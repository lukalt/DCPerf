diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/build.sh treadmill/build.sh
--- treadmill-src/build.sh	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/build.sh	2025-08-04 15:44:21.731476550 -0700
@@ -0,0 +1,42 @@
+#!/bin/bash
+
+# Exit on error
+set -e
+
+# Set environment variables
+source ../config.sh
+
+# Parse arguments
+ENABLE_SLEEP=OFF
+INSTALL=false
+
+
+sudo dnf install -y numactl-devel
+# Create build directory
+mkdir -p build
+cd build
+
+# Configure with CMake
+echo "Configuring with CMake..."
+echo "BUILD_TREADMILL_SLEEP=$ENABLE_SLEEP"
+
+cmake .. \
+    -DCMAKE_INSTALL_PREFIX=${ADSIM_STAGING_DIR} \
+    -DCMAKE_PREFIX_PATH=${ADSIM_STAGING_DIR} \
+    -DCMAKE_CXX_COMPILER=clang++ \
+    -DCMAKE_C_COMPILER=clang \
+    -DBUILD_TREADMILL_SLEEP=$ENABLE_SLEEP \
+    -DADSIM_STAGING_DIR=${ADSIM_STAGING_DIR}
+
+# Build
+echo "Building treadmill..."
+cmake --build . -j$(nproc)
+
+# Install (optional)
+if [ "$INSTALL" = true ]; then
+    echo "Installing treadmill to ${ADSIM_STAGING_DIR}..."
+    cmake --install .
+fi
+
+echo "Build completed successfully!"
+echo "Executables are located in: $(pwd)"
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FBCMakeParseArgs.cmake treadmill/CMake/FBCMakeParseArgs.cmake
--- treadmill-src/CMake/FBCMakeParseArgs.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FBCMakeParseArgs.cmake	2025-08-04 15:44:21.733051431 -0700
@@ -0,0 +1,141 @@
+#
+# Copyright (c) Facebook, Inc. and its affiliates.
+#
+# Helper function for parsing arguments to a CMake function.
+#
+# This function is very similar to CMake's built-in cmake_parse_arguments()
+# function, with some improvements:
+# - This function correctly handles empty arguments.  (cmake_parse_arguments()
+#   ignores empty arguments.)
+# - If a multi-value argument is specified more than once, the subsequent
+#   arguments are appended to the original list rather than replacing it.  e.g.
+#   if "SOURCES" is a multi-value argument, and the argument list contains
+#   "SOURCES a b c SOURCES x y z" then the resulting value for SOURCES will be
+#   "a;b;c;x;y;z" rather than "x;y;z"
+# - This function errors out by default on unrecognized arguments.  You can
+#   pass in an extra "ALLOW_UNPARSED_ARGS" argument to make it behave like
+#   cmake_parse_arguments(), and return the unparsed arguments in a
+#   <prefix>_UNPARSED_ARGUMENTS variable instead.
+#
+# It does look like cmake_parse_arguments() handled empty arguments correctly
+# from CMake 3.0 through 3.3, but it seems like this was probably broken when
+# it was turned into a built-in function in CMake 3.4.  Here is discussion and
+# patches that fixed this behavior prior to CMake 3.0:
+# https://cmake.org/pipermail/cmake-developers/2013-November/020607.html
+#
+# The one downside to this function over the built-in cmake_parse_arguments()
+# is that I don't think we can achieve the PARSE_ARGV behavior in a non-builtin
+# function, so we can't properly handle arguments that contain ";".  CMake will
+# treat the ";" characters as list element separators, and treat it as multiple
+# separate arguments.
+#
+function(fb_cmake_parse_args PREFIX OPTIONS ONE_VALUE_ARGS MULTI_VALUE_ARGS ARGS)
+  foreach(option IN LISTS ARGN)
+    if ("${option}" STREQUAL "ALLOW_UNPARSED_ARGS")
+      set(ALLOW_UNPARSED_ARGS TRUE)
+    else()
+      message(
+        FATAL_ERROR
+        "unknown optional argument for fb_cmake_parse_args(): ${option}"
+      )
+    endif()
+  endforeach()
+
+  # Define all options as FALSE in the parent scope to start with
+  foreach(var_name IN LISTS OPTIONS)
+    set("${PREFIX}_${var_name}" "FALSE" PARENT_SCOPE)
+  endforeach()
+
+  # TODO: We aren't extremely strict about error checking for one-value
+  # arguments here.  e.g., we don't complain if a one-value argument is
+  # followed by another option/one-value/multi-value name rather than an
+  # argument.  We also don't complain if a one-value argument is the last
+  # argument and isn't followed by a value.
+
+  list(APPEND all_args ${ONE_VALUE_ARGS})
+  list(APPEND all_args ${MULTI_VALUE_ARGS})
+  set(current_variable)
+  set(unparsed_args)
+  foreach(arg IN LISTS ARGS)
+    list(FIND OPTIONS "${arg}" opt_index)
+    if("${opt_index}" EQUAL -1)
+      list(FIND all_args "${arg}" arg_index)
+      if("${arg_index}" EQUAL -1)
+        # This argument does not match an argument name,
+        # must be an argument value
+        if("${current_variable}" STREQUAL "")
+          list(APPEND unparsed_args "${arg}")
+        else()
+          # Ugh, CMake lists have a pretty fundamental flaw: they cannot
+          # distinguish between an empty list and a list with a single empty
+          # element.  We track our own SEEN_VALUES_arg setting to help
+          # distinguish this and behave properly here.
+          if ("${SEEN_${current_variable}}" AND "${${current_variable}}" STREQUAL "")
+            set("${current_variable}" ";${arg}")
+          else()
+            list(APPEND "${current_variable}" "${arg}")
+          endif()
+          set("SEEN_${current_variable}" TRUE)
+        endif()
+      else()
+        # We found a single- or multi-value argument name
+        set(current_variable "VALUES_${arg}")
+        set("SEEN_${arg}" TRUE)
+      endif()
+    else()
+      # We found an option variable
+      set("${PREFIX}_${arg}" "TRUE" PARENT_SCOPE)
+      set(current_variable)
+    endif()
+  endforeach()
+
+  foreach(arg_name IN LISTS ONE_VALUE_ARGS)
+    if(NOT "${SEEN_${arg_name}}")
+      unset("${PREFIX}_${arg_name}" PARENT_SCOPE)
+    elseif(NOT "${SEEN_VALUES_${arg_name}}")
+      # If the argument was seen but a value wasn't specified, error out.
+      # We require exactly one value to be specified.
+      message(
+        FATAL_ERROR "argument ${arg_name} was specified without a value"
+      )
+    else()
+      list(LENGTH "VALUES_${arg_name}" num_args)
+      if("${num_args}" EQUAL 0)
+        # We know an argument was specified and that we called list(APPEND).
+        # If CMake thinks the list is empty that means there is really a single
+        # empty element in the list.
+        set("${PREFIX}_${arg_name}" "" PARENT_SCOPE)
+      elseif("${num_args}" EQUAL 1)
+        list(GET "VALUES_${arg_name}" 0 arg_value)
+        set("${PREFIX}_${arg_name}" "${arg_value}" PARENT_SCOPE)
+      else()
+        message(
+          FATAL_ERROR "too many arguments specified for ${arg_name}: "
+          "${VALUES_${arg_name}}"
+        )
+      endif()
+    endif()
+  endforeach()
+
+  foreach(arg_name IN LISTS MULTI_VALUE_ARGS)
+    # If this argument name was never seen, then unset the parent scope
+    if (NOT "${SEEN_${arg_name}}")
+      unset("${PREFIX}_${arg_name}" PARENT_SCOPE)
+    else()
+      # TODO: Our caller still won't be able to distinguish between an empty
+      # list and a list with a single empty element.  We can tell which is
+      # which, but CMake lists don't make it easy to show this to our caller.
+      set("${PREFIX}_${arg_name}" "${VALUES_${arg_name}}" PARENT_SCOPE)
+    endif()
+  endforeach()
+
+  # By default we fatal out on unparsed arguments, but return them to the
+  # caller if ALLOW_UNPARSED_ARGS was specified.
+  if (DEFINED unparsed_args)
+    if ("${ALLOW_UNPARSED_ARGS}")
+      set("${PREFIX}_UNPARSED_ARGUMENTS" "${unparsed_args}" PARENT_SCOPE)
+    else()
+      message(FATAL_ERROR "unrecognized arguments: ${unparsed_args}")
+    endif()
+  endif()
+endfunction()
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FBThriftCppLibrary.cmake treadmill/CMake/FBThriftCppLibrary.cmake
--- treadmill-src/CMake/FBThriftCppLibrary.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FBThriftCppLibrary.cmake	2025-08-04 15:44:21.734044042 -0700
@@ -0,0 +1,194 @@
+# Copyright (c) Facebook, Inc. and its affiliates.
+
+include(FBCMakeParseArgs)
+
+# Generate a C++ library from a thrift file
+#
+# Parameters:
+# - SERVICES <svc1> [<svc2> ...]
+#   The names of the services defined in the thrift file.
+# - DEPENDS <dep1> [<dep2> ...]
+#   A list of other thrift C++ libraries that this library depends on.
+# - OPTIONS <opt1> [<opt2> ...]
+#   A list of options to pass to the thrift compiler.
+# - INCLUDE_DIR <path>
+#   The sub-directory where generated headers will be installed.
+#   Defaults to "include" if not specified.  The caller must still call
+#   install() to install the thrift library if desired.
+# - THRIFT_INCLUDE_DIR <path>
+#   The sub-directory where generated headers will be installed.
+#   Defaults to "${INCLUDE_DIR}/thrift-files" if not specified.
+#   The caller must still call install() to install the thrift library if
+#   desired.
+function(add_fbthrift_cpp_library LIB_NAME THRIFT_FILE)
+  # Parse the arguments
+  set(one_value_args INCLUDE_DIR THRIFT_INCLUDE_DIR)
+  set(multi_value_args SERVICES DEPENDS OPTIONS)
+  fb_cmake_parse_args(
+    ARG "" "${one_value_args}" "${multi_value_args}" "${ARGN}"
+  )
+  if(NOT DEFINED ARG_INCLUDE_DIR)
+    set(ARG_INCLUDE_DIR "include")
+  endif()
+  if(NOT DEFINED ARG_THRIFT_INCLUDE_DIR)
+    set(ARG_THRIFT_INCLUDE_DIR "${ARG_INCLUDE_DIR}/thrift-files")
+  endif()
+
+  get_filename_component(base ${THRIFT_FILE} NAME_WE)
+  get_filename_component(
+    output_dir
+    ${CMAKE_CURRENT_BINARY_DIR}/${THRIFT_FILE}
+    DIRECTORY
+  )
+
+  # Generate relative paths in #includes
+  file(
+    RELATIVE_PATH include_prefix
+    "${CMAKE_SOURCE_DIR}"
+    "${CMAKE_CURRENT_SOURCE_DIR}/${THRIFT_FILE}"
+  )
+  get_filename_component(include_prefix ${include_prefix} DIRECTORY)
+
+  if (NOT "${include_prefix}" STREQUAL "")
+    list(APPEND ARG_OPTIONS "include_prefix=${include_prefix}")
+  endif()
+  # CMake 3.12 is finally getting a list(JOIN) function, but until then
+  # treating the list as a string and replacing the semicolons is good enough.
+  string(REPLACE ";" "," GEN_ARG_STR "${ARG_OPTIONS}")
+
+  # Compute the list of generated files
+  list(APPEND generated_headers
+    "${output_dir}/gen-cpp2/${base}_constants.h"
+    "${output_dir}/gen-cpp2/${base}_types.h"
+    "${output_dir}/gen-cpp2/${base}_types.tcc"
+    "${output_dir}/gen-cpp2/${base}_types_custom_protocol.h"
+    "${output_dir}/gen-cpp2/${base}_metadata.h"
+  )
+  list(APPEND generated_sources
+    "${output_dir}/gen-cpp2/${base}_constants.cpp"
+    "${output_dir}/gen-cpp2/${base}_data.h"
+    "${output_dir}/gen-cpp2/${base}_data.cpp"
+    "${output_dir}/gen-cpp2/${base}_types.cpp"
+    "${output_dir}/gen-cpp2/${base}_metadata.cpp"
+  )
+  foreach(service IN LISTS ARG_SERVICES)
+    list(APPEND generated_headers
+      "${output_dir}/gen-cpp2/${service}.h"
+      "${output_dir}/gen-cpp2/${service}.tcc"
+      "${output_dir}/gen-cpp2/${service}AsyncClient.h"
+      "${output_dir}/gen-cpp2/${service}_custom_protocol.h"
+    )
+    list(APPEND generated_sources
+      "${output_dir}/gen-cpp2/${service}.cpp"
+      "${output_dir}/gen-cpp2/${service}AsyncClient.cpp"
+      "${output_dir}/gen-cpp2/${service}_processmap_binary.cpp"
+      "${output_dir}/gen-cpp2/${service}_processmap_compact.cpp"
+    )
+  endforeach()
+
+  # This generator expression gets the list of include directories required
+  # for all of our dependencies.
+  # It requires using COMMAND_EXPAND_LISTS in the add_custom_command() call
+  # below.  COMMAND_EXPAND_LISTS is only available in CMake 3.8+
+  # If we really had to support older versions of CMake we would probably need
+  # to use a wrapper script around the thrift compiler that could take the
+  # include list as a single argument and split it up before invoking the
+  # thrift compiler.
+  if (NOT POLICY CMP0067)
+    message(FATAL_ERROR "add_fbthrift_cpp_library() requires CMake 3.8+")
+  endif()
+  set(
+    thrift_include_options
+    "-I;$<JOIN:$<TARGET_PROPERTY:${LIB_NAME}.thrift_includes,INTERFACE_INCLUDE_DIRECTORIES>,;-I;>"
+  )
+
+  # Emit the rule to run the thrift compiler
+  add_custom_command(
+    OUTPUT
+      ${generated_headers}
+      ${generated_sources}
+    COMMAND_EXPAND_LISTS
+    COMMAND
+      "${CMAKE_COMMAND}" -E make_directory "${output_dir}"
+    COMMAND
+      "${FBTHRIFT_COMPILER}"
+      --legacy-strict
+      --gen "mstch_cpp2:${GEN_ARG_STR}"
+      "${thrift_include_options}"
+      -o "${output_dir}"
+      "${CMAKE_CURRENT_SOURCE_DIR}/${THRIFT_FILE}"
+    WORKING_DIRECTORY
+      "${CMAKE_BINARY_DIR}"
+    MAIN_DEPENDENCY
+      "${THRIFT_FILE}"
+    DEPENDS
+      ${ARG_DEPENDS}
+      "${FBTHRIFT_COMPILER}"
+  )
+
+  # Now emit the library rule to compile the sources
+  if (BUILD_SHARED_LIBS)
+    set(LIB_TYPE SHARED)
+  else ()
+    set(LIB_TYPE STATIC)
+  endif ()
+
+  add_library(
+    "${LIB_NAME}" ${LIB_TYPE}
+    ${generated_sources}
+  )
+
+  target_include_directories(
+    "${LIB_NAME}"
+    PUBLIC
+      "$<BUILD_INTERFACE:${CMAKE_BINARY_DIR}>"
+      "$<INSTALL_INTERFACE:${ARG_INCLUDE_DIR}>"
+  )
+  target_link_libraries(
+    "${LIB_NAME}"
+    PUBLIC
+      ${ARG_DEPENDS}
+      FBThrift::thriftcpp2
+      Folly::folly
+  )
+
+  # Add ${generated_headers} to the PUBLIC_HEADER property for ${LIB_NAME}
+  #
+  # This allows callers to install it using
+  # "install(TARGETS ${LIB_NAME} PUBLIC_HEADER)"
+  # However, note that CMake's PUBLIC_HEADER behavior is rather inflexible,
+  # and does have any way to preserve header directory structure.  Callers
+  # must be careful to use the correct PUBLIC_HEADER DESTINATION parameter
+  # when doing this, to put the files the correct directory themselves.
+  # We define a HEADER_INSTALL_DIR property with the include directory prefix,
+  # so typically callers should specify the PUBLIC_HEADER DESTINATION as
+  # "$<TARGET_PROPERTY:${LIB_NAME},HEADER_INSTALL_DIR>"
+  set_property(
+    TARGET "${LIB_NAME}"
+    PROPERTY PUBLIC_HEADER ${generated_headers}
+  )
+
+  # Define a dummy interface library to help propagate the thrift include
+  # directories between dependencies.
+  add_library("${LIB_NAME}.thrift_includes" INTERFACE)
+  target_include_directories(
+    "${LIB_NAME}.thrift_includes"
+    INTERFACE
+      "$<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}>"
+      "$<INSTALL_INTERFACE:${ARG_THRIFT_INCLUDE_DIR}>"
+  )
+  foreach(dep IN LISTS ARG_DEPENDS)
+    target_link_libraries(
+      "${LIB_NAME}.thrift_includes"
+      INTERFACE "${dep}.thrift_includes"
+    )
+  endforeach()
+
+  set_target_properties(
+    "${LIB_NAME}"
+    PROPERTIES
+      EXPORT_PROPERTIES "THRIFT_INSTALL_DIR"
+      THRIFT_INSTALL_DIR "${ARG_THRIFT_INCLUDE_DIR}/${include_prefix}"
+      HEADER_INSTALL_DIR "${ARG_INCLUDE_DIR}/${include_prefix}/gen-cpp2"
+  )
+endfunction()
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindCereal.cmake treadmill/CMake/FindCereal.cmake
--- treadmill-src/CMake/FindCereal.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindCereal.cmake	2025-08-04 15:44:21.734737942 -0700
@@ -0,0 +1,21 @@
+find_path(Cereal_INCLUDE_DIR
+    NAMES cereal/cereal.hpp
+    PATHS "${CMAKE_SOURCE_DIR}/third_party/cereal"
+    PATH_SUFFIXES
+        include)
+
+mark_as_advanced(Cereal_INCLUDE_DIR)
+
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(Cereal
+    REQUIRED_VARS Cereal_INCLUDE_DIR
+)
+
+if(Cereal_FOUND AND NOT TARGET Cereal::Cereal)
+    add_library(Cereal::Cereal INTERFACE IMPORTED)
+
+    set_target_properties(Cereal::Cereal PROPERTIES
+        INTERFACE_INCLUDE_DIRECTORIES "${Cereal_INCLUDE_DIR}"
+    )
+endif()
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindDoubleConversion.cmake treadmill/CMake/FindDoubleConversion.cmake
--- treadmill-src/CMake/FindDoubleConversion.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindDoubleConversion.cmake	2025-08-04 15:44:21.735422076 -0700
@@ -0,0 +1,26 @@
+# Copyright (c) 2017-present, Facebook, Inc. and its affiliates.
+# All rights reserved.
+#
+# This source code is licensed under the BSD-style license found in the
+# LICENSE file in the root directory of this source tree.
+
+find_path(DOUBLE_CONVERSION_INCLUDE_DIR
+    NAMES
+      double-conversion.h
+    PATHS
+      /usr/include/double-conversion
+      /usr/local/include/double-conversion)
+find_library(DOUBLE_CONVERSION_LIBRARY NAMES double-conversion)
+
+include(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(
+    DoubleConversion DEFAULT_MSG
+    DOUBLE_CONVERSION_LIBRARY DOUBLE_CONVERSION_INCLUDE_DIR)
+
+if (NOT DOUBLE_CONVERSION_FOUND)
+  message(STATUS "Using third-party bundled double-conversion")
+else()
+  message(STATUS "Found double-conversion: ${DOUBLE_CONVERSION_LIBRARY}")
+endif ()
+
+mark_as_advanced(DOUBLE_CONVERSION_INCLUDE_DIR DOUBLE_CONVERSION_LIBRARY)
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindGflags.cmake treadmill/CMake/FindGflags.cmake
--- treadmill-src/CMake/FindGflags.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindGflags.cmake	2025-08-04 15:44:21.736158410 -0700
@@ -0,0 +1,105 @@
+# Copyright (c) Facebook, Inc. and its affiliates.
+# Find libgflags.
+# There's a lot of compatibility cruft going on in here, both
+# to deal with changes across the FB consumers of this and also
+# to deal with variances in behavior of cmake itself.
+#
+# Since this file is named FindGflags.cmake the cmake convention
+# is for the module to export both GFLAGS_FOUND and Gflags_FOUND.
+# The convention expected by consumers is that we export the
+# following variables, even though these do not match the cmake
+# conventions:
+#
+#  LIBGFLAGS_INCLUDE_DIR - where to find gflags/gflags.h, etc.
+#  LIBGFLAGS_LIBRARY     - List of libraries when using libgflags.
+#  LIBGFLAGS_FOUND       - True if libgflags found.
+#
+# We need to be able to locate gflags both from an installed
+# cmake config file and just from the raw headers and libs, so
+# test for the former and then the latter, and then stick
+# the results together and export them into the variables
+# listed above.
+#
+# For forwards compatibility, we export the following variables:
+#
+#  gflags_INCLUDE_DIR - where to find gflags/gflags.h, etc.
+#  gflags_TARGET / GFLAGS_TARGET / gflags_LIBRARIES
+#                     - List of libraries when using libgflags.
+#  gflags_FOUND       - True if libgflags found.
+#
+
+IF (LIBGFLAGS_INCLUDE_DIR)
+  # Already in cache, be silent
+  SET(Gflags_FIND_QUIETLY TRUE)
+ENDIF ()
+
+find_package(gflags CONFIG QUIET)
+if (gflags_FOUND)
+  if (NOT Gflags_FIND_QUIETLY)
+    message(STATUS "Found gflags from package config ${gflags_CONFIG}")
+  endif()
+  # Re-export the config-specified libs with our local names
+  set(LIBGFLAGS_LIBRARY ${gflags_LIBRARIES})
+  set(LIBGFLAGS_INCLUDE_DIR ${gflags_INCLUDE_DIR})
+  if(NOT EXISTS "${gflags_INCLUDE_DIR}")
+    # The gflags-devel RPM on recent RedHat-based systems is somewhat broken.
+    # RedHat symlinks /lib64 to /usr/lib64, and this breaks some of the
+    # relative path computation performed in gflags-config.cmake.  The package
+    # config file ends up being found via /lib64, but the relative path
+    # computation it does only works if it was found in /usr/lib64.
+    # If gflags_INCLUDE_DIR does not actually exist, simply default it to
+    # /usr/include on these systems.
+    set(LIBGFLAGS_INCLUDE_DIR "/usr/include")
+  endif()
+  set(LIBGFLAGS_FOUND ${gflags_FOUND})
+  # cmake module compat
+  set(GFLAGS_FOUND ${gflags_FOUND})
+  set(Gflags_FOUND ${gflags_FOUND})
+else()
+  FIND_PATH(LIBGFLAGS_INCLUDE_DIR gflags/gflags.h)
+
+  FIND_LIBRARY(LIBGFLAGS_LIBRARY_DEBUG NAMES gflagsd gflags_staticd)
+  FIND_LIBRARY(LIBGFLAGS_LIBRARY_RELEASE NAMES gflags gflags_static)
+
+  INCLUDE(SelectLibraryConfigurations)
+  SELECT_LIBRARY_CONFIGURATIONS(LIBGFLAGS)
+
+  # handle the QUIETLY and REQUIRED arguments and set LIBGFLAGS_FOUND to TRUE if
+  # all listed variables are TRUE
+  INCLUDE(FindPackageHandleStandardArgs)
+  FIND_PACKAGE_HANDLE_STANDARD_ARGS(gflags DEFAULT_MSG LIBGFLAGS_LIBRARY LIBGFLAGS_INCLUDE_DIR)
+  # cmake module compat
+  set(Gflags_FOUND ${GFLAGS_FOUND})
+  # compat with some existing FindGflags consumers
+  set(LIBGFLAGS_FOUND ${GFLAGS_FOUND})
+
+  # Compat with the gflags CONFIG based detection
+  set(gflags_FOUND ${GFLAGS_FOUND})
+  set(gflags_INCLUDE_DIR ${LIBGFLAGS_INCLUDE_DIR})
+  set(gflags_LIBRARIES ${LIBGFLAGS_LIBRARY})
+  set(GFLAGS_TARGET ${LIBGFLAGS_LIBRARY})
+  set(gflags_TARGET ${LIBGFLAGS_LIBRARY})
+
+  MARK_AS_ADVANCED(LIBGFLAGS_LIBRARY LIBGFLAGS_INCLUDE_DIR)
+endif()
+
+# Compat with the gflags CONFIG based detection
+if (LIBGFLAGS_FOUND AND NOT TARGET gflags)
+  add_library(gflags UNKNOWN IMPORTED)
+  if(TARGET gflags-shared)
+    # If the installed gflags CMake package config defines a gflags-shared
+    # target but not gflags, just make the gflags target that we define
+    # depend on the gflags-shared target.
+    target_link_libraries(gflags INTERFACE gflags-shared)
+    # Export LIBGFLAGS_LIBRARY as the gflags-shared target in this case.
+    set(LIBGFLAGS_LIBRARY gflags-shared)
+  else()
+    set_target_properties(
+      gflags
+      PROPERTIES
+        IMPORTED_LINK_INTERFACE_LANGUAGES "C"
+        IMPORTED_LOCATION "${LIBGFLAGS_LIBRARY}"
+        INTERFACE_INCLUDE_DIRECTORIES "${LIBGFLAGS_INCLUDE_DIR}"
+    )
+  endif()
+endif()
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindGlog.cmake treadmill/CMake/FindGlog.cmake
--- treadmill-src/CMake/FindGlog.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindGlog.cmake	2025-08-04 15:44:21.736813991 -0700
@@ -0,0 +1,37 @@
+# Copyright (c) Facebook, Inc. and its affiliates.
+# - Try to find Glog
+# Once done, this will define
+#
+# GLOG_FOUND - system has Glog
+# GLOG_INCLUDE_DIRS - the Glog include directories
+# GLOG_LIBRARIES - link these to use Glog
+
+include(FindPackageHandleStandardArgs)
+include(SelectLibraryConfigurations)
+
+find_library(GLOG_LIBRARY_RELEASE glog
+  PATHS ${GLOG_LIBRARYDIR})
+find_library(GLOG_LIBRARY_DEBUG glogd
+  PATHS ${GLOG_LIBRARYDIR})
+
+find_path(GLOG_INCLUDE_DIR glog/logging.h
+  PATHS ${GLOG_INCLUDEDIR})
+
+select_library_configurations(GLOG)
+
+find_package_handle_standard_args(glog DEFAULT_MSG
+  GLOG_LIBRARY
+  GLOG_INCLUDE_DIR)
+
+mark_as_advanced(
+  GLOG_LIBRARY
+  GLOG_INCLUDE_DIR)
+
+set(GLOG_LIBRARIES ${GLOG_LIBRARY})
+set(GLOG_INCLUDE_DIRS ${GLOG_INCLUDE_DIR})
+
+if (NOT TARGET glog::glog)
+  add_library(glog::glog UNKNOWN IMPORTED)
+  set_target_properties(glog::glog PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${GLOG_INCLUDE_DIRS}")
+  set_target_properties(glog::glog PROPERTIES IMPORTED_LINK_INTERFACE_LANGUAGES "C" IMPORTED_LOCATION "${GLOG_LIBRARIES}")
+endif()
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindGMock.cmake treadmill/CMake/FindGMock.cmake
--- treadmill-src/CMake/FindGMock.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindGMock.cmake	2025-08-04 15:44:21.737281097 -0700
@@ -0,0 +1,80 @@
+# Copyright (c) Facebook, Inc. and its affiliates.
+# Find libgmock
+#
+#  LIBGMOCK_DEFINES     - List of defines when using libgmock.
+#  LIBGMOCK_INCLUDE_DIR - where to find gmock/gmock.h, etc.
+#  LIBGMOCK_LIBRARIES   - List of libraries when using libgmock.
+#  LIBGMOCK_FOUND       - True if libgmock found.
+
+IF (LIBGMOCK_INCLUDE_DIR)
+  # Already in cache, be silent
+  SET(LIBGMOCK_FIND_QUIETLY TRUE)
+ENDIF ()
+
+find_package(GTest CONFIG QUIET)
+if (TARGET GTest::gmock)
+  get_target_property(LIBGMOCK_DEFINES GTest::gtest INTERFACE_COMPILE_DEFINITIONS)
+  if (NOT ${LIBGMOCK_DEFINES})
+    # Explicitly set to empty string if not found to avoid it being
+    # set to NOTFOUND and breaking compilation
+    set(LIBGMOCK_DEFINES "")
+  endif()
+  get_target_property(LIBGMOCK_INCLUDE_DIR GTest::gtest INTERFACE_INCLUDE_DIRECTORIES)
+  set(LIBGMOCK_LIBRARIES GTest::gmock_main GTest::gmock GTest::gtest)
+  set(LIBGMOCK_FOUND ON)
+  message(STATUS "Found gmock via config, defines=${LIBGMOCK_DEFINES}, include=${LIBGMOCK_INCLUDE_DIR}, libs=${LIBGMOCK_LIBRARIES}")
+else()
+
+  FIND_PATH(LIBGMOCK_INCLUDE_DIR gmock/gmock.h)
+
+  FIND_LIBRARY(LIBGMOCK_MAIN_LIBRARY_DEBUG NAMES gmock_maind)
+  FIND_LIBRARY(LIBGMOCK_MAIN_LIBRARY_RELEASE NAMES gmock_main)
+  FIND_LIBRARY(LIBGMOCK_LIBRARY_DEBUG NAMES gmockd)
+  FIND_LIBRARY(LIBGMOCK_LIBRARY_RELEASE NAMES gmock)
+  FIND_LIBRARY(LIBGTEST_LIBRARY_DEBUG NAMES gtestd)
+  FIND_LIBRARY(LIBGTEST_LIBRARY_RELEASE NAMES gtest)
+
+  find_package(Threads REQUIRED)
+  INCLUDE(SelectLibraryConfigurations)
+  SELECT_LIBRARY_CONFIGURATIONS(LIBGMOCK_MAIN)
+  SELECT_LIBRARY_CONFIGURATIONS(LIBGMOCK)
+  SELECT_LIBRARY_CONFIGURATIONS(LIBGTEST)
+
+  set(LIBGMOCK_LIBRARIES
+    ${LIBGMOCK_MAIN_LIBRARY}
+    ${LIBGMOCK_LIBRARY}
+    ${LIBGTEST_LIBRARY}
+    Threads::Threads
+  )
+
+  if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
+    # The GTEST_LINKED_AS_SHARED_LIBRARY macro must be set properly on Windows.
+    #
+    # There isn't currently an easy way to determine if a library was compiled as
+    # a shared library on Windows, so just assume we've been built against a
+    # shared build of gmock for now.
+    SET(LIBGMOCK_DEFINES "GTEST_LINKED_AS_SHARED_LIBRARY=1" CACHE STRING "")
+  endif()
+
+  # handle the QUIETLY and REQUIRED arguments and set LIBGMOCK_FOUND to TRUE if
+  # all listed variables are TRUE
+  INCLUDE(FindPackageHandleStandardArgs)
+  FIND_PACKAGE_HANDLE_STANDARD_ARGS(
+    GMock
+    DEFAULT_MSG
+    LIBGMOCK_MAIN_LIBRARY
+    LIBGMOCK_LIBRARY
+    LIBGTEST_LIBRARY
+    LIBGMOCK_LIBRARIES
+    LIBGMOCK_INCLUDE_DIR
+  )
+
+  MARK_AS_ADVANCED(
+    LIBGMOCK_DEFINES
+    LIBGMOCK_MAIN_LIBRARY
+    LIBGMOCK_LIBRARY
+    LIBGTEST_LIBRARY
+    LIBGMOCK_LIBRARIES
+    LIBGMOCK_INCLUDE_DIR
+  )
+endif()
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindLibEvent.cmake treadmill/CMake/FindLibEvent.cmake
--- treadmill-src/CMake/FindLibEvent.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindLibEvent.cmake	2025-08-04 15:44:21.737884690 -0700
@@ -0,0 +1,38 @@
+# - Find LibEvent (a cross event library)
+# This module defines
+# LIBEVENT_INCLUDE_DIR, where to find LibEvent headers
+# LIBEVENT_LIB, LibEvent libraries
+# LibEvent_FOUND, If false, do not try to use libevent
+
+set(LibEvent_EXTRA_PREFIXES /usr/local /opt/local "$ENV{HOME}")
+foreach(prefix ${LibEvent_EXTRA_PREFIXES})
+  list(APPEND LibEvent_INCLUDE_PATHS "${prefix}/include")
+  list(APPEND LibEvent_LIB_PATHS "${prefix}/lib")
+endforeach()
+
+find_path(LIBEVENT_INCLUDE_DIR event.h PATHS ${LibEvent_INCLUDE_PATHS})
+find_library(LIBEVENT_LIB NAMES event PATHS ${LibEvent_LIB_PATHS})
+find_library(LIBEVENT_PTHREAD_LIB NAMES event_pthreads PATHS ${LibEvent_LIB_PATHS})
+
+if (LIBEVENT_LIB AND LIBEVENT_INCLUDE_DIR AND LIBEVENT_PTHREAD_LIB)
+  set(LibEvent_FOUND TRUE)
+  set(LIBEVENT_LIB ${LIBEVENT_LIB} ${LIBEVENT_PTHREAD_LIB})
+else ()
+  set(LibEvent_FOUND FALSE)
+endif ()
+
+if (LibEvent_FOUND)
+  if (NOT LibEvent_FIND_QUIETLY)
+    message(STATUS "Found libevent: ${LIBEVENT_LIB}")
+  endif ()
+else ()
+  if (LibEvent_FIND_REQUIRED)
+    message(FATAL_ERROR "Could NOT find libevent and libevent_pthread.")
+  endif ()
+  message(STATUS "libevent and libevent_pthread NOT found.")
+endif ()
+
+mark_as_advanced(
+    LIBEVENT_LIB
+    LIBEVENT_INCLUDE_DIR
+  )
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindLibIberty.cmake treadmill/CMake/FindLibIberty.cmake
--- treadmill-src/CMake/FindLibIberty.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindLibIberty.cmake	2025-08-04 15:44:21.738594913 -0700
@@ -0,0 +1,25 @@
+# Copyright (c) 2017-present, Facebook, Inc. and its affiliates.
+# All rights reserved.
+#
+# This source code is licensed under the BSD-style license found in the
+# LICENSE file in the root directory of this source tree.
+
+FIND_LIBRARY(IBERTY_LIBRARIES
+        NAMES iberty_pic iberty)
+
+IF (IBERTY_LIBRARIES)
+
+   # show which libiberty was found only if not quiet
+   MESSAGE( STATUS "Found libiberty: ${IBERTY_LIBRARIES}")
+
+   SET(IBERTY_FOUND TRUE)
+
+ELSE (IBERTY_LIBRARIES)
+
+   IF ( IBERTY_FIND_REQUIRED)
+      MESSAGE(FATAL_ERROR "Could not find libiberty. Try to install binutil-devel?")
+   ELSE()
+      MESSAGE(STATUS "Could not find libiberty; downloading binutils and building PIC libiberty.")
+   ENDIF (IBERTY_FIND_REQUIRED)
+
+ENDIF (IBERTY_LIBRARIES)
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindLZ4.cmake treadmill/CMake/FindLZ4.cmake
--- treadmill-src/CMake/FindLZ4.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindLZ4.cmake	2025-08-04 15:44:21.739204906 -0700
@@ -0,0 +1,21 @@
+# Copyright (c) 2017-present, Facebook, Inc. and its affiliates.
+# All rights reserved.
+#
+# This source code is licensed under the BSD-style license found in the
+# LICENSE file in the root directory of this source tree.
+
+find_path(LZ4_INCLUDE_DIR NAMES lz4.h)
+find_library(LZ4_LIBRARY NAMES lz4)
+
+include(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(
+    LZ4 DEFAULT_MSG
+    LZ4_LIBRARY LZ4_INCLUDE_DIR)
+
+if (NOT LZ4_FOUND)
+  message(STATUS "Using third-party bundled LZ4")
+else()
+  message(STATUS "Found LZ4: ${LZ4_LIBRARY}")
+endif (NOT LZ4_FOUND)
+
+mark_as_advanced(LZ4_INCLUDE_DIR LZ4_LIBRARY)
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindSnappy.cmake treadmill/CMake/FindSnappy.cmake
--- treadmill-src/CMake/FindSnappy.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindSnappy.cmake	2025-08-04 15:44:21.739902771 -0700
@@ -0,0 +1,21 @@
+# Copyright (c) 2017-present, Facebook, Inc. and its affiliates.
+# All rights reserved.
+#
+# This source code is licensed under the BSD-style license found in the
+# LICENSE file in the root directory of this source tree.
+
+find_path(SNAPPY_INCLUDE_DIR NAMES snappy.h)
+find_library(SNAPPY_LIBRARY NAMES snappy)
+
+include(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(
+    Snappy DEFAULT_MSG
+    SNAPPY_LIBRARY SNAPPY_INCLUDE_DIR)
+
+if (NOT SNAPPY_FOUND)
+  message(STATUS "Using third-party bundled Snappy")
+else()
+  message(STATUS "Found Snappy: ${SNAPPY_LIBRARY}")
+endif (NOT SNAPPY_FOUND)
+
+mark_as_advanced(SNAPPY_INCLUDE_DIR SNAPPY_LIBRARY)
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindSodium.cmake treadmill/CMake/FindSodium.cmake
--- treadmill-src/CMake/FindSodium.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindSodium.cmake	2025-08-04 15:44:21.740726787 -0700
@@ -0,0 +1,297 @@
+# Written in 2016 by Henrik Steffen Ga√ümann <henrik@gassmann.onl>
+#
+# To the extent possible under law, the author(s) have dedicated all
+# copyright and related and neighboring rights to this software to the
+# public domain worldwide. This software is distributed without any warranty.
+#
+# You should have received a copy of the CC0 Public Domain Dedication
+# along with this software. If not, see
+#
+#     http://creativecommons.org/publicdomain/zero/1.0/
+#
+########################################################################
+# Tries to find the local libsodium installation.
+#
+# On Windows the sodium_DIR environment variable is used as a default
+# hint which can be overridden by setting the corresponding cmake variable.
+#
+# Once done the following variables will be defined:
+#
+#   sodium_FOUND
+#   sodium_INCLUDE_DIR
+#   sodium_LIBRARY_DEBUG
+#   sodium_LIBRARY_RELEASE
+#
+#
+# Furthermore an imported "sodium" target is created.
+#
+
+if (CMAKE_C_COMPILER_ID STREQUAL "GNU"
+    OR CMAKE_C_COMPILER_ID STREQUAL "Clang")
+    set(_GCC_COMPATIBLE 1)
+endif()
+
+# static library option
+if (NOT DEFINED sodium_USE_STATIC_LIBS)
+    option(sodium_USE_STATIC_LIBS "enable to statically link against sodium" OFF)
+endif()
+if(NOT (sodium_USE_STATIC_LIBS EQUAL sodium_USE_STATIC_LIBS_LAST))
+    unset(sodium_LIBRARY CACHE)
+    unset(sodium_LIBRARY_DEBUG CACHE)
+    unset(sodium_LIBRARY_RELEASE CACHE)
+    unset(sodium_DLL_DEBUG CACHE)
+    unset(sodium_DLL_RELEASE CACHE)
+    set(sodium_USE_STATIC_LIBS_LAST ${sodium_USE_STATIC_LIBS} CACHE INTERNAL "internal change tracking variable")
+endif()
+
+
+########################################################################
+# UNIX
+if (UNIX)
+    # import pkg-config
+    find_package(PkgConfig QUIET)
+    if (PKG_CONFIG_FOUND)
+        pkg_check_modules(sodium_PKG QUIET libsodium)
+    endif()
+
+    if(sodium_USE_STATIC_LIBS)
+        foreach(_libname ${sodium_PKG_STATIC_LIBRARIES})
+            if (NOT _libname MATCHES "^lib.*\\.a$") # ignore strings already ending with .a
+                list(INSERT sodium_PKG_STATIC_LIBRARIES 0 "lib${_libname}.a")
+            endif()
+        endforeach()
+        list(REMOVE_DUPLICATES sodium_PKG_STATIC_LIBRARIES)
+
+        # if pkgconfig for libsodium doesn't provide
+        # static lib info, then override PKG_STATIC here..
+        if (NOT sodium_PKG_STATIC_FOUND)
+            set(sodium_PKG_STATIC_LIBRARIES libsodium.a)
+        endif()
+
+        set(XPREFIX sodium_PKG_STATIC)
+    else()
+        if (NOT sodium_PKG_FOUND)
+            set(sodium_PKG_LIBRARIES sodium)
+        endif()
+
+        set(XPREFIX sodium_PKG)
+    endif()
+
+    find_path(sodium_INCLUDE_DIR sodium.h
+        HINTS ${${XPREFIX}_INCLUDE_DIRS}
+    )
+    find_library(sodium_LIBRARY_DEBUG NAMES ${${XPREFIX}_LIBRARIES}
+        HINTS ${${XPREFIX}_LIBRARY_DIRS}
+    )
+    find_library(sodium_LIBRARY_RELEASE NAMES ${${XPREFIX}_LIBRARIES}
+        HINTS ${${XPREFIX}_LIBRARY_DIRS}
+    )
+
+
+########################################################################
+# Windows
+elseif (WIN32)
+    set(sodium_DIR "$ENV{sodium_DIR}" CACHE FILEPATH "sodium install directory")
+    mark_as_advanced(sodium_DIR)
+
+    find_path(sodium_INCLUDE_DIR sodium.h
+        HINTS ${sodium_DIR}
+        PATH_SUFFIXES include
+    )
+
+    if (MSVC)
+        # detect target architecture
+        file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/arch.cpp" [=[
+            #if defined _M_IX86
+            #error ARCH_VALUE x86_32
+            #elif defined _M_X64
+            #error ARCH_VALUE x86_64
+            #endif
+            #error ARCH_VALUE unknown
+        ]=])
+        try_compile(_UNUSED_VAR "${CMAKE_CURRENT_BINARY_DIR}" "${CMAKE_CURRENT_BINARY_DIR}/arch.cpp"
+            OUTPUT_VARIABLE _COMPILATION_LOG
+        )
+        string(REGEX REPLACE ".*ARCH_VALUE ([a-zA-Z0-9_]+).*" "\\1" _TARGET_ARCH "${_COMPILATION_LOG}")
+
+        # construct library path
+        if (_TARGET_ARCH STREQUAL "x86_32")
+            string(APPEND _PLATFORM_PATH "Win32")
+        elseif(_TARGET_ARCH STREQUAL "x86_64")
+            string(APPEND _PLATFORM_PATH "x64")
+        else()
+            message(FATAL_ERROR "the ${_TARGET_ARCH} architecture is not supported by Findsodium.cmake.")
+        endif()
+        string(APPEND _PLATFORM_PATH "/$$CONFIG$$")
+
+        if (MSVC_VERSION LESS 1900)
+            math(EXPR _VS_VERSION "${MSVC_VERSION} / 10 - 60")
+        else()
+            math(EXPR _VS_VERSION "${MSVC_VERSION} / 10 - 50")
+        endif()
+        string(APPEND _PLATFORM_PATH "/v${_VS_VERSION}")
+
+        if (sodium_USE_STATIC_LIBS)
+            string(APPEND _PLATFORM_PATH "/static")
+        else()
+            string(APPEND _PLATFORM_PATH "/dynamic")
+        endif()
+
+        string(REPLACE "$$CONFIG$$" "Debug" _DEBUG_PATH_SUFFIX "${_PLATFORM_PATH}")
+        string(REPLACE "$$CONFIG$$" "Release" _RELEASE_PATH_SUFFIX "${_PLATFORM_PATH}")
+
+        find_library(sodium_LIBRARY_DEBUG libsodium.lib
+            HINTS ${sodium_DIR}
+            PATH_SUFFIXES ${_DEBUG_PATH_SUFFIX}
+        )
+        find_library(sodium_LIBRARY_RELEASE libsodium.lib
+            HINTS ${sodium_DIR}
+            PATH_SUFFIXES ${_RELEASE_PATH_SUFFIX}
+        )
+        if (NOT sodium_USE_STATIC_LIBS)
+            set(CMAKE_FIND_LIBRARY_SUFFIXES_BCK ${CMAKE_FIND_LIBRARY_SUFFIXES})
+            set(CMAKE_FIND_LIBRARY_SUFFIXES ".dll")
+            find_library(sodium_DLL_DEBUG libsodium
+                HINTS ${sodium_DIR}
+                PATH_SUFFIXES ${_DEBUG_PATH_SUFFIX}
+            )
+            find_library(sodium_DLL_RELEASE libsodium
+                HINTS ${sodium_DIR}
+                PATH_SUFFIXES ${_RELEASE_PATH_SUFFIX}
+            )
+            set(CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES_BCK})
+        endif()
+
+    elseif(_GCC_COMPATIBLE)
+        if (sodium_USE_STATIC_LIBS)
+            find_library(sodium_LIBRARY_DEBUG libsodium.a
+                HINTS ${sodium_DIR}
+                PATH_SUFFIXES lib
+            )
+            find_library(sodium_LIBRARY_RELEASE libsodium.a
+                HINTS ${sodium_DIR}
+                PATH_SUFFIXES lib
+            )
+        else()
+            find_library(sodium_LIBRARY_DEBUG libsodium.dll.a
+                HINTS ${sodium_DIR}
+                PATH_SUFFIXES lib
+            )
+            find_library(sodium_LIBRARY_RELEASE libsodium.dll.a
+                HINTS ${sodium_DIR}
+                PATH_SUFFIXES lib
+            )
+
+            file(GLOB _DLL
+                LIST_DIRECTORIES false
+                RELATIVE "${sodium_DIR}/bin"
+                "${sodium_DIR}/bin/libsodium*.dll"
+            )
+            find_library(sodium_DLL_DEBUG ${_DLL} libsodium
+                HINTS ${sodium_DIR}
+                PATH_SUFFIXES bin
+            )
+            find_library(sodium_DLL_RELEASE ${_DLL} libsodium
+                HINTS ${sodium_DIR}
+                PATH_SUFFIXES bin
+            )
+        endif()
+    else()
+        message(FATAL_ERROR "this platform is not supported by FindSodium.cmake")
+    endif()
+
+
+########################################################################
+# unsupported
+else()
+    message(FATAL_ERROR "this platform is not supported by FindSodium.cmake")
+endif()
+
+
+########################################################################
+# common stuff
+
+# extract sodium version
+if (sodium_INCLUDE_DIR)
+    set(_VERSION_HEADER "${_INCLUDE_DIR}/sodium/version.h")
+    if (EXISTS _VERSION_HEADER)
+        file(READ "${_VERSION_HEADER}" _VERSION_HEADER_CONTENT)
+        string(REGEX REPLACE ".*#[ \t]*define[ \t]*SODIUM_VERSION_STRING[ \t]*\"([^\n]*)\".*" "\\1"
+            sodium_VERSION "${_VERSION_HEADER_CONTENT}")
+        set(sodium_VERSION "${sodium_VERSION}" PARENT_SCOPE)
+    endif()
+endif()
+
+# communicate results
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(
+    Sodium # The name must be either uppercase or match the filename case.
+    REQUIRED_VARS
+        sodium_LIBRARY_RELEASE
+        sodium_LIBRARY_DEBUG
+        sodium_INCLUDE_DIR
+    VERSION_VAR
+        sodium_VERSION
+)
+
+if(Sodium_FOUND)
+    set(sodium_LIBRARIES
+        optimized ${sodium_LIBRARY_RELEASE} debug ${sodium_LIBRARY_DEBUG})
+endif()
+
+# mark file paths as advanced
+mark_as_advanced(sodium_INCLUDE_DIR)
+mark_as_advanced(sodium_LIBRARY_DEBUG)
+mark_as_advanced(sodium_LIBRARY_RELEASE)
+if (WIN32)
+    mark_as_advanced(sodium_DLL_DEBUG)
+    mark_as_advanced(sodium_DLL_RELEASE)
+endif()
+
+# create imported target
+if(sodium_USE_STATIC_LIBS)
+    set(_LIB_TYPE STATIC)
+else()
+    set(_LIB_TYPE SHARED)
+endif()
+
+if(NOT TARGET sodium)
+    add_library(sodium ${_LIB_TYPE} IMPORTED)
+endif()
+
+set_target_properties(sodium PROPERTIES
+    INTERFACE_INCLUDE_DIRECTORIES "${sodium_INCLUDE_DIR}"
+    IMPORTED_LINK_INTERFACE_LANGUAGES "C"
+)
+
+if (sodium_USE_STATIC_LIBS)
+    set_target_properties(sodium PROPERTIES
+        INTERFACE_COMPILE_DEFINITIONS "SODIUM_STATIC"
+        IMPORTED_LOCATION "${sodium_LIBRARY_RELEASE}"
+        IMPORTED_LOCATION_DEBUG "${sodium_LIBRARY_DEBUG}"
+    )
+else()
+    if (UNIX)
+        set_target_properties(sodium PROPERTIES
+            IMPORTED_LOCATION "${sodium_LIBRARY_RELEASE}"
+            IMPORTED_LOCATION_DEBUG "${sodium_LIBRARY_DEBUG}"
+        )
+    elseif (WIN32)
+        set_target_properties(sodium PROPERTIES
+            IMPORTED_IMPLIB "${sodium_LIBRARY_RELEASE}"
+            IMPORTED_IMPLIB_DEBUG "${sodium_LIBRARY_DEBUG}"
+        )
+        if (NOT (sodium_DLL_DEBUG MATCHES ".*-NOTFOUND"))
+            set_target_properties(sodium PROPERTIES
+                IMPORTED_LOCATION_DEBUG "${sodium_DLL_DEBUG}"
+            )
+        endif()
+        if (NOT (sodium_DLL_RELEASE MATCHES ".*-NOTFOUND"))
+            set_target_properties(sodium PROPERTIES
+                IMPORTED_LOCATION_RELWITHDEBINFO "${sodium_DLL_RELEASE}"
+                IMPORTED_LOCATION_MINSIZEREL "${sodium_DLL_RELEASE}"
+                IMPORTED_LOCATION_RELEASE "${sodium_DLL_RELEASE}"
+            )
+        endif()
+    endif()
+endif()
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindThrift.cmake treadmill/CMake/FindThrift.cmake
--- treadmill-src/CMake/FindThrift.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindThrift.cmake	2025-08-04 15:44:21.741428688 -0700
@@ -0,0 +1,162 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+#########
+#
+# Locate and configure the Thrift library.
+# Defines the following variables:
+#
+#   THRIFT_INCLUDE_DIR - the include directory for thrift headers
+#   THRIFT_SHARED_LIBRARY - path to thrift's shared library
+#   THRIFT_STATIC_LIBRARY - path to thrift's static library
+#   THRIFT_EXECUTABLE - the thrift compiler
+#   THRIFT_FOUND - whether the Thrift library and executable has been found
+#
+#  ====================================================================
+#  Example:
+#
+#   find_package(Thrift REQUIRED)
+#   include_directories(${THRIFT_INCLUDE_DIR})
+#
+#   include_directories(${CMAKE_CURRENT_BINARY_DIR})
+#   THRIFT_GENERATE_CPP(THRIFT_SRCS THRIFT_HDRS THRIFT_TGTS
+#     [SOURCE_ROOT <root from which source is found>]
+#     [BINARY_ROOT <root into which binaries are built>]
+#     THRIFT_FILES foo.thrift)
+#   add_executable(bar bar.cc ${THRIFT_SRCS} ${THRIFT_HDRS})
+#   target_link_libraries(bar ${THRIFT_SHARED_LIBRARY})
+#
+#  ====================================================================
+#
+# THRIFT_GENERATE_CPP (public function)
+#   SRCS = Variable to define with autogenerated
+#          source files
+#   HDRS = Variable to define with autogenerated
+#          header files
+#   TGTS = Variable to define with autogenerated
+#          custom targets; if SRCS/HDRS need to be used in multiple
+#          libraries, those libraries should depend on these targets
+#          in order to "serialize" the thrift invocations
+#  ====================================================================
+
+function(THRIFT_GENERATE_CPP SRCS HDRS TGTS)
+  if(NOT ARGN)
+    message(SEND_ERROR "Error: THRIFT_GENERATE_CPP() called without any thrift files")
+    return()
+  endif()
+
+  set(one_value_args SOURCE_ROOT BINARY_ROOT)
+  set(multi_value_args EXTRA_THRIFT_PATHS THRIFT_FILES)
+  cmake_parse_arguments(ARG "${options}" "${one_value_args}" "${multi_value_args}" ${ARGN})
+  if(ARG_UNPARSED_ARGUMENTS)
+    message(SEND_ERROR "Error: unrecognized arguments: ${ARG_UNPARSED_ARGUMENTS}")
+  endif()
+
+  set(${SRCS})
+  set(${HDRS})
+  set(${TGTS})
+
+  set(EXTRA_THRIFT_PATH_ARGS)
+  foreach(PP ${ARG_EXTRA_THRIFT_PATHS})
+    set(EXTRA_THRIFT_PATH_ARGS ${EXTRA_THRIFT_PATH_ARGS} -I ${PP})
+  endforeach()
+
+  if("${ARG_SOURCE_ROOT}" STREQUAL "")
+    SET(ARG_SOURCE_ROOT "${CMAKE_CURRENT_SOURCE_DIR}")
+  endif()
+  GET_FILENAME_COMPONENT(ARG_SOURCE_ROOT ${ARG_SOURCE_ROOT} ABSOLUTE)
+
+  if("${ARG_BINARY_ROOT}" STREQUAL "")
+    SET(ARG_BINARY_ROOT "${CMAKE_CURRENT_BINARY_DIR}")
+  endif()
+  GET_FILENAME_COMPONENT(ARG_BINARY_ROOT ${ARG_BINARY_ROOT} ABSOLUTE)
+
+  foreach(FIL ${ARG_THRIFT_FILES})
+    get_filename_component(ABS_FIL ${FIL} ABSOLUTE)
+    get_filename_component(FIL_WE ${FIL} NAME_WE)
+
+    set(THRIFT_H_OUT "${ARG_BINARY_ROOT}/${FIL_WE}_types.h" "${ARG_BINARY_ROOT}/${FIL_WE}_constants.h")
+    set(THRIFT_CC_OUT "${ARG_BINARY_ROOT}/${FIL_WE}_constants.cpp" "${ARG_BINARY_ROOT}/${FIL_WE}_types.cpp")
+
+    execute_process(COMMAND awk "/^service/ { print $2 }" "${ABS_FIL}"
+                    OUTPUT_VARIABLE SERVICES
+                    OUTPUT_STRIP_TRAILING_WHITESPACE)
+
+    foreach(SERVICE ${SERVICES})
+      list(APPEND THRIFT_H_OUT "${ARG_BINARY_ROOT}/${SERVICE}.h")
+      list(APPEND THRIFT_CC_OUT "${ARG_BINARY_ROOT}/${SERVICE}.cpp")
+    endforeach()
+
+    list(APPEND ${SRCS} "${THRIFT_CC_OUT}")
+    list(APPEND ${HDRS} "${THRIFT_H_OUT}")
+
+    add_custom_command(
+      OUTPUT ${THRIFT_CC_OUT} ${THRIFT_H_OUT}
+      DEPENDS ${ABS_FIL}
+      COMMAND  ${THRIFT_EXECUTABLE}
+      ARGS
+        --gen cpp:moveable_types
+        --recurse
+        --out ${ARG_BINARY_ROOT}
+        -I ${ARG_SOURCE_ROOT}
+        ${EXTRA_THRIFT_PATH_ARGS} ${ABS_FIL}
+      COMMENT "Running C++ thrift compiler on ${FIL}"
+      VERBATIM )
+
+    # This custom target enforces that there's just one invocation of thrift
+    # when there are multiple consumers of the generated files. The target name
+    # must be unique; adding parts of the filename helps ensure this.
+    string(MAKE_C_IDENTIFIER "${ARG_BINARY_ROOT}${FIL}" TGT_NAME)
+    add_custom_target(${TGT_NAME}
+      DEPENDS "${THRIFT_CC_OUT}" "${THRIFT_H_OUT}")
+    list(APPEND ${TGTS} "${TGT_NAME}")
+  endforeach()
+
+  set_source_files_properties(${${SRCS}} ${${HDRS}} PROPERTIES GENERATED TRUE)
+  set(${SRCS} ${${SRCS}} PARENT_SCOPE)
+  set(${HDRS} ${${HDRS}} PARENT_SCOPE)
+  set(${TGTS} ${${TGTS}} PARENT_SCOPE)
+endfunction()
+
+
+find_path(THRIFT_INCLUDE_DIR thrift/Thrift.h
+  # NO_CMAKE_SYSTEM_PATH
+  # NO_SYSTEM_ENVIRONMENT_PATH
+)
+
+find_library(THRIFT_SHARED_LIBRARY thrift
+  DOC "The Thrift Library"
+  # NO_CMAKE_SYSTEM_PATH
+  # NO_SYSTEM_ENVIRONMENT_PATH
+)
+
+find_library(THRIFT_STATIC_LIBRARY libthrift.a
+  DOC "Static version of the Thrift Library"
+  # NO_CMAKE_SYSTEM_PATH
+  # NO_SYSTEM_ENVIRONMENT_PATH
+)
+
+find_program(THRIFT_EXECUTABLE thrift
+  DOC "The Thrift Compiler"
+  # NO_CMAKE_SYSTEM_PATH
+  # NO_SYSTEM_ENVIRONMENT_PATH
+)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(THRIFT REQUIRED_VARS
+  THRIFT_SHARED_LIBRARY THRIFT_STATIC_LIBRARY
+  THRIFT_INCLUDE_DIR THRIFT_EXECUTABLE)
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindXxhash.cmake treadmill/CMake/FindXxhash.cmake
--- treadmill-src/CMake/FindXxhash.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindXxhash.cmake	2025-08-04 15:44:21.742032592 -0700
@@ -0,0 +1,40 @@
+# Copyright (c) Facebook, Inc. and its affiliates.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#
+# - Try to find Facebook xxhash library
+# This will define
+# Xxhash_FOUND
+# Xxhash_INCLUDE_DIR
+# Xxhash_LIBRARY
+#
+
+find_path(Xxhash_INCLUDE_DIR NAMES xxhash.h)
+
+find_library(Xxhash_LIBRARY_RELEASE NAMES xxhash)
+
+include(SelectLibraryConfigurations)
+SELECT_LIBRARY_CONFIGURATIONS(Xxhash)
+
+include(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(
+    Xxhash DEFAULT_MSG
+    Xxhash_LIBRARY Xxhash_INCLUDE_DIR
+)
+
+if (Xxhash_FOUND)
+  message(STATUS "Found xxhash: ${Xxhash_LIBRARY}")
+endif()
+
+mark_as_advanced(Xxhash_INCLUDE_DIR Xxhash_LIBRARY)
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/FindZstd.cmake treadmill/CMake/FindZstd.cmake
--- treadmill-src/CMake/FindZstd.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/FindZstd.cmake	2025-08-04 15:44:21.742573340 -0700
@@ -0,0 +1,14 @@
+# Copyright (c) 2017-present, Facebook, Inc. and its affiliates.
+# All rights reserved.
+#
+# This source code is licensed under the BSD-style license found in the
+# LICENSE file in the root directory of this source tree.
+
+find_path(ZSTD_INCLUDE_DIR zstd.h)
+
+find_library(ZSTD_LIBRARY NAMES zstd)
+
+if (ZSTD_INCLUDE_DIR AND ZSTD_LIBRARY)
+    set(ZSTD_FOUND TRUE)
+    message(STATUS "Found ZSTD library: ${ZSTD_LIBRARY}")
+endif ()
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMake/ThriftLibrary.cmake treadmill/CMake/ThriftLibrary.cmake
--- treadmill-src/CMake/ThriftLibrary.cmake	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMake/ThriftLibrary.cmake	2025-08-04 15:44:21.743231445 -0700
@@ -0,0 +1,302 @@
+# Copyright (c) Meta Platforms, Inc. and affiliates.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#
+# Requirements:
+# Please provide the following two variables before using these macros:
+#   ${THRIFT1} - path/to/bin/thrift1
+#   ${THRIFTCPP2} - path/to/lib/thriftcpp2
+#
+
+#
+# thrift_object
+# This creates a object that will contain the source files and all the proper
+# dependencies to generate and compile thrift generated files
+#
+# Params:
+#   @file_name - The name of the thrift file
+#   @services  - A list of services that are declared in the thrift file
+#   @language  - The generator to use (cpp or cpp2)
+#   @options   - Extra options to pass to the generator
+#   @file_path - The directory where the thrift file lives
+#   @output_path - The directory where the thrift objects will be built
+#   @include_prefix - The last part of output_path, relative include prefix
+#
+# Output:
+#  A object file named `${file-name}-${language}-obj` to include into your
+#  project's library
+#
+# Notes:
+# If any of the fields is empty, it is still required to provide an empty string
+#
+# Usage:
+#   thrift_object(
+#     #file_name
+#     #services
+#     #language
+#     #options
+#     #file_path
+#     #output_path
+#     #include_prefix
+#   )
+#   add_library(somelib $<TARGET_OBJECTS:${file_name}-${language}-obj> ...)
+#
+
+macro(thrift_object
+  file_name
+  services
+  language
+  options
+  file_path
+  output_path
+  include_prefix
+)
+  thrift_generate(
+    "${file_name}"
+    "${services}"
+    "${language}"
+    "${options}"
+    "${file_path}"
+    "${output_path}"
+    "${include_prefix}"
+    "${ARGN}"
+  )
+  bypass_source_check(${${file_name}-${language}-SOURCES})
+  add_library(
+    "${file_name}-${language}-obj"
+    OBJECT
+    ${${file_name}-${language}-SOURCES}
+  )
+  add_dependencies(
+    "${file_name}-${language}-obj"
+    "${file_name}-${language}-target"
+  )
+  message("Thrift will create the Object file : ${file_name}-${language}-obj")
+endmacro()
+
+# thrift_library
+# Same as thrift object in terms of usage but creates the library instead of
+# object so that you can use to link against your library instead of including
+# all symbols into your library
+#
+# Params:
+#   @file_name - The name of the thrift file
+#   @services  - A list of services that are declared in the thrift file
+#   @language  - The generator to use (cpp or cpp2)
+#   @options   - Extra options to pass to the generator
+#   @file_path - The directory where the thrift file lives
+#   @output_path - The directory where the thrift objects will be built
+#   @include_prefix - The last part of output_path, relative include prefix
+#
+# Output:
+#  A library file named `${file-name}-${language}` to link against your
+#  project's library
+#
+# Notes:
+# If any of the fields is empty, it is still required to provide an empty string
+#
+# Usage:
+#   thrift_library(
+#     #file_name
+#     #services
+#     #language
+#     #options
+#     #file_path
+#     #output_path
+#     #include_prefix
+#   )
+#   add_library(somelib ...)
+#   target_link_libraries(somelib ${file_name}-${language} ...)
+#
+
+macro(thrift_library
+  file_name
+  services
+  language
+  options
+  file_path
+  output_path
+  include_prefix
+)
+  thrift_object(
+    "${file_name}"
+    "${services}"
+    "${language}"
+    "${options}"
+    "${file_path}"
+    "${output_path}"
+    "${include_prefix}"
+    "${ARGN}"
+  )
+  add_library(
+    "${file_name}-${language}"
+    $<TARGET_OBJECTS:${file_name}-${language}-obj>
+  )
+  target_link_libraries("${file_name}-${language}" ${THRIFTCPP2})
+  message("Thrift will create the Library file : ${file_name}-${language}")
+endmacro()
+
+#
+# bypass_source_check
+# This tells cmake to ignore if it doesn't see the following sources in
+# the library that will be installed. Thrift files are generated at compile
+# time so they do not exist at source check time
+#
+# Params:
+#   @sources - The list of files to ignore in source check
+#
+
+macro(bypass_source_check sources)
+  set_source_files_properties(
+    ${sources}
+    PROPERTIES GENERATED TRUE
+  )
+endmacro()
+
+#
+# thrift_generate
+# This is used to codegen thrift files using the thrift compiler
+# Supports library names that differ from the file name (to handle two libraries
+# with the same filename on disk (in different folders))
+# Params:
+#   @file_name - Input file name. Will be used for naming the CMake
+#       target if TARGET_NAME_BASE is not specified.
+#   @services  - A list of services that are declared in the thrift file
+#   @language  - The generator to use (cpp, cpp2 or py3)
+#   @options   - Extra options to pass to the generator
+#   @output_path - The directory where the thrift file lives
+#   @include_prefix - Prefix to use for thrift includes in generated sources
+#   @TARGET_NAME_BASE (optional) - name used for target instead of real filename
+#   @THRIFT_INCLUDE_DIRECTORIES (optional) path to thrift include directories
+#
+# Output:
+#  file-language-target     - A custom target to add a dependency
+#  ${file-language-HEADERS} - The generated Header Files.
+#  ${file-language-SOURCES} - The generated Source Files.
+#
+# Notes:
+# If any of the fields is empty, it is still required to provide an empty string
+#
+# When using file_language-SOURCES it should always call:
+#   bypass_source_check(${file_language-SOURCES})
+# This will prevent cmake from complaining about missing source files
+#
+macro(thrift_generate
+  file_name
+  services
+  language
+  options
+  file_path
+  output_path
+  include_prefix
+)
+  cmake_parse_arguments(THRIFT_GENERATE   # Prefix
+    "" # Options
+    "TARGET_NAME_BASE" # One Value args
+    "THRIFT_INCLUDE_DIRECTORIES" # Multi-value args
+    "${ARGN}")
+
+  set(source_file_name ${file_name})
+  set(target_file_name ${file_name})
+  set(thrift_include_directories)
+  foreach(dir ${THRIFT_GENERATE_THRIFT_INCLUDE_DIRECTORIES})
+    list(APPEND thrift_include_directories "-I" "${dir}")
+  endforeach()
+  if(DEFINED THRIFT_GENERATE_TARGET_NAME_BASE
+     AND NOT THRIFT_GENERATE_TARGET_NAME_BASE STREQUAL "")
+    set(target_file_name ${THRIFT_GENERATE_TARGET_NAME_BASE})
+  endif()
+
+  set("${target_file_name}-${language}-HEADERS"
+    ${output_path}/gen-${language}/${source_file_name}_constants.h
+    ${output_path}/gen-${language}/${source_file_name}_data.h
+    ${output_path}/gen-${language}/${source_file_name}_metadata.h
+    ${output_path}/gen-${language}/${source_file_name}_types.h
+    ${output_path}/gen-${language}/${source_file_name}_types.tcc
+  )
+  set("${target_file_name}-${language}-SOURCES"
+    ${output_path}/gen-${language}/${source_file_name}_constants.cpp
+    ${output_path}/gen-${language}/${source_file_name}_data.cpp
+    ${output_path}/gen-${language}/${source_file_name}_types.cpp
+    ${output_path}/gen-${language}/${source_file_name}_types_compact.cpp
+    ${output_path}/gen-${language}/${source_file_name}_types_binary.cpp
+  )
+  if("${options}" MATCHES "layouts")
+    set("${target_file_name}-${language}-SOURCES"
+      ${${target_file_name}-${language}-SOURCES}
+      ${output_path}/gen-${language}/${source_file_name}_layouts.cpp
+    )
+  endif()
+  if(NOT "${options}" MATCHES "no_metadata")
+    set("${target_file_name}-${language}-SOURCES"
+      ${${target_file_name}-${language}-SOURCES}
+      ${output_path}/gen-${language}/${source_file_name}_metadata.cpp
+    )
+  endif()
+  foreach(service ${services})
+    set("${target_file_name}-${language}-HEADERS"
+      ${${source_file_name}-${language}-HEADERS}
+      ${output_path}/gen-${language}/${service}.h
+      ${output_path}/gen-${language}/${service}.tcc
+      ${output_path}/gen-${language}/${service}AsyncClient.h
+      ${output_path}/gen-${language}/${service}_custom_protocol.h
+    )
+    set("${target_file_name}-${language}-SOURCES"
+      ${${source_file_name}-${language}-SOURCES}
+      ${output_path}/gen-${language}/${service}.cpp
+      ${output_path}/gen-${language}/${service}AsyncClient.cpp
+    )
+  endforeach()
+  if("${include_prefix}" STREQUAL "")
+    set(include_prefix_text "")
+  else()
+    set(include_prefix_text "include_prefix=${include_prefix}")
+    if(NOT "${options}" STREQUAL "")
+      set(include_prefix_text ",${include_prefix_text}")
+    endif()
+  endif()
+  set(gen_language ${language})
+  if("${language}" STREQUAL "cpp2")
+    set(gen_language "mstch_cpp2")
+  elseif("${language}" STREQUAL "py3")
+    set(gen_language "mstch_py3")
+    file(WRITE "${output_path}/gen-${language}/${source_file_name}/__init__.py")
+  endif()
+  add_custom_command(
+    OUTPUT ${${target_file_name}-${language}-HEADERS}
+      ${${target_file_name}-${language}-SOURCES}
+    COMMAND ${THRIFT1}
+      --gen "${gen_language}:${options}${include_prefix_text}"
+      -o ${output_path}
+      ${thrift_include_directories}
+      "${file_path}/${source_file_name}.thrift"
+    DEPENDS
+      ${THRIFT1}
+      "${file_path}/${source_file_name}.thrift"
+    COMMENT "Generating ${target_file_name} files. Output: ${output_path}"
+  )
+  add_custom_target(
+    ${target_file_name}-${language}-target ALL
+    DEPENDS ${${language}-${language}-HEADERS}
+      ${${target_file_name}-${language}-SOURCES}
+  )
+  install(
+    DIRECTORY gen-${language}
+    DESTINATION include/${include_prefix}
+    FILES_MATCHING PATTERN "*.h")
+  install(
+    DIRECTORY gen-${language}
+    DESTINATION include/${include_prefix}
+    FILES_MATCHING PATTERN "*.tcc")
+endmacro()
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CMakeLists.txt treadmill/CMakeLists.txt
--- treadmill-src/CMakeLists.txt	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/CMakeLists.txt	2025-08-04 15:44:21.743816038 -0700
@@ -0,0 +1,81 @@
+cmake_minimum_required(VERSION 3.20)
+project(treadmill
+    VERSION 0.1.0
+    LANGUAGES CXX)
+
+# Set compiler
+set(CMAKE_CXX_COMPILER "clang++")
+set(CMAKE_C_COMPILER "clang")
+
+# Set C++ standard
+set(CMAKE_CXX_STANDARD 20)
+set(CMAKE_CXX_STANDARD_REQUIRED YES)
+
+# Add compile options
+add_compile_options(-DLIBMC_FBTRACE_DISABLE -g -O3)
+
+# Set module path
+set(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/CMake" ${CMAKE_MODULE_PATH})
+
+# Include directories
+include_directories(${CMAKE_SOURCE_DIR})
+include_directories(${CMAKE_BINARY_DIR})
+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/..)
+
+# Find required packages
+find_package(Threads REQUIRED)
+find_package(ZLIB REQUIRED)
+find_package(BZip2 REQUIRED)
+find_package(Zstd REQUIRED)
+find_package(LZ4 REQUIRED)
+find_package(Snappy REQUIRED)
+find_package(LibLZMA REQUIRED)
+find_package(OpenSSL REQUIRED)
+find_package(DoubleConversion REQUIRED)
+find_package(gflags REQUIRED)
+find_package(glog REQUIRED)
+find_package(Xxhash REQUIRED)
+find_package(Boost 1.83.0
+    COMPONENTS
+        context
+        filesystem
+        program_options
+        thread
+        system
+        regex
+    REQUIRED
+)
+find_package(folly CONFIG REQUIRED)
+find_package(fb303 CONFIG REQUIRED)
+find_package(fizz CONFIG REQUIRED)
+find_package(fmt CONFIG REQUIRED)
+find_package(wangle CONFIG REQUIRED)
+find_package(FBThrift CONFIG REQUIRED)
+
+# Include directories for dependencies
+include_directories(
+    ${FOLLY_INCLUDE_DIR}
+    ${FIZZ_INCLUDE_DIR}
+    ${FB303_INCLUDE_DIR}
+    ${GLOG_INCLUDE_DIRS}
+    ${GFLAGS_INCLUDE_DIR}
+    ${DOUBLE_CONVERSION_INCLUDE}
+)
+
+# Add rpath settings
+set(CMAKE_INSTALL_RPATH "${ADSIM_STAGING_DIR}/lib:${ADSIM_STAGING_DIR}/lib64")
+set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)
+set(CMAKE_SKIP_BUILD_RPATH FALSE)
+set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)
+set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
+
+# Find Thrift executable
+find_program(THRIFT_EXECUTABLE thrift1 PATHS ${ADSIM_STAGING_DIR}/bin REQUIRED)
+
+# Option to build treadmill_sleep (disabled by default to match Makefile.am)
+option(BUILD_TREADMILL_SLEEP "Build the treadmill_sleep executable" OFF)
+
+# Add subdirectories
+add_subdirectory(src)
+add_subdirectory(services/adsim)
+add_subdirectory(services/sleep)
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CODE_OF_CONDUCT.md treadmill/CODE_OF_CONDUCT.md
--- treadmill-src/CODE_OF_CONDUCT.md	2025-08-11 17:04:00.472178400 -0700
+++ treadmill/CODE_OF_CONDUCT.md	1969-12-31 16:00:00.000000000 -0800
@@ -1,77 +0,0 @@
-# Code of Conduct
-
-## Our Pledge
-
-In the interest of fostering an open and welcoming environment, we as
-contributors and maintainers pledge to make participation in our project and
-our community a harassment-free experience for everyone, regardless of age, body
-size, disability, ethnicity, sex characteristics, gender identity and expression,
-level of experience, education, socio-economic status, nationality, personal
-appearance, race, religion, or sexual identity and orientation.
-
-## Our Standards
-
-Examples of behavior that contributes to creating a positive environment
-include:
-
-* Using welcoming and inclusive language
-* Being respectful of differing viewpoints and experiences
-* Gracefully accepting constructive criticism
-* Focusing on what is best for the community
-* Showing empathy towards other community members
-
-Examples of unacceptable behavior by participants include:
-
-* The use of sexualized language or imagery and unwelcome sexual attention or
-  advances
-* Trolling, insulting/derogatory comments, and personal or political attacks
-* Public or private harassment
-* Publishing others' private information, such as a physical or electronic
-  address, without explicit permission
-* Other conduct which could reasonably be considered inappropriate in a
-  professional setting
-
-## Our Responsibilities
-
-Project maintainers are responsible for clarifying the standards of acceptable
-behavior and are expected to take appropriate and fair corrective action in
-response to any instances of unacceptable behavior.
-
-Project maintainers have the right and responsibility to remove, edit, or
-reject comments, commits, code, wiki edits, issues, and other contributions
-that are not aligned to this Code of Conduct, or to ban temporarily or
-permanently any contributor for other behaviors that they deem inappropriate,
-threatening, offensive, or harmful.
-
-## Scope
-
-This Code of Conduct applies within all project spaces, and it also applies when
-an individual is representing the project or its community in public spaces.
-Examples of representing a project or community include using an official
-project e-mail address, posting via an official social media account, or acting
-as an appointed representative at an online or offline event. Representation of
-a project may be further defined and clarified by project maintainers.
-
-## Enforcement
-
-Instances of abusive, harassing, or otherwise unacceptable behavior may be
-reported by contacting the project team at <opensource-conduct@fb.com>. All
-complaints will be reviewed and investigated and will result in a response that
-is deemed necessary and appropriate to the circumstances. The project team is
-obligated to maintain confidentiality with regard to the reporter of an incident.
-Further details of specific enforcement policies may be posted separately.
-
-Project maintainers who do not follow or enforce the Code of Conduct in good
-faith may face temporary or permanent repercussions as determined by other
-members of the project's leadership.
-
-## Attribution
-
-This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
-available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html
-
-[homepage]: https://www.contributor-covenant.org
-
-For answers to common questions about this code of conduct, see
-https://www.contributor-covenant.org/faq
-
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/common/fb303/if/fb303.thrift treadmill/common/fb303/if/fb303.thrift
--- treadmill-src/common/fb303/if/fb303.thrift	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/common/fb303/if/fb303.thrift	2025-08-04 15:44:21.745361125 -0700
@@ -0,0 +1,123 @@
+/*
+ * fb303.thrift
+ *
+ * Copyright (c) 2006- Facebook
+ * Distributed under the Thrift Software License
+ *
+ * See accompanying file LICENSE or visit the Thrift site at:
+ * http://developers.facebook.com/thrift/
+ *
+ *
+ * Definition of common Facebook data types and status reporting mechanisms
+ * common to all Facebook services. In some cases, these methods are
+ * provided in the base implementation, and in other cases they simply define
+ * methods that inheriting applications should implement (i.e. status report)
+ *
+ * @author Mark Slee <mcslee@facebook.com>
+ */
+include "fb303/thrift/fb303_core.thrift"
+
+namespace java com.facebook.fbcode.fb303
+namespace java.swift com.facebook.swift.fb303
+namespace java2 com.facebook.thrift.fb303
+namespace cpp facebook.fb303
+namespace py.asyncio fb303_asyncio.fb303
+namespace perl fb303
+namespace hack fb303
+namespace node_module fb303
+namespace go common.fb303.if.fb303
+
+/**
+ * For migration to open source fb303_core.
+ */
+typedef fb303_core.fb303_status fb_status
+/*
+const fb_status DEAD = fb303_core.DEAD
+const fb_status STARTING = fb303_core.STARTING
+const fb_status ALIVE = fb303_core.ALIVE
+const fb_status STOPPING = fb303_core.STOPPING
+const fb_status STOPPED = fb303_core.STOPPED
+const fb_status WARNING = fb303_core.WARNING
+*/
+
+/**
+ * DEPRECATED! This will be removed soon.
+ *
+ * Structure for holding counters information.
+ */
+struct CountersInformation {
+  1: map<string, i64> data;
+}
+
+struct CpuProfileOptions {
+  1: i32 durationSecs;
+
+  // If "selective" is set, we only profile sections of code where profiling
+  // is explicitly enabled by calling Perftools::startSelectiveCpuProfiling()
+  // and Perftools::stopSelectiveCpuProfiling() from each thread that
+  // should be profiled. You must likely instrument your server to do this.
+  2: bool selective;
+}
+
+/**
+ * Standard base service
+ *
+ * Those methods with priority level IMPORTANT run in a dedicated thread pool
+ * in C++. If you need to change one of the rest to be IMPORTANT, make sure it
+ * runs fast so it won't block other IMPORTANT methods.
+ */
+service FacebookService extends fb303_core.BaseService {
+  /**
+   * Returns a CPU profile over the given time interval (client and server
+   * must agree on the profile format).
+   *
+   */
+  string getCpuProfile(1: i32 profileDurationInSec) (thread = 'eb');
+
+  /**
+   * Returns a CPU profile, specifying options (see the struct definition).
+   */
+  string getCpuProfileWithOptions(1: CpuProfileOptions options) (thread = 'eb');
+
+  /**
+   * Returns a WallTime Profiler data over the given time
+   * interval (client and server must agree on the profile format).
+   */
+  string getWallTimeProfile(1: i32 profileDurationInSec);
+
+  /**
+   * Returns the current memory usage (RSS) of this process in bytes.
+   */
+  i64 getMemoryUsage();
+
+  /**
+   * Returns the 1-minute load average on the system (i.e. the load may not
+   * all be coming from the current process).
+   */
+  double getLoad() (priority = 'IMPORTANT');
+
+  /**
+   * Returns the pid of the process
+   */
+  i64 getPid();
+
+  /**
+   * Returns the command line used to execute this process.
+   */
+  string getCommandLine();
+
+  /**
+   * Tell the server to reload its configuration, reopen log files, etc
+   */
+  oneway void reinitialize();
+
+  /**
+   * Suggest a shutdown to the server
+   */
+  oneway void shutdown();
+
+  /**
+   * Translate frame pointers to file name and line pairs.
+   */
+  list<string> translateFrames(1: list<i64> pointers);
+}
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/configure.ac treadmill/configure.ac
--- treadmill-src/configure.ac	2025-08-11 17:04:00.487691986 -0700
+++ treadmill/configure.ac	1969-12-31 16:00:00.000000000 -0800
@@ -1,138 +0,0 @@
-# Copyright (c) 2013, Facebook, Inc.
-# All rights reserved.
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are met:
-#   * Redistributions of source code must retain the above copyright notice,
-#     this list of conditions and the following disclaimer.
-#   * Redistributions in binary form must reproduce the above copyright notice,
-#     this list of conditions and the following disclaimer in the documentation
-#     and/or other materials provided with the distribution.
-#   * Neither the name Facebook nor the names of its contributors may be used to
-#     endorse or promote products derived from this software without specific
-#     prior written permission.
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-# Download the latest version of autotools
-# http://git.savannah.gnu.org/cgit/coreutils.git/tree/scripts/autotools-install
-AC_PREREQ([2.69])
-AC_INIT([treadmill], [0.1.0], [https://github.com/facebook/treadmill])
-
-AC_CONFIG_AUX_DIR([build-aux])
-
-AM_INIT_AUTOMAKE([foreign dist-bzip2 nostdinc subdir-objects])
-
-# Checks for programs.
-AC_PROG_CXX
-AC_PROG_CC
-AC_PROG_CPP
-AC_PROG_CPP
-AC_PROG_RANLIB
-
-# Checks for C++14
-AX_CXX_COMPILE_STDCXX_14([],[mandatory])
-
-# Thrift compiler
-AC_ARG_VAR([THRIFT2_COMP_DIR],
-           [Full path to directory containing fbthrift main.py (cpp2 compiler)])
-AS_IF([test x"$THRIFT2_COMP_DIR" = x],
-      [AC_MSG_ERROR([Path to fbthrift cpp2 compiler must be specified])],
-      [THRIFT="python$PYTHON_VERSION $THRIFT2_COMP_DIR/main.py"])
-
-AC_SUBST([THRIFT])
-
-# Disable FBTrace
-CXXFLAGS="-DLIBMC_FBTRACE_DISABLE $CXXFLAGS"
-
-# Checks for libraries.
-AC_CHECK_LIB([crypto], [MD5_Init], [], [AC_MSG_ERROR(
-             [Please install libcrypto])])
-AC_CHECK_LIB([double-conversion],[getenv],[],[AC_MSG_ERROR(
-             [Please install double-conversion library])])
-AC_CHECK_LIB([folly], [getenv], [], [AC_MSG_ERROR(
-             [Please install folly library])])
-AC_CHECK_LIB([zstd], [getenv], [], [AC_MSG_ERROR(
-             [Please install zstd library])])
-AC_CHECK_LIB([event], [event_set], [], [AC_MSG_ERROR(
-             [Please install libevent])])
-AC_CHECK_LIB([gflags], [getenv], [], [AC_MSG_ERROR(
-             [Please install google-gflags library])])
-AC_CHECK_LIB([glog], [openlog], [], [AC_MSG_ERROR(
-             [Please install google-glog library])])
-AC_CHECK_LIB([pthread], [pthread_mutex_init], [], [AC_MSG_ERROR(
-             [Please install pthread library])])
-AC_CHECK_LIB([ssl], [SSL_library_init], [], [AC_MSG_ERROR(
-             [Please install openSSL])])
-AC_CHECK_LIB([thrift], [main], [], [AC_MSG_ERROR(
-             [Please install fbthrift])])
-AC_CHECK_LIB([thriftcpp2], [main], [], [AC_MSG_ERROR(
-             [Please install fbthrift cpp2])])
-AC_CHECK_LIB([thriftprotocol], [main], [], [AC_MSG_ERROR(
-             [Please install fbthrift protocol])])
-AC_CHECK_LIB([mcrouter], [getenv], [], [AC_MSG_ERROR(
-             [Please install mcrouter library])])
-AC_CHECK_LIB([numa], [numa_available], [], [AC_MSG_ERROR(
-             [Please install numa library])])
-
-# check for boost libs
-AX_BOOST_BASE([1.51.0], [], [AC_MSG_ERROR(
-              [Please install boost >= 1.51.0])])
-AC_CHECK_LIB([boost_context], [main], [], [AC_MSG_ERROR(
-             [Please install libboost_context])])
-AC_CHECK_LIB([boost_thread], [main], [], [AC_MSG_ERROR(
-             [Please install libboost_thread])])
-AC_CHECK_LIB([boost_system], [main], [], [AC_MSG_ERROR(
-             [Please install libboost_system])])
-AC_CHECK_LIB([boost_filesystem], [main], [], [AC_MSG_ERROR(
-             [Please install libboost_filesystem])])
-
-# Checks for header files.
-AC_CHECK_HEADERS([arpa/inet.h])
-AC_CHECK_HEADERS([fcntl.h])
-AC_CHECK_HEADERS([netdb.h])
-AC_CHECK_HEADERS([netinet/in.h])
-AC_CHECK_HEADERS([stdlib.h])
-AC_CHECK_HEADERS([string.h])
-AC_CHECK_HEADERS([sys/ioctl.h])
-AC_CHECK_HEADERS([sys/socket.h])
-AC_CHECK_HEADERS([sys/time.h])
-AC_CHECK_HEADERS([unistd.h])
-
-# Checks for typedefs, structures, and compiler characteristics.
-AC_HEADER_STDBOOL
-AC_HEADER_STDC
-AC_HEADER_TIME
-
-# Checks for library functions.
-AC_CHECK_FUNCS([gethostbyname])
-AC_CHECK_FUNCS([gettimeofday])
-AC_CHECK_FUNCS([inet_ntoa])
-AC_CHECK_FUNCS([socket])
-AC_CHECK_FUNCS([sqrt])
-AC_CHECK_FUNCS([strerror])
-
-# Checks for types
-AC_TYPE_INT16_T
-AC_TYPE_INT32_T
-AC_TYPE_INT64_T
-AC_TYPE_INT8_T
-AC_TYPE_MODE_T
-AC_TYPE_OFF_T
-AC_TYPE_SIZE_T
-AC_TYPE_SSIZE_T
-AC_TYPE_UINT16_T
-AC_TYPE_UINT32_T
-AC_TYPE_UINT64_T
-AC_TYPE_UINT8_T
-
-AC_CONFIG_FILES([Makefile])
-
-AC_OUTPUT
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Connection.h treadmill/Connection.h
--- treadmill-src/Connection.h	2025-08-11 17:04:00.472733601 -0700
+++ treadmill/Connection.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,61 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-#include <folly/Memory.h>
-
-#include "common/thrift/thrift/gen-cpp2/MonitorAsyncClient.h"
-
-DECLARE_string(counter_name);
-DECLARE_int32(counter_threshold);
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-/**
- * Specializations of this template should implement:
- *
- * bool isReady();
- *
- * folly::Future<Service::Reply>
- * sendRequest(std::unique_ptr<typename Service::Request>&& request);
- *
- * */
-template <class Service>
-class Connection {
- public:
-  /**
-   * Sample implementation below shows how to wait for a specific counter
-   * value to cross a threshold
-   * e.g. usage: --wait_for_target_ready --counter_threshold 10
-   * --counter_name thrift.accepted_connections.count
-   * */
-
-  bool isReady() const {
-    if (!FLAGS_counter_name.empty()) {
-      int64_t value = client_->sync_getCounter(FLAGS_counter_name);
-      if (value < FLAGS_counter_threshold) {
-        LOG(INFO) << "Threshold: " << FLAGS_counter_threshold
-                  << " Counter: " << FLAGS_counter_name << " Value: " << value;
-        return false;
-      }
-    }
-    return true;
-  }
-
- private:
-  std::unique_ptr<facebook::thrift::MonitorAsyncClient> client_;
-};
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CounterStatistic.cpp treadmill/CounterStatistic.cpp
--- treadmill-src/CounterStatistic.cpp	2025-08-11 17:04:00.473011080 -0700
+++ treadmill/CounterStatistic.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,37 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#include "treadmill/CounterStatistic.h"
-
-#include "treadmill/Util.h"
-
-#include <mutex>
-#include <unordered_map>
-
-#include <glog/logging.h>
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-/**
- * Print out all the statistic
- */
-void CounterStatistic::printStatistic() const {
-  LOG(INFO) << "Count: " << count_;
-  std::for_each(
-      subkey_count_.cbegin(), subkey_count_.cend(), [](const auto& p) {
-        LOG(INFO) << "Count[" << p.first << "]: " << p.second.data;
-      });
-}
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/CounterStatistic.h treadmill/CounterStatistic.h
--- treadmill-src/CounterStatistic.h	2025-08-11 17:04:00.473221618 -0700
+++ treadmill/CounterStatistic.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,63 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-#include <atomic>
-#include <string>
-#include <unordered_map>
-#include <vector>
-
-#include <folly/AtomicUnorderedMap.h>
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-class CounterStatistic {
- public:
-  explicit CounterStatistic(const std::string& /* name */) {}
-
-  void increase(int64_t n, const std::string& subkey) {
-    count_ += n;
-    if (!subkey.empty()) {
-      subkey_count_
-          .findOrConstruct(
-              subkey,
-              [](void* raw) { return new (raw) std::atomic<int64_t>{0}; })
-          .first->second.data += n;
-    }
-  }
-
-  int64_t getCount() const {
-    return count_;
-  }
-
-  int64_t getCount(const std::string& subkey) {
-    return subkey_count_
-        .findOrConstruct(
-            subkey,
-            [=](void* raw) { return new (raw) std::atomic<int64_t>{0}; })
-        .first->second.data;
-  }
-
-  void printStatistic() const;
-
- private:
-  int64_t count_ = 0;
-  folly::AtomicUnorderedInsertMap<std::string, folly::MutableAtom<int64_t>>
-      subkey_count_ = folly::
-          AtomicUnorderedInsertMap<std::string, folly::MutableAtom<int64_t>>{
-              10 * 1024};
-};
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Event.h treadmill/Event.h
--- treadmill-src/Event.h	2025-08-11 17:04:00.473470034 -0700
+++ treadmill/Event.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,47 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-#include <folly/dynamic.h>
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-enum class EventType {
-  STOP,
-  RESET,
-  SEND_REQUEST,
-  // Sets the phase of the test, which is stored as string in extraData
-  SET_PHASE,
-  // Sets the max outstanding requests in the Worker
-  SET_MAX_OUTSTANDING,
-};
-
-class Event {
- public:
-  explicit Event(EventType event_type, folly::dynamic extra_data = nullptr)
-      : eventType_(event_type), extraData_(extra_data) {}
-  EventType getEventType() const {
-    return eventType_;
-  }
-  const folly::dynamic getExtraData() const {
-    return extraData_;
-  }
-
- private:
-  EventType eventType_;
-  folly::dynamic extraData_;
-};
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/.gitignore treadmill/.gitignore
--- treadmill-src/.gitignore	2025-08-11 17:04:00.471470259 -0700
+++ treadmill/.gitignore	2025-08-04 15:44:21.748100337 -0700
@@ -19,4 +19,5 @@
 /install-sh
 /libtool
 /missing
+build/
 services/sleep/gen-cpp2
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/if/treadmill.thrift treadmill/if/treadmill.thrift
--- treadmill-src/if/treadmill.thrift	2025-08-11 17:04:00.488532357 -0700
+++ treadmill/if/treadmill.thrift	1969-12-31 16:00:00.000000000 -0800
@@ -1,54 +0,0 @@
-// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
-include "common/fb303/if/fb303.thrift"
-
-namespace cpp2 treadmill
-namespace py treadmill
-
-typedef string PhaseName
-
-struct ResumeRequest {
-  /**
-   * Name of the phase that treadmill is transitioning to
-   */
-  1: required PhaseName phaseName;
-}
-
-struct ResumeResponse {
-  /**
-   * Value indicating whether the resume was successful
-   */
-  1: required bool success;
-}
-
-struct RateResponse {
-  /**
-   * The state of the scheduler
-   */
-  1: optional bool scheduler_running;
-
-  /**
-   * The request per second rate
-   */
-  2: optional i32 rps;
-
-  /**
-   * The maximum number of outstanding requests
-   */
-  3: optional i32 max_outstanding;
-}
-
-service TreadmillService extends fb303.FacebookService {
-  bool pause();
-  bool resume();
-  /**
-   * Temporary renaming of resume for backwards compatibility
-   */
-  ResumeResponse resume2(ResumeRequest req);
-  void setRps(1: i32 rps);
-  void setMaxOutstanding(1: i32 max_outstanding);
-  RateResponse getRate();
-
-  string getConfiguration(1: string key);
-  void setConfiguration(1: string key, 2: string value);
-  void clearConfiguration();
-}
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/m4/ax_cxx_compile_stdcxx_14.m4 treadmill/m4/ax_cxx_compile_stdcxx_14.m4
--- treadmill-src/m4/ax_cxx_compile_stdcxx_14.m4	2025-08-11 17:04:00.489562846 -0700
+++ treadmill/m4/ax_cxx_compile_stdcxx_14.m4	1969-12-31 16:00:00.000000000 -0800
@@ -1,34 +0,0 @@
-# ============================================================================
-#  http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx_14.html
-# ============================================================================
-#
-# SYNOPSIS
-#
-#   AX_CXX_COMPILE_STDCXX_14([ext|noext], [mandatory|optional])
-#
-# DESCRIPTION
-#
-#   Check for baseline language coverage in the compiler for the C++14
-#   standard; if necessary, add switches to CXX and CXXCPP to enable
-#   support.
-#
-#   This macro is a convenience alias for calling the AX_CXX_COMPILE_STDCXX
-#   macro with the version set to C++14.  The two optional arguments are
-#   forwarded literally as the second and third argument respectively.
-#   Please see the documentation for the AX_CXX_COMPILE_STDCXX macro for
-#   more information.  If you want to use this macro, you also need to
-#   download the ax_cxx_compile_stdcxx.m4 file.
-#
-# LICENSE
-#
-#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>
-#
-#   Copying and distribution of this file, with or without modification, are
-#   permitted in any medium without royalty provided the copyright notice
-#   and this notice are preserved. This file is offered as-is, without any
-#   warranty.
-
-#serial 4
-
-AX_REQUIRE_DEFINED([AX_CXX_COMPILE_STDCXX])
-AC_DEFUN([AX_CXX_COMPILE_STDCXX_14], [AX_CXX_COMPILE_STDCXX([14], [$1], [$2])])
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/m4/ax_cxx_compile_stdcxx.m4 treadmill/m4/ax_cxx_compile_stdcxx.m4
--- treadmill-src/m4/ax_cxx_compile_stdcxx.m4	2025-08-11 17:04:00.489234440 -0700
+++ treadmill/m4/ax_cxx_compile_stdcxx.m4	1969-12-31 16:00:00.000000000 -0800
@@ -1,982 +0,0 @@
-# ===========================================================================
-#   http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx.html
-# ===========================================================================
-#
-# SYNOPSIS
-#
-#   AX_CXX_COMPILE_STDCXX(VERSION, [ext|noext], [mandatory|optional])
-#
-# DESCRIPTION
-#
-#   Check for baseline language coverage in the compiler for the specified
-#   version of the C++ standard.  If necessary, add switches to CXX and
-#   CXXCPP to enable support.  VERSION may be '11' (for the C++11 standard)
-#   or '14' (for the C++14 standard).
-#
-#   The second argument, if specified, indicates whether you insist on an
-#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.
-#   -std=c++11).  If neither is specified, you get whatever works, with
-#   preference for an extended mode.
-#
-#   The third argument, if specified 'mandatory' or if left unspecified,
-#   indicates that baseline support for the specified C++ standard is
-#   required and that the macro should error out if no mode with that
-#   support is found.  If specified 'optional', then configuration proceeds
-#   regardless, after defining HAVE_CXX${VERSION} if and only if a
-#   supporting mode is found.
-#
-# LICENSE
-#
-#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
-#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
-#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
-#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>
-#   Copyright (c) 2015 Paul Norman <penorman@mac.com>
-#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>
-#   Copyright (c) 2016 Krzesimir Nowak <qdlacz@gmail.com>
-#
-#   Copying and distribution of this file, with or without modification, are
-#   permitted in any medium without royalty provided the copyright notice
-#   and this notice are preserved.  This file is offered as-is, without any
-#   warranty.
-
-#serial 6
-
-dnl  This macro is based on the code from the AX_CXX_COMPILE_STDCXX_11 macro
-dnl  (serial version number 13).
-
-AX_REQUIRE_DEFINED([AC_MSG_WARN])
-AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl
-  m4_if([$1], [11], [ax_cxx_compile_alternatives="11 0x"],
-        [$1], [14], [ax_cxx_compile_alternatives="14 1y"],
-        [$1], [17], [ax_cxx_compile_alternatives="17 1z"],
-        [m4_fatal([invalid first argument `$1' to AX_CXX_COMPILE_STDCXX])])dnl
-  m4_if([$2], [], [],
-        [$2], [ext], [],
-        [$2], [noext], [],
-        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX])])dnl
-  m4_if([$3], [], [ax_cxx_compile_cxx$1_required=true],
-        [$3], [mandatory], [ax_cxx_compile_cxx$1_required=true],
-        [$3], [optional], [ax_cxx_compile_cxx$1_required=false],
-        [m4_fatal([invalid third argument `$3' to AX_CXX_COMPILE_STDCXX])])
-  AC_LANG_PUSH([C++])dnl
-  ac_success=no
-  AC_CACHE_CHECK(whether $CXX supports C++$1 features by default,
-  ax_cv_cxx_compile_cxx$1,
-  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
-    [ax_cv_cxx_compile_cxx$1=yes],
-    [ax_cv_cxx_compile_cxx$1=no])])
-  if test x$ax_cv_cxx_compile_cxx$1 = xyes; then
-    ac_success=yes
-  fi
-
-  m4_if([$2], [noext], [], [dnl
-  if test x$ac_success = xno; then
-    for alternative in ${ax_cxx_compile_alternatives}; do
-      switch="-std=gnu++${alternative}"
-      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
-      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
-                     $cachevar,
-        [ac_save_CXX="$CXX"
-         CXX="$CXX $switch"
-         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
-          [eval $cachevar=yes],
-          [eval $cachevar=no])
-         CXX="$ac_save_CXX"])
-      if eval test x\$$cachevar = xyes; then
-        CXX="$CXX $switch"
-        if test -n "$CXXCPP" ; then
-          CXXCPP="$CXXCPP $switch"
-        fi
-        ac_success=yes
-        break
-      fi
-    done
-  fi])
-
-  m4_if([$2], [ext], [], [dnl
-  if test x$ac_success = xno; then
-    dnl HP's aCC needs +std=c++11 according to:
-    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf
-    dnl Cray's crayCC needs "-h std=c++11"
-    for alternative in ${ax_cxx_compile_alternatives}; do
-      for switch in -std=c++${alternative} +std=c++${alternative} "-h std=c++${alternative}"; do
-        cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
-        AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
-                       $cachevar,
-          [ac_save_CXX="$CXX"
-           CXX="$CXX $switch"
-           AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
-            [eval $cachevar=yes],
-            [eval $cachevar=no])
-           CXX="$ac_save_CXX"])
-        if eval test x\$$cachevar = xyes; then
-          CXX="$CXX $switch"
-          if test -n "$CXXCPP" ; then
-            CXXCPP="$CXXCPP $switch"
-          fi
-          ac_success=yes
-          break
-        fi
-      done
-      if test x$ac_success = xyes; then
-        break
-      fi
-    done
-  fi])
-  AC_LANG_POP([C++])
-  if test x$ax_cxx_compile_cxx$1_required = xtrue; then
-    if test x$ac_success = xno; then
-      AC_MSG_ERROR([*** A compiler with support for C++$1 language features is required.])
-    fi
-  fi
-  if test x$ac_success = xno; then
-    HAVE_CXX$1=0
-    AC_MSG_NOTICE([No compiler with C++$1 support was found])
-  else
-    HAVE_CXX$1=1
-    AC_DEFINE(HAVE_CXX$1,1,
-              [define if the compiler supports basic C++$1 syntax])
-  fi
-  AC_SUBST(HAVE_CXX$1)
-  m4_if([$1], [17], [AC_MSG_WARN([C++17 is not yet standardized, so the checks may change in incompatible ways anytime])])
-])
-
-
-dnl  Test body for checking C++11 support
-
-m4_define([_AX_CXX_COMPILE_STDCXX_testbody_11],
-  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
-)
-
-
-dnl  Test body for checking C++14 support
-
-m4_define([_AX_CXX_COMPILE_STDCXX_testbody_14],
-  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
-  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14
-)
-
-m4_define([_AX_CXX_COMPILE_STDCXX_testbody_17],
-  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
-  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14
-  _AX_CXX_COMPILE_STDCXX_testbody_new_in_17
-)
-
-dnl  Tests for new features in C++11
-
-m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_11], [[
-
-// If the compiler admits that it is not ready for C++11, why torture it?
-// Hopefully, this will speed up the test.
-
-#ifndef __cplusplus
-
-#error "This is not a C++ compiler"
-
-#elif __cplusplus < 201103L
-
-#error "This is not a C++11 compiler"
-
-#else
-
-namespace cxx11
-{
-
-  namespace test_static_assert
-  {
-
-    template <typename T>
-    struct check
-    {
-      static_assert(sizeof(int) <= sizeof(T), "not big enough");
-    };
-
-  }
-
-  namespace test_final_override
-  {
-
-    struct Base
-    {
-      virtual void f() {}
-    };
-
-    struct Derived : public Base
-    {
-      virtual void f() override {}
-    };
-
-  }
-
-  namespace test_double_right_angle_brackets
-  {
-
-    template < typename T >
-    struct check {};
-
-    typedef check<void> single_type;
-    typedef check<check<void>> double_type;
-    typedef check<check<check<void>>> triple_type;
-    typedef check<check<check<check<void>>>> quadruple_type;
-
-  }
-
-  namespace test_decltype
-  {
-
-    int
-    f()
-    {
-      int a = 1;
-      decltype(a) b = 2;
-      return a + b;
-    }
-
-  }
-
-  namespace test_type_deduction
-  {
-
-    template < typename T1, typename T2 >
-    struct is_same
-    {
-      static const bool value = false;
-    };
-
-    template < typename T >
-    struct is_same<T, T>
-    {
-      static const bool value = true;
-    };
-
-    template < typename T1, typename T2 >
-    auto
-    add(T1 a1, T2 a2) -> decltype(a1 + a2)
-    {
-      return a1 + a2;
-    }
-
-    int
-    test(const int c, volatile int v)
-    {
-      static_assert(is_same<int, decltype(0)>::value == true, "");
-      static_assert(is_same<int, decltype(c)>::value == false, "");
-      static_assert(is_same<int, decltype(v)>::value == false, "");
-      auto ac = c;
-      auto av = v;
-      auto sumi = ac + av + 'x';
-      auto sumf = ac + av + 1.0;
-      static_assert(is_same<int, decltype(ac)>::value == true, "");
-      static_assert(is_same<int, decltype(av)>::value == true, "");
-      static_assert(is_same<int, decltype(sumi)>::value == true, "");
-      static_assert(is_same<int, decltype(sumf)>::value == false, "");
-      static_assert(is_same<int, decltype(add(c, v))>::value == true, "");
-      return (sumf > 0.0) ? sumi : add(c, v);
-    }
-
-  }
-
-  namespace test_noexcept
-  {
-
-    int f() { return 0; }
-    int g() noexcept { return 0; }
-
-    static_assert(noexcept(f()) == false, "");
-    static_assert(noexcept(g()) == true, "");
-
-  }
-
-  namespace test_constexpr
-  {
-
-    template < typename CharT >
-    unsigned long constexpr
-    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept
-    {
-      return *s ? strlen_c_r(s + 1, acc + 1) : acc;
-    }
-
-    template < typename CharT >
-    unsigned long constexpr
-    strlen_c(const CharT *const s) noexcept
-    {
-      return strlen_c_r(s, 0UL);
-    }
-
-    static_assert(strlen_c("") == 0UL, "");
-    static_assert(strlen_c("1") == 1UL, "");
-    static_assert(strlen_c("example") == 7UL, "");
-    static_assert(strlen_c("another\0example") == 7UL, "");
-
-  }
-
-  namespace test_rvalue_references
-  {
-
-    template < int N >
-    struct answer
-    {
-      static constexpr int value = N;
-    };
-
-    answer<1> f(int&)       { return answer<1>(); }
-    answer<2> f(const int&) { return answer<2>(); }
-    answer<3> f(int&&)      { return answer<3>(); }
-
-    void
-    test()
-    {
-      int i = 0;
-      const int c = 0;
-      static_assert(decltype(f(i))::value == 1, "");
-      static_assert(decltype(f(c))::value == 2, "");
-      static_assert(decltype(f(0))::value == 3, "");
-    }
-
-  }
-
-  namespace test_uniform_initialization
-  {
-
-    struct test
-    {
-      static const int zero {};
-      static const int one {1};
-    };
-
-    static_assert(test::zero == 0, "");
-    static_assert(test::one == 1, "");
-
-  }
-
-  namespace test_lambdas
-  {
-
-    void
-    test1()
-    {
-      auto lambda1 = [](){};
-      auto lambda2 = lambda1;
-      lambda1();
-      lambda2();
-    }
-
-    int
-    test2()
-    {
-      auto a = [](int i, int j){ return i + j; }(1, 2);
-      auto b = []() -> int { return '0'; }();
-      auto c = [=](){ return a + b; }();
-      auto d = [&](){ return c; }();
-      auto e = [a, &b](int x) mutable {
-        const auto identity = [](int y){ return y; };
-        for (auto i = 0; i < a; ++i)
-          a += b--;
-        return x + identity(a + b);
-      }(0);
-      return a + b + c + d + e;
-    }
-
-    int
-    test3()
-    {
-      const auto nullary = [](){ return 0; };
-      const auto unary = [](int x){ return x; };
-      using nullary_t = decltype(nullary);
-      using unary_t = decltype(unary);
-      const auto higher1st = [](nullary_t f){ return f(); };
-      const auto higher2nd = [unary](nullary_t f1){
-        return [unary, f1](unary_t f2){ return f2(unary(f1())); };
-      };
-      return higher1st(nullary) + higher2nd(nullary)(unary);
-    }
-
-  }
-
-  namespace test_variadic_templates
-  {
-
-    template <int...>
-    struct sum;
-
-    template <int N0, int... N1toN>
-    struct sum<N0, N1toN...>
-    {
-      static constexpr auto value = N0 + sum<N1toN...>::value;
-    };
-
-    template <>
-    struct sum<>
-    {
-      static constexpr auto value = 0;
-    };
-
-    static_assert(sum<>::value == 0, "");
-    static_assert(sum<1>::value == 1, "");
-    static_assert(sum<23>::value == 23, "");
-    static_assert(sum<1, 2>::value == 3, "");
-    static_assert(sum<5, 5, 11>::value == 21, "");
-    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, "");
-
-  }
-
-  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
-  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function
-  // because of this.
-  namespace test_template_alias_sfinae
-  {
-
-    struct foo {};
-
-    template<typename T>
-    using member = typename T::member_type;
-
-    template<typename T>
-    void func(...) {}
-
-    template<typename T>
-    void func(member<T>*) {}
-
-    void test();
-
-    void test() { func<foo>(0); }
-
-  }
-
-}  // namespace cxx11
-
-#endif  // __cplusplus >= 201103L
-
-]])
-
-
-dnl  Tests for new features in C++14
-
-m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_14], [[
-
-// If the compiler admits that it is not ready for C++14, why torture it?
-// Hopefully, this will speed up the test.
-
-#ifndef __cplusplus
-
-#error "This is not a C++ compiler"
-
-#elif __cplusplus < 201402L
-
-#error "This is not a C++14 compiler"
-
-#else
-
-namespace cxx14
-{
-
-  namespace test_polymorphic_lambdas
-  {
-
-    int
-    test()
-    {
-      const auto lambda = [](auto&&... args){
-        const auto istiny = [](auto x){
-          return (sizeof(x) == 1UL) ? 1 : 0;
-        };
-        const int aretiny[] = { istiny(args)... };
-        return aretiny[0];
-      };
-      return lambda(1, 1L, 1.0f, '1');
-    }
-
-  }
-
-  namespace test_binary_literals
-  {
-
-    constexpr auto ivii = 0b0000000000101010;
-    static_assert(ivii == 42, "wrong value");
-
-  }
-
-  namespace test_generalized_constexpr
-  {
-
-    template < typename CharT >
-    constexpr unsigned long
-    strlen_c(const CharT *const s) noexcept
-    {
-      auto length = 0UL;
-      for (auto p = s; *p; ++p)
-        ++length;
-      return length;
-    }
-
-    static_assert(strlen_c("") == 0UL, "");
-    static_assert(strlen_c("x") == 1UL, "");
-    static_assert(strlen_c("test") == 4UL, "");
-    static_assert(strlen_c("another\0test") == 7UL, "");
-
-  }
-
-  namespace test_lambda_init_capture
-  {
-
-    int
-    test()
-    {
-      auto x = 0;
-      const auto lambda1 = [a = x](int b){ return a + b; };
-      const auto lambda2 = [a = lambda1(x)](){ return a; };
-      return lambda2();
-    }
-
-  }
-
-  namespace test_digit_separators
-  {
-
-    constexpr auto ten_million = 100'000'000;
-    static_assert(ten_million == 100000000, "");
-
-  }
-
-  namespace test_return_type_deduction
-  {
-
-    auto f(int& x) { return x; }
-    decltype(auto) g(int& x) { return x; }
-
-    template < typename T1, typename T2 >
-    struct is_same
-    {
-      static constexpr auto value = false;
-    };
-
-    template < typename T >
-    struct is_same<T, T>
-    {
-      static constexpr auto value = true;
-    };
-
-    int
-    test()
-    {
-      auto x = 0;
-      static_assert(is_same<int, decltype(f(x))>::value, "");
-      static_assert(is_same<int&, decltype(g(x))>::value, "");
-      return x;
-    }
-
-  }
-
-}  // namespace cxx14
-
-#endif  // __cplusplus >= 201402L
-
-]])
-
-
-dnl  Tests for new features in C++17
-
-m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_17], [[
-
-// If the compiler admits that it is not ready for C++17, why torture it?
-// Hopefully, this will speed up the test.
-
-#ifndef __cplusplus
-
-#error "This is not a C++ compiler"
-
-#elif __cplusplus <= 201402L
-
-#error "This is not a C++17 compiler"
-
-#else
-
-#if defined(__clang__)
-  #define REALLY_CLANG
-#else
-  #if defined(__GNUC__)
-    #define REALLY_GCC
-  #endif
-#endif
-
-#include <initializer_list>
-#include <utility>
-#include <type_traits>
-
-namespace cxx17
-{
-
-#if !defined(REALLY_CLANG)
-  namespace test_constexpr_lambdas
-  {
-
-    // TODO: test it with clang++ from git
-
-    constexpr int foo = [](){return 42;}();
-
-  }
-#endif // !defined(REALLY_CLANG)
-
-  namespace test::nested_namespace::definitions
-  {
-
-  }
-
-  namespace test_fold_expression
-  {
-
-    template<typename... Args>
-    int multiply(Args... args)
-    {
-      return (args * ... * 1);
-    }
-
-    template<typename... Args>
-    bool all(Args... args)
-    {
-      return (args && ...);
-    }
-
-  }
-
-  namespace test_extended_static_assert
-  {
-
-    static_assert (true);
-
-  }
-
-  namespace test_auto_brace_init_list
-  {
-
-    auto foo = {5};
-    auto bar {5};
-
-    static_assert(std::is_same<std::initializer_list<int>, decltype(foo)>::value);
-    static_assert(std::is_same<int, decltype(bar)>::value);
-  }
-
-  namespace test_typename_in_template_template_parameter
-  {
-
-    template<template<typename> typename X> struct D;
-
-  }
-
-  namespace test_fallthrough_nodiscard_maybe_unused_attributes
-  {
-
-    int f1()
-    {
-      return 42;
-    }
-
-    [[nodiscard]] int f2()
-    {
-      [[maybe_unused]] auto unused = f1();
-
-      switch (f1())
-      {
-      case 17:
-        f1();
-        [[fallthrough]];
-      case 42:
-        f1();
-      }
-      return f1();
-    }
-
-  }
-
-  namespace test_extended_aggregate_initialization
-  {
-
-    struct base1
-    {
-      int b1, b2 = 42;
-    };
-
-    struct base2
-    {
-      base2() {
-        b3 = 42;
-      }
-      int b3;
-    };
-
-    struct derived : base1, base2
-    {
-        int d;
-    };
-
-    derived d1 {{1, 2}, {}, 4};  // full initialization
-    derived d2 {{}, {}, 4};      // value-initialized bases
-
-  }
-
-  namespace test_general_range_based_for_loop
-  {
-
-    struct iter
-    {
-      int i;
-
-      int& operator* ()
-      {
-        return i;
-      }
-
-      const int& operator* () const
-      {
-        return i;
-      }
-
-      iter& operator++()
-      {
-        ++i;
-        return *this;
-      }
-    };
-
-    struct sentinel
-    {
-      int i;
-    };
-
-    bool operator== (const iter& i, const sentinel& s)
-    {
-      return i.i == s.i;
-    }
-
-    bool operator!= (const iter& i, const sentinel& s)
-    {
-      return !(i == s);
-    }
-
-    struct range
-    {
-      iter begin() const
-      {
-        return {0};
-      }
-
-      sentinel end() const
-      {
-        return {5};
-      }
-    };
-
-    void f()
-    {
-      range r {};
-
-      for (auto i : r)
-      {
-        [[maybe_unused]] auto v = i;
-      }
-    }
-
-  }
-
-  namespace test_lambda_capture_asterisk_this_by_value
-  {
-
-    struct t
-    {
-      int i;
-      int foo()
-      {
-        return [*this]()
-        {
-          return i;
-        }();
-      }
-    };
-
-  }
-
-  namespace test_enum_class_construction
-  {
-
-    enum class byte : unsigned char
-    {};
-
-    byte foo {42};
-
-  }
-
-  namespace test_constexpr_if
-  {
-
-    template <bool cond>
-    int f ()
-    {
-      if constexpr(cond)
-      {
-        return 13;
-      }
-      else
-      {
-        return 42;
-      }
-    }
-
-  }
-
-  namespace test_selection_statement_with_initializer
-  {
-
-    int f()
-    {
-      return 13;
-    }
-
-    int f2()
-    {
-      if (auto i = f(); i > 0)
-      {
-        return 3;
-      }
-
-      switch (auto i = f(); i + 4)
-      {
-      case 17:
-        return 2;
-
-      default:
-        return 1;
-      }
-    }
-
-  }
-
-#if !defined(REALLY_CLANG)
-  namespace test_template_argument_deduction_for_class_templates
-  {
-
-    // TODO: test it with clang++ from git
-
-    template <typename T1, typename T2>
-    struct pair
-    {
-      pair (T1 p1, T2 p2)
-        : m1 {p1},
-          m2 {p2}
-      {}
-
-      T1 m1;
-      T2 m2;
-    };
-
-    void f()
-    {
-      [[maybe_unused]] auto p = pair{13, 42u};
-    }
-
-  }
-#endif // !defined(REALLY_CLANG)
-
-  namespace test_non_type_auto_template_parameters
-  {
-
-    template <auto n>
-    struct B
-    {};
-
-    B<5> b1;
-    B<'a'> b2;
-
-  }
-
-#if !defined(REALLY_CLANG)
-  namespace test_structured_bindings
-  {
-
-    // TODO: test it with clang++ from git
-
-    int arr[2] = { 1, 2 };
-    std::pair<int, int> pr = { 1, 2 };
-
-    auto f1() -> int(&)[2]
-    {
-      return arr;
-    }
-
-    auto f2() -> std::pair<int, int>&
-    {
-      return pr;
-    }
-
-    struct S
-    {
-      int x1 : 2;
-      volatile double y1;
-    };
-
-    S f3()
-    {
-      return {};
-    }
-
-    auto [ x1, y1 ] = f1();
-    auto& [ xr1, yr1 ] = f1();
-    auto [ x2, y2 ] = f2();
-    auto& [ xr2, yr2 ] = f2();
-    const auto [ x3, y3 ] = f3();
-
-  }
-#endif // !defined(REALLY_CLANG)
-
-#if !defined(REALLY_CLANG)
-  namespace test_exception_spec_type_system
-  {
-
-    // TODO: test it with clang++ from git
-
-    struct Good {};
-    struct Bad {};
-
-    void g1() noexcept;
-    void g2();
-
-    template<typename T>
-    Bad
-    f(T*, T*);
-
-    template<typename T1, typename T2>
-    Good
-    f(T1*, T2*);
-
-    static_assert (std::is_same_v<Good, decltype(f(g1, g2))>);
-
-  }
-#endif // !defined(REALLY_CLANG)
-
-  namespace test_inline_variables
-  {
-
-    template<class T> void f(T)
-    {}
-
-    template<class T> inline T g(T)
-    {
-      return T{};
-    }
-
-    template<> inline void f<>(int)
-    {}
-
-    template<> int g<>(int)
-    {
-      return 5;
-    }
-
-  }
-
-}  // namespace cxx17
-
-#endif  // __cplusplus <= 201402L
-
-]])
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Makefile.am treadmill/Makefile.am
--- treadmill-src/Makefile.am	2025-08-11 17:04:00.474073838 -0700
+++ treadmill/Makefile.am	1969-12-31 16:00:00.000000000 -0800
@@ -1,74 +0,0 @@
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
-ACLOCAL_AMFLAGS = -I m4
-
-AM_CPPFLAGS = -I$(top_srcdir)/..
-
-# Compile the thrift files first
-BUILT_SOURCES = \
-	services/sleep/gen-cpp2/Sleep.h
-
-services/sleep/gen-cpp2/Sleep.h: services/sleep/sleep.thrift
-	PYTHONPATH=$(THRIFT2_COMP_DIR)/..:$$PYTHONPATH $(THRIFT) --gen cpp2 -o services/sleep/ $<
-
-noinst_LIBRARIES = libtreadmill.a
-
-libtreadmill_a_SOURCES = \
-	Connection.h \
-	Histogram.h \
-	Request.h \
-	RandomEngine.h \
-	Scheduler.h \
-	Statistic.h \
-	ContinuousStatistic.h \
-	CounterStatistic.h \
-	StatisticsManager.h \
-	Treadmill.h \
-	Util.h \
-	Worker.h \
-	Workload.h \
-	Histogram.cpp \
-	RandomEngine.cpp \
-	Scheduler.cpp \
-	Treadmill.cpp \
-	ContinuousStatistic.cpp \
-	CounterStatistic.cpp \
-	StatisticsManager.cpp \
-	Util.cpp
-
-bin_PROGRAMS = \
-	treadmill_memcached \
-	treadmill_sleep
-
-# Ignore treadmill_libmcrouter for now
-
-treadmill_memcached_SOURCES = \
-	services/memcached/Connection.h \
-	services/memcached/MemcachedService.h \
-	services/memcached/Request.h \
-	services/memcached/Treadmill.cpp \
-	services/memcached/Workload.h
-
-treadmill_memcached_LDADD = \
-	libtreadmill.a
-
-treadmill_sleep_SOURCES = \
-	services/sleep/Treadmill.cpp \
-	services/sleep/gen-cpp2/sleep_constants.cpp \
-	services/sleep/gen-cpp2/sleep_data.cpp \
-	services/sleep/gen-cpp2/sleep_types.cpp \
-	services/sleep/gen-cpp2/Sleep.cpp \
-	services/sleep/gen-cpp2/SleepAsyncClient.cpp \
-	services/sleep/gen-cpp2/Sleep_processmap_binary.cpp \
-	services/sleep/gen-cpp2/Sleep_processmap_compact.cpp
-
-treadmill_sleep_LDADD = \
-	libtreadmill.a
-
-treadmill_libmcrouter_SOURCES = \
-	services/libmcrouter/Connection.h \
-	services/libmcrouter/LibmcrouterService.h \
-	services/libmcrouter/Workload.h \
-	services/libmcrouter/Treadmill.cpp
-
-treadmill_libmcrouter_LDADD = \
-	libtreadmill.a
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/RandomEngine.cpp treadmill/RandomEngine.cpp
--- treadmill-src/RandomEngine.cpp	2025-08-11 17:04:00.474959246 -0700
+++ treadmill/RandomEngine.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,86 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-#include "treadmill/RandomEngine.h"
-
-#include <sys/time.h>
-#include <thread>
-
-#include <folly/Likely.h>
-
-DEFINE_uint64(treadmill_random_seed, ULLONG_MAX, "seed for random engines");
-
-using std::mt19937_64;
-using std::uniform_int_distribution;
-using std::uniform_real_distribution;
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-// Seed the random engine
-mt19937_64 RandomEngine::random_engine_(
-    FLAGS_treadmill_random_seed == ULLONG_MAX ? time(nullptr)
-                                              : FLAGS_treadmill_random_seed);
-// Generate a uniform distribution
-uniform_real_distribution<double> RandomEngine::uniform_real_distribution_(
-    0.0,
-    1.0);
-uniform_int_distribution<uint64_t> RandomEngine::uniform_int_distribution_(
-    0,
-    ULLONG_MAX);
-
-// Empty thread-local random engine
-folly::ThreadLocalPtr<std::mt19937_64> ThreadSafeRandomEngine::random_engine_;
-
-double RandomEngine::getDouble() {
-  return uniform_real_distribution_(random_engine_);
-}
-
-double RandomEngine::getDouble(double min, double max) {
-  uniform_real_distribution<double> dist(min, max);
-  return dist(random_engine_);
-}
-
-uint64_t RandomEngine::getInteger() {
-  return uniform_int_distribution_(random_engine_);
-}
-
-uint64_t RandomEngine::getInteger(uint64_t min, uint64_t max) {
-  uniform_int_distribution<uint64_t> dist(min, max);
-  return dist(random_engine_);
-}
-
-mt19937_64& ThreadSafeRandomEngine::get() {
-  mt19937_64* engine = random_engine_.get();
-  if (UNLIKELY(engine == nullptr)) {
-    std::hash<std::thread::id> hasher;
-    uint64_t seed = hasher(std::this_thread::get_id()) +
-        (FLAGS_treadmill_random_seed == ULLONG_MAX
-             ? time(nullptr)
-             : FLAGS_treadmill_random_seed);
-    engine = new mt19937_64(seed);
-    random_engine_.reset(engine);
-  }
-  return *engine;
-}
-
-double ThreadSafeRandomEngine::getDouble(double min, double max) {
-  uniform_real_distribution<double> dist(min, max);
-  return dist(get());
-}
-
-uint64_t ThreadSafeRandomEngine::getInteger(uint64_t min, uint64_t max) {
-  uniform_int_distribution<uint64_t> dist(min, max);
-  return dist(get());
-}
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/RandomEngine.h treadmill/RandomEngine.h
--- treadmill-src/RandomEngine.h	2025-08-11 17:04:00.475447816 -0700
+++ treadmill/RandomEngine.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,110 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-#pragma once
-
-#include <random>
-
-#include <folly/ThreadLocal.h>
-
-DECLARE_uint64(treadmill_random_seed);
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-/**
- * Shared struct for Mersene Twister 19937 generator (64 bit)
- *
- * The struct produces a shared random number stream that all threads can
- * access.
- * The struct might not be thread-safe or have high locking contention depending
- * on the underlying STL implementation.
- * If you want a thread-safe PRNG for each thread, use ThreadSafeRandomEngine.
- */
-struct RandomEngine {
- public:
-  /**
-   * Return a random number ranging in [0.0, 1.0] in double
-   *
-   * @return A random number ranging in [0.0, 1.0] in double
-   */
-  static double getDouble();
-
-  /**
-   * Return a random number ranging in [min, max] in double
-   *
-   * @return A random number ranging in [min, max] in double
-   */
-  static double getDouble(double min, double max);
-
-  /**
-   * Return a random number ranging in [0, 2^64-1] in uint64_t
-   *
-   * @return A random number ranging in [0, 2^64-1] in uint64_t
-   */
-  static uint64_t getInteger();
-
-  /**
-   * Return a random number ranging in [min, max] in uint64_t
-   *
-   * @return A random number ranging in [min, max] in uint64_t
-   */
-  static uint64_t getInteger(uint64_t min, uint64_t max);
-
- private:
-  // The Mersene Twister 19937 random engine (64 bit)
-  static std::mt19937_64 random_engine_;
-  // A uniform distribution for real numbers
-  static std::uniform_real_distribution<double> uniform_real_distribution_;
-  // A uniform distribution for integer numbers
-  static std::uniform_int_distribution<uint64_t> uniform_int_distribution_;
-};
-
-/**
- * Thread-local struct for Mersene Twister 19937 generator (64 bit)
- *
- * This struct produces a private random number stream for current thread.
- * Should perform better than the shared engine.
- * Different threads will have different seeds derived from the global seed and
- * their thread ids.
- * The correlation between streams of all threads might not be 0.
- * Don't use if you have strong requirement on randomness.
- */
-struct ThreadSafeRandomEngine {
- public:
-  /**
-   * Return a random number ranging in [min, max] in double
-   *
-   * @return A random number ranging in [min, max] in double
-   */
-  static double getDouble(double min, double max);
-
-  /**
-   * Return a random number ranging in [min, max] in uint64_t
-   *
-   * @return A random number ranging in [min, max] in uint64_t
-   */
-  static uint64_t getInteger(uint64_t min, uint64_t max);
-
- private:
-  /**
-   * Return the underlying random engine
-   *
-   * @return The underlying random engine
-   */
-  static std::mt19937_64& get();
-
-  // The Mersene Twister 19937 random engine (64 bit)
-  static folly::ThreadLocalPtr<std::mt19937_64> random_engine_;
-};
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/README.md treadmill/README.md
--- treadmill-src/README.md	2025-08-11 17:04:00.474575697 -0700
+++ treadmill/README.md	2025-08-04 15:44:21.751212503 -0700
@@ -1,6 +1,6 @@
 ## Treadmill [![Build Status](https://travis-ci.org/facebook/treadmill.svg?branch=master)](https://travis-ci.org/facebook/treadmill)

-Treadmill is an open-source modular load testing platform for characterizing
+Treadmill is an open-source modular load testing platform for characeterizing
 server-side applications (_e.g._, [Memcached](http://memcached.org/),
 [Mcrouter](https://github.com/facebook/mcrouter), and
 [FBThrift](https://github.com/facebook/fbthrift).
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Request.h treadmill/Request.h
--- treadmill-src/Request.h	2025-08-11 17:04:00.475781400 -0700
+++ treadmill/Request.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,21 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-class Request {};
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Scheduler.cpp treadmill/Scheduler.cpp
--- treadmill-src/Scheduler.cpp	2025-08-11 17:04:00.476083337 -0700
+++ treadmill/Scheduler.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,198 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#include "treadmill/Scheduler.h"
-
-#include <folly/Memory.h>
-#include <folly/futures/Future.h>
-#include <folly/futures/Promise.h>
-
-#include "treadmill/Util.h"
-
-DEFINE_bool(
-    wait_for_runner_ready,
-    false,
-    "If true, wait for a 'resume' message before sending requests.");
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-Scheduler::Scheduler(
-    uint32_t rps,
-    uint32_t number_of_workers,
-    uint32_t logging_threshold)
-    : logging_threshold_(logging_threshold),
-      rps_(rps),
-      max_outstanding_requests_(0),
-      logged_(number_of_workers, 1),
-      queues_(number_of_workers) {
-  state_.store(
-      FLAGS_wait_for_runner_ready ? PAUSED : RUNNING,
-      std::memory_order_relaxed);
-}
-
-Scheduler::Scheduler(
-    uint32_t rps,
-    uint32_t number_of_workers,
-    uint32_t max_outstanding_requests,
-    uint32_t logging_threshold)
-    : logging_threshold_(logging_threshold),
-      rps_(rps),
-      max_outstanding_requests_(max_outstanding_requests),
-      logged_(number_of_workers, 1),
-      queues_(number_of_workers) {
-  state_.store(
-      FLAGS_wait_for_runner_ready ? PAUSED : RUNNING,
-      std::memory_order_relaxed);
-}
-
-Scheduler::~Scheduler() {}
-
-folly::Future<folly::Unit> Scheduler::run() {
-  if (state_ != RUNNING) {
-    LOG(INFO) << "Scheduler is not in the running state. "
-              << "Assuming resume will be called in future.";
-  }
-  thread_ = std::make_unique<std::thread>([this] { this->loop(); });
-  return promise_.getFuture();
-}
-
-void Scheduler::pause() {
-  RunState expected = RUNNING;
-  state_.compare_exchange_strong(expected, PAUSED);
-}
-
-bool Scheduler::resume() {
-  RunState expected = PAUSED;
-  state_.compare_exchange_strong(expected, RUNNING);
-
-  // Now return if we are running. It's possible that the scheduler was already
-  // running so we don't return the bool from compare_exchange_strong.
-  return state_ == RUNNING;
-}
-
-bool Scheduler::isRunning() {
-  return state_ == RUNNING;
-}
-
-void Scheduler::setPhase(const std::string& phase_name) {
-  if (FLAGS_wait_for_runner_ready) {
-    CHECK_EQ(state_, PAUSED);
-  }
-  messageAllWorkers(Event(EventType::SET_PHASE, phase_name));
-}
-
-int32_t Scheduler::getMaxOutstandingRequests() {
-  return max_outstanding_requests_;
-}
-
-void Scheduler::setMaxOutstandingRequests(int32_t max_outstanding_requests) {
-  max_outstanding_requests_ = max_outstanding_requests;
-  messageAllWorkers(
-      Event(EventType::SET_MAX_OUTSTANDING, max_outstanding_requests_));
-}
-
-void Scheduler::stop() {
-  state_.store(STOPPING);
-}
-
-void Scheduler::join() {
-  CHECK(state_ == STOPPING);
-  thread_->join();
-}
-
-folly::NotificationQueue<Event>& Scheduler::getWorkerQueue(uint32_t id) {
-  return queues_[id];
-}
-
-int32_t Scheduler::getRps() {
-  return rps_;
-}
-
-void Scheduler::setRps(int32_t rps) {
-  rps_ = rps;
-}
-
-double Scheduler::randomExponentialInterval(double mean) {
-  static std::mt19937* rng = new std::mt19937();
-  std::uniform_real_distribution<double> dist(0, 1.0);
-  /* Cap the lower end so that we don't return infinity */
-  return -log(std::max(dist(*rng), 1e-9)) * mean;
-}
-
-void Scheduler::waitNs(int64_t ns) {
-  /* We need to have *precise* timing, and it's not achievable with any other
-     means like 'nanosleep' or EventBase.
-     "pause" instruction would hint processor that this is a spin-loop, it
-     will burn as much CPU as possible. The processor will use this hint
-     to avoid memory order violation, which greatly improves its performance.
-     http://siyobik.info.gf/main/reference/instruction/PAUSE */
-  for (auto start = nowNs(); nowNs() - start < ns;) {
-    asm volatile("pause");
-  }
-}
-
-void Scheduler::messageAllWorkers(Event event) {
-  for (int i = 0; i < queues_.size(); ++i) {
-    queues_[i].putMessage(event);
-  }
-}
-
-/**
- * Responsible for generating requests events.
- * Requests are randomly spaced (intervals are drawn from an
- * exponential distribution) to achieve the target throughput rate.
- * Events would be put into notification queues, which would be selected in
- * round-robin fashion.
- */
-void Scheduler::loop() {
-  do {
-    messageAllWorkers(Event(EventType::RESET));
-    next_ = 0;
-    int32_t rps = rps_;
-    int64_t interval_ns = 1.0 / rps * k_ns_per_s;
-    int64_t a = 0, b = 0, budget = randomExponentialInterval(interval_ns);
-    while (state_ == RUNNING) {
-      b = nowNs();
-      if (a) {
-        /* Account for time spent sending the message */
-        budget -= (b - a);
-      }
-      waitNs(std::max(budget, 0L));
-      a = nowNs();
-      /* Decrease the sleep budget by the exact time slept (could have been
-         more than the budget value), increase by the next interval */
-      budget += randomExponentialInterval(interval_ns) - (a - b);
-      queues_[next_].putMessage(Event(EventType::SEND_REQUEST));
-      if (queues_[next_].size() > logging_threshold_ * logged_[next_]) {
-        LOG(INFO) << "Notification queue for worker " << next_
-                  << " is overloaded by factor of " << logged_[next_];
-        logged_[next_] *= 2;
-      }
-      ++next_;
-      if (next_ == queues_.size()) {
-        next_ = 0;
-      }
-      if (rps != rps_) {
-        rps = rps_;
-        interval_ns = 1.0 / rps * k_ns_per_s;
-      }
-    }
-    while (state_ == PAUSED)
-      waitNs(1000);
-  } while (state_ != STOPPING);
-  messageAllWorkers(Event(EventType::STOP));
-  promise_.setValue(folly::Unit());
-}
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Scheduler.h treadmill/Scheduler.h
--- treadmill-src/Scheduler.h	2025-08-11 17:04:00.476339515 -0700
+++ treadmill/Scheduler.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,108 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-#include <memory>
-#include <thread>
-
-#include <folly/futures/Future.h>
-#include <folly/futures/Promise.h>
-#include <folly/io/async/NotificationQueue.h>
-
-#include "treadmill/Event.h"
-
-DECLARE_bool(wait_for_runner_ready);
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-class Scheduler {
- public:
-  Scheduler(
-      uint32_t rps,
-      uint32_t number_of_workers,
-      uint32_t logging_threshold);
-  Scheduler(
-      uint32_t rps,
-      uint32_t number_of_workers,
-      uint32_t max_outstanding_requests,
-      uint32_t logging_threshold);
-  ~Scheduler();
-
-  folly::Future<folly::Unit> run();
-
-  // Transition from running to paused (no-op if not running).
-  void pause();
-
-  // Transition from paused to running (no-op if not paused). Returns bool
-  // representing if the scheduler is now in a running state.
-  bool resume();
-
-  // Returns true if the scheduler state is equal to running
-  bool isRunning();
-
-  // Set the phase of the test
-  void setPhase(const std::string& phase_name);
-
-  int32_t getMaxOutstandingRequests();
-
-  // set the maximum outstanding requests for the Workers
-  void setMaxOutstandingRequests(int32_t max_outstanding);
-
-  // It is safe to call stop() multiple times.
-  void stop();
-
-  // The scheduler _must_ be stopped first.
-  void join();
-
-  folly::NotificationQueue<Event>& getWorkerQueue(uint32_t id);
-
-  int32_t getRps();
-
-  void setRps(int32_t rps);
-
- private:
-  enum RunState { RUNNING, PAUSED, STOPPING };
-
-  /**
-   * Draws from an exponential distribution with the given mean.
-   */
-  static double randomExponentialInterval(double mean);
-
-  /**
-   * Waits until given amount of nanosecond pases, for precise timing it uses
-   * spin-loop.
-   */
-  static void waitNs(int64_t ns);
-
-  /**
-   * Puts given message on each worker's queue.
-   */
-  void messageAllWorkers(Event event);
-
-  void loop();
-
-  uint32_t logging_threshold_;
-  uint32_t next_{0};
-  uint32_t rps_;
-  uint32_t max_outstanding_requests_;
-
-  std::vector<uint64_t> logged_;
-  std::vector<folly::NotificationQueue<Event>> queues_;
-  std::atomic<RunState> state_;
-  std::unique_ptr<std::thread> thread_;
-  folly::Promise<folly::Unit> promise_;
-};
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/common.sh treadmill/scripts/common.sh
--- treadmill-src/scripts/common.sh	2025-08-11 17:04:00.490028360 -0700
+++ treadmill/scripts/common.sh	2025-08-04 15:44:21.753016891 -0700
@@ -1,5 +1,3 @@
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
-# shellcheck disable=SC2148
 set -ex

 function die { printf "%s: %s\n" "$0" "$@"; exit 1; }
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/get_and_build_everything.sh treadmill/scripts/get_and_build_everything.sh
--- treadmill-src/scripts/get_and_build_everything.sh	2025-08-11 17:04:00.490302405 -0700
+++ treadmill/scripts/get_and_build_everything.sh	2025-08-04 15:44:21.753636338 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 set -ex

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/install_ubuntu_14.04.sh treadmill/scripts/install_ubuntu_14.04.sh
--- treadmill-src/scripts/install_ubuntu_14.04.sh	2025-08-11 17:04:00.490593135 -0700
+++ treadmill/scripts/install_ubuntu_14.04.sh	2025-08-04 15:44:21.754074992 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 set -ex

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/order_ubuntu-14.04/10_folly treadmill/scripts/order_ubuntu-14.04/10_folly
--- treadmill-src/scripts/order_ubuntu-14.04/10_folly	2025-08-11 17:04:00.492937491 -0700
+++ treadmill/scripts/order_ubuntu-14.04/10_folly	2025-08-04 15:44:21.754651803 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/order_ubuntu-14.04/20_wangle treadmill/scripts/order_ubuntu-14.04/20_wangle
--- treadmill-src/scripts/order_ubuntu-14.04/20_wangle	2025-08-11 17:04:00.493987048 -0700
+++ treadmill/scripts/order_ubuntu-14.04/20_wangle	2025-08-04 15:44:21.755198230 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/order_ubuntu-14.04/30_mstch treadmill/scripts/order_ubuntu-14.04/30_mstch
--- treadmill-src/scripts/order_ubuntu-14.04/30_mstch	2025-08-11 17:04:00.493416545 -0700
+++ treadmill/scripts/order_ubuntu-14.04/30_mstch	2025-08-04 15:44:21.755890337 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/order_ubuntu-14.04/40_zstd treadmill/scripts/order_ubuntu-14.04/40_zstd
--- treadmill-src/scripts/order_ubuntu-14.04/40_zstd	2025-08-11 17:04:00.494478812 -0700
+++ treadmill/scripts/order_ubuntu-14.04/40_zstd	2025-08-04 15:44:21.756384293 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/order_ubuntu-14.04/50_fbthrift treadmill/scripts/order_ubuntu-14.04/50_fbthrift
--- treadmill-src/scripts/order_ubuntu-14.04/50_fbthrift	2025-08-11 17:04:00.492588052 -0700
+++ treadmill/scripts/order_ubuntu-14.04/50_fbthrift	2025-08-04 15:44:21.757073867 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/order_ubuntu-14.04/60_mcrouter treadmill/scripts/order_ubuntu-14.04/60_mcrouter
--- treadmill-src/scripts/order_ubuntu-14.04/60_mcrouter	2025-08-11 17:04:00.493142671 -0700
+++ treadmill/scripts/order_ubuntu-14.04/60_mcrouter	2025-08-04 15:44:21.757712733 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/order_ubuntu-14.04/70_treadmill treadmill/scripts/order_ubuntu-14.04/70_treadmill
--- treadmill-src/scripts/order_ubuntu-14.04/70_treadmill	2025-08-11 17:04:00.493739934 -0700
+++ treadmill/scripts/order_ubuntu-14.04/70_treadmill	2025-08-04 15:44:21.758265699 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/recipes/fbthrift.sh treadmill/scripts/recipes/fbthrift.sh
--- treadmill-src/scripts/recipes/fbthrift.sh	2025-08-11 17:04:00.492588052 -0700
+++ treadmill/scripts/recipes/fbthrift.sh	2025-08-04 15:44:21.758747577 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/recipes/folly.sh treadmill/scripts/recipes/folly.sh
--- treadmill-src/scripts/recipes/folly.sh	2025-08-11 17:04:00.492937491 -0700
+++ treadmill/scripts/recipes/folly.sh	2025-08-04 15:44:21.759364320 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/recipes/mcrouter.sh treadmill/scripts/recipes/mcrouter.sh
--- treadmill-src/scripts/recipes/mcrouter.sh	2025-08-11 17:04:00.493142671 -0700
+++ treadmill/scripts/recipes/mcrouter.sh	2025-08-04 15:44:21.759905458 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/recipes/mstch.sh treadmill/scripts/recipes/mstch.sh
--- treadmill-src/scripts/recipes/mstch.sh	2025-08-11 17:04:00.493416545 -0700
+++ treadmill/scripts/recipes/mstch.sh	2025-08-04 15:44:21.760542562 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/recipes/treadmill.sh treadmill/scripts/recipes/treadmill.sh
--- treadmill-src/scripts/recipes/treadmill.sh	2025-08-11 17:04:00.493739934 -0700
+++ treadmill/scripts/recipes/treadmill.sh	2025-08-04 15:44:21.761082278 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/recipes/wangle.sh treadmill/scripts/recipes/wangle.sh
--- treadmill-src/scripts/recipes/wangle.sh	2025-08-11 17:04:00.493987048 -0700
+++ treadmill/scripts/recipes/wangle.sh	2025-08-04 15:44:21.761625489 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/scripts/recipes/zstd.sh treadmill/scripts/recipes/zstd.sh
--- treadmill-src/scripts/recipes/zstd.sh	2025-08-11 17:04:00.494478812 -0700
+++ treadmill/scripts/recipes/zstd.sh	2025-08-04 15:44:21.762229662 -0700
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

 source common.sh

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/adsim/AdSimClientFactory.cpp treadmill/services/adsim/AdSimClientFactory.cpp
--- treadmill-src/services/adsim/AdSimClientFactory.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/adsim/AdSimClientFactory.cpp	2025-08-11 16:59:36.547132714 -0700
@@ -0,0 +1,266 @@
+#include "AdSimClientFactory.h"
+
+#include <fizz/backend/libaegis/LibAEGIS.h>
+#include <fizz/client/AsyncFizzClient.h>
+#include <fizz/client/MultiClientExtensions.h>
+#include <folly/futures/Future.h>
+#include <folly/io/async/AsyncSocket.h>
+#include <glog/logging.h>
+#include <thrift/lib/cpp2/security/extensions/ThriftParametersClientExtension.h>
+
+DEFINE_bool(
+    use_stop_tls,
+    false,
+    "Use stop TLS mode (transition to plaintext) instead of full TLS encryption");
+
+DEFINE_bool(
+    use_aegis_encryption,
+    false,
+    "Enable AEGIS cipher suites on the server side");
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+namespace {
+
+class AdSimConnection
+    : public folly::AsyncSocket::ConnectCallback,
+      public fizz::client::AsyncFizzClient::HandshakeCallback {
+ public:
+  void connectSuccess() noexcept override {
+    LOG(INFO) << "AdSimClient: Connection established.";
+  }
+
+  void connectErr(const folly::AsyncSocketException& ex) noexcept override {
+    LOG(ERROR) << "AdSimClient: Connection failed: " << ex.what();
+  }
+
+  void fizzHandshakeSuccess(
+      fizz::client::AsyncFizzClient* client) noexcept override {
+    printHandshakeSuccess(client);
+  }
+
+  void fizzHandshakeError(
+      fizz::client::AsyncFizzClient* /* unused */,
+      folly::exception_wrapper ex) noexcept override {
+    LOG(ERROR) << "AdSimClient: Handshake error: " << ex.what();
+  }
+
+ private:
+  void printHandshakeSuccess(fizz::client::AsyncFizzClient* client) {
+    auto& state = client->getState();
+    auto serverCert = state.serverCert();
+    auto clientCert = state.clientCert();
+
+    VLOG(1) << "AdSimClient: Handshake succeeded.";
+    VLOG(1) << "  TLS Version: " << fizz::toString(*state.version());
+
+    // Enhanced cipher suite logging
+    auto cipherSuite = state.cipher();
+    VLOG(1) << "  Cipher Suite: " << fizz::toString(*cipherSuite);
+
+    // Check if this is an AEGIS cipher suite
+    if (*cipherSuite == fizz::CipherSuite::TLS_AEGIS_256_SHA512 ||
+        *cipherSuite == fizz::CipherSuite::TLS_AEGIS_128L_SHA256) {
+      VLOG(1) << "  AEGIS Encryption: ENABLED - Using "
+              << fizz::toString(*cipherSuite);
+    } else {
+      VLOG(1) << "  AEGIS Encryption: DISABLED - Using standard cipher "
+              << fizz::toString(*cipherSuite);
+    }
+
+    VLOG(1) << "  Named Group: "
+            << (state.group() ? fizz::toString(*state.group()) : "(none)");
+    VLOG(1) << "  Signature Scheme: "
+            << (state.sigScheme() ? fizz::toString(*state.sigScheme())
+                                  : "(none)");
+    VLOG(1) << "  PSK: " << fizz::toString(*state.pskType());
+    VLOG(1) << "  PSK Mode: "
+            << (state.pskMode() ? fizz::toString(*state.pskMode()) : "(none)");
+    VLOG(1) << "  Key Exchange Type: "
+            << fizz::toString(*state.keyExchangeType());
+    VLOG(1) << "  Early: " << fizz::toString(*state.earlyDataType());
+    VLOG(1) << "  Server Identity: "
+            << (serverCert ? serverCert->getIdentity() : "(none)");
+    VLOG(1) << "  Client Identity: "
+            << (clientCert ? clientCert->getIdentity() : "(none)");
+    VLOG(1) << "  Server Certificate Compression: "
+            << (state.serverCertCompAlgo()
+                    ? fizz::toString(*state.serverCertCompAlgo())
+                    : "(none)");
+    VLOG(1) << "  ALPN: " << state.alpn().value_or("(none)");
+
+    if (client->getClientRandom()) {
+      VLOG(1) << "  Client Random: "
+              << folly::hexlify(*client->getClientRandom());
+    }
+  }
+};
+
+class StopTLSConnector
+    : public fizz::client::AsyncFizzClient::HandshakeCallback,
+      public fizz::AsyncFizzBase::EndOfTLSCallback {
+ public:
+  explicit StopTLSConnector(const ClientConnectionConfig& config)
+      : config_(config) {}
+
+  folly::AsyncSocket::UniquePtr connect(folly::EventBase* evb) {
+    eb_ = evb;
+
+    auto sock = folly::AsyncSocket::newSocket(eb_, config_.serverAddress);
+    auto ctx = AdSimClientFactory::createFizzContext();
+
+    auto thriftParametersContext =
+        std::make_shared<apache::thrift::ThriftParametersContext>();
+    thriftParametersContext->setUseStopTLS(true);
+    auto extension =
+        std::make_shared<apache::thrift::ThriftParametersClientExtension>(
+            thriftParametersContext);
+
+    client_.reset(new fizz::client::AsyncFizzClient(
+        std::move(sock), std::move(ctx), std::move(extension)));
+    client_->connect(
+        this,
+        nullptr,
+        folly::none,
+        folly::none,
+        folly::none,
+        config_.connectTimeout);
+    return promise_.getFuture().getVia(eb_);
+  }
+
+  void fizzHandshakeSuccess(
+      fizz::client::AsyncFizzClient* client) noexcept override {
+    client->setEndOfTLSCallback(this);
+  }
+
+  void fizzHandshakeError(
+      fizz::client::AsyncFizzClient* /* unused */,
+      folly::exception_wrapper ex) noexcept override {
+    promise_.setException(ex);
+    LOG(ERROR) << "Fizz handshake failed: " << ex.what();
+  }
+
+  void endOfTLS(fizz::AsyncFizzBase* transport, std::unique_ptr<folly::IOBuf>)
+      override {
+    auto sock = transport->getUnderlyingTransport<folly::AsyncSocket>();
+    DCHECK(sock);
+
+    auto fd = sock->detachNetworkSocket();
+    auto zcId = sock->getZeroCopyBufId();
+
+    // Create new plaintext socket
+    auto plaintextTransport =
+        folly::AsyncSocket::UniquePtr(new folly::AsyncSocket(eb_, fd, zcId));
+    promise_.setValue(std::move(plaintextTransport));
+  }
+
+ private:
+  ClientConnectionConfig config_;
+  fizz::client::AsyncFizzClient::UniquePtr client_;
+  folly::Promise<folly::AsyncSocket::UniquePtr> promise_;
+  folly::EventBase* eb_;
+};
+
+} // anonymous namespace
+
+/* static */ folly::AsyncTransport::UniquePtr
+AdSimClientFactory::createTransport(
+    folly::EventBase* evb,
+    const ClientConnectionConfig& config) {
+  switch (config.tlsMode) {
+    case TLSMode::FULL_TLS:
+      return createFullTLSTransport(evb, config);
+    case TLSMode::STOP_TLS:
+      return createStopTLSTransport(evb, config);
+  }
+  LOG(FATAL) << "Unknown TLS mode";
+}
+
+/* static */ folly::AsyncTransport::UniquePtr
+AdSimClientFactory::createTransport(
+    folly::EventBase* evb,
+    const folly::SocketAddress& serverAddress) {
+  ClientConnectionConfig config;
+  config.serverAddress = serverAddress;
+  config.tlsMode = FLAGS_use_stop_tls ? TLSMode::STOP_TLS : TLSMode::FULL_TLS;
+  return createTransport(evb, config);
+}
+
+/* static */ folly::AsyncTransport::UniquePtr
+AdSimClientFactory::createFullTLSTransport(
+    folly::EventBase* evb,
+    const ClientConnectionConfig& config) {
+  auto ctx = createFizzContext();
+
+  // Configure ThriftParameters to disable stop TLS
+  auto thriftParametersContext =
+      std::make_shared<apache::thrift::ThriftParametersContext>();
+  thriftParametersContext->setUseStopTLS(false);
+  auto extension =
+      std::make_shared<apache::thrift::ThriftParametersClientExtension>(
+          thriftParametersContext);
+
+  std::vector<std::shared_ptr<fizz::ClientExtensions>> extensions;
+  extensions.push_back(extension);
+
+  // Create socket first
+  auto sock = folly::AsyncSocket::newSocket(evb, config.serverAddress);
+
+  // Create Fizz client with the socket
+  auto fizzClient = fizz::client::AsyncFizzClient::UniquePtr(
+      new fizz::client::AsyncFizzClient(
+          std::move(sock),
+          ctx,
+          std::make_shared<fizz::client::MultiClientExtensions>(
+              std::move(extensions))));
+
+  // Connect with handshake callback to print cipher information
+  fizzClient->connect(
+      new AdSimConnection(),
+      nullptr, // verifier
+      folly::none, // sni
+      folly::none, // pskIdentity
+      folly::none); // echConfigs
+
+  return std::move(fizzClient);
+}
+
+/* static */ folly::AsyncTransport::UniquePtr
+AdSimClientFactory::createStopTLSTransport(
+    folly::EventBase* evb,
+    const ClientConnectionConfig& config) {
+  StopTLSConnector connector(config);
+  auto transport = connector.connect(evb);
+  // Convert AsyncSocket::UniquePtr to AsyncTransport::UniquePtr
+  return folly::AsyncTransport::UniquePtr(transport.release());
+}
+
+/* static */ std::shared_ptr<fizz::client::FizzClientContext>
+AdSimClientFactory::createFizzContext() {
+  auto ctx = std::make_shared<fizz::client::FizzClientContext>();
+  ctx->setSupportedAlpns({"rs"});
+
+  // Enable AEGIS cipher suites
+  if (FLAGS_use_aegis_encryption) {
+#if FIZZ_HAVE_LIBAEGIS
+    // Override with only AEGIS cipher suites
+    std::vector<fizz::CipherSuite> ciphers = {
+        fizz::CipherSuite::TLS_AEGIS_256_SHA512,
+        fizz::CipherSuite::TLS_AEGIS_128L_SHA256};
+
+    ctx->setSupportedCiphers(ciphers);
+#else
+    LOG(WARNING)
+        << "AdSimClient: AEGIS requested but FIZZ_HAVE_LIBAEGIS not enabled";
+#endif
+  } else {
+    LOG(INFO)
+        << "AdSimClient: AEGIS Encryption DISABLED - Using default ciphers";
+  }
+  return ctx;
+}
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/adsim/AdSimClientFactory.h treadmill/services/adsim/AdSimClientFactory.h
--- treadmill-src/services/adsim/AdSimClientFactory.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/adsim/AdSimClientFactory.h	2025-08-05 12:14:50.543995512 -0700
@@ -0,0 +1,72 @@
+#pragma once
+
+#include <fizz/client/AsyncFizzClient.h>
+#include <fizz/client/MultiClientExtensions.h>
+#include <folly/io/async/AsyncTransport.h>
+#include <folly/io/async/EventBase.h>
+#include <gflags/gflags.h>
+#include <thrift/lib/cpp2/security/extensions/ThriftParametersClientExtension.h>
+
+DECLARE_bool(use_stop_tls);
+DECLARE_bool(use_aegis_encryption);
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+enum class TLSMode {
+  FULL_TLS, // Continuous TLS encryption (no stop TLS)
+  STOP_TLS // Traditional stop TLS (transition to plaintext)
+};
+
+struct ClientConnectionConfig {
+  folly::SocketAddress serverAddress;
+  TLSMode tlsMode = TLSMode::FULL_TLS;
+  std::chrono::milliseconds connectTimeout{100};
+};
+
+/**
+ * Factory class for creating different types of TLS connectors.
+ * Provides a clean interface to create either full TLS or stop TLS connectors
+ * based on configuration parameters.
+ */
+class AdSimClientFactory {
+ public:
+  /**
+   * Create a transport connection based on the specified configuration.
+   *
+   * @param evb EventBase for the connection
+   * @param config Connection configuration including TLS mode
+   * @return AsyncTransport::UniquePtr that can be used with RocketClientChannel
+   */
+  static folly::AsyncTransport::UniquePtr createTransport(
+      folly::EventBase* evb,
+      const ClientConnectionConfig& config);
+
+  /**
+   * Create a transport connection using global flags for configuration.
+   * This is a convenience method that reads from FLAGS_use_stop_tls.
+   *
+   * @param evb EventBase for the connection
+   * @param serverAddress Server address to connect to
+   * @return AsyncTransport::UniquePtr that can be used with RocketClientChannel
+   */
+  static folly::AsyncTransport::UniquePtr createTransport(
+      folly::EventBase* evb,
+      const folly::SocketAddress& serverAddress);
+
+  static std::shared_ptr<fizz::client::FizzClientContext> createFizzContext();
+
+ private:
+  static folly::AsyncTransport::UniquePtr createFullTLSTransport(
+      folly::EventBase* evb,
+      const ClientConnectionConfig& config);
+
+  static folly::AsyncTransport::UniquePtr createStopTLSTransport(
+      folly::EventBase* evb,
+      const ClientConnectionConfig& config);
+};
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/adsim/AdSimService.h treadmill/services/adsim/AdSimService.h
--- treadmill-src/services/adsim/AdSimService.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/adsim/AdSimService.h	2025-08-04 15:44:21.764339323 -0700
@@ -0,0 +1,18 @@
+#pragma once
+
+#include <folly/Unit.h>
+#include "Request.h"
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+class AdSimService {
+ public:
+  using Request = AdSimServiceRequest;
+  using Reply = folly::Unit;
+};
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/adsim/AdSimServiceRequestFactory.cpp treadmill/services/adsim/AdSimServiceRequestFactory.cpp
--- treadmill-src/services/adsim/AdSimServiceRequestFactory.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/adsim/AdSimServiceRequestFactory.cpp	2025-08-04 15:44:21.764858056 -0700
@@ -0,0 +1,92 @@
+// (c) Facebook, Inc. and its affiliates. Confidential and proprietary.
+
+#include <folly/Random.h>
+#include <folly/Singleton.h>
+#include <folly/executors/CPUThreadPoolExecutor.h>
+#include <folly/executors/thread_factory/NamedThreadFactory.h>
+#include <glog/logging.h>
+
+#include <algorithm>
+#include <mutex>
+#include <random>
+#include <sstream>
+#include <vector>
+
+#include "AdSimServiceRequestFactory.h"
+
+namespace facebook::windtunnel::treadmill {
+
+static std::string gen_string(const uint64_t len) {
+  std::string tmp;
+  static const char alphabet[] =
+      "0123456789 ,.!:'\"@#$%&*"
+      "ABCEDFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz";
+  std::random_device rd;
+  std::default_random_engine rng(rd());
+  std::uniform_int_distribution<> dist(
+      0, sizeof(alphabet) / sizeof(*alphabet) - 2);
+  tmp.reserve(len);
+  std::generate_n(
+      std::back_inserter(tmp), len, [&]() { return alphabet[dist(rng)]; });
+  return tmp;
+}
+
+folly::Singleton<AdSimServiceRequestFactory> singleton;
+
+AdSimServiceRequestFactory::AdSimServiceRequestFactory() : ready_(false) {}
+
+// static
+std::shared_ptr<AdSimServiceRequestFactory> AdSimServiceRequestFactory::get() {
+  auto ptr = singleton.try_get();
+  if (ptr == nullptr) {
+    throw std::runtime_error(
+        "Error loading AdSimServiceRequestFactory from singleton");
+  }
+  return ptr;
+}
+
+bool AdSimServiceRequestFactory::isReady() {
+  return ready_;
+}
+
+bool AdSimServiceRequestFactory::tryLock() {
+  return lock_.try_lock();
+}
+
+void AdSimServiceRequestFactory::unLock() {
+  lock_.unlock();
+}
+
+void AdSimServiceRequestFactory::prepareRequests(const std::string& req_size) {
+  DLOG(INFO) << "Generating template requests for AdSim Service";
+
+  std::vector<uint64_t> sizes;
+  std::stringstream ss(req_size);
+  for (uint64_t i; ss >> i;) {
+    sizes.push_back(i);
+    if (',' == ss.peek()) {
+      ss.ignore();
+    }
+  }
+
+  AdSimRequests_.resize(sizes.size());
+  auto pool = std::make_shared<folly::CPUThreadPoolExecutor>(
+      32, std::make_shared<folly::NamedThreadFactory>("PopulateRequests"));
+  std::vector<folly::Future<bool>> futures;
+  for (int64_t i = sizes.size() - 1; i >= 0; i--) {
+    futures.push_back(folly::via(pool.get(), [&, i]() {
+      AdSimRequests_[i].request() = gen_string(sizes[i]);
+      return true;
+    }));
+  }
+  auto fs = folly::collect(std::move(futures)).get();
+
+  ready_ = true;
+}
+
+const facebook::cea::chips::adsim::AdSimRequest&
+AdSimServiceRequestFactory::getRequest() const {
+  return AdSimRequests_[folly::Random::rand32(AdSimRequests_.size())];
+}
+
+} // namespace facebook::windtunnel::treadmill
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/adsim/AdSimServiceRequestFactory.h treadmill/services/adsim/AdSimServiceRequestFactory.h
--- treadmill-src/services/adsim/AdSimServiceRequestFactory.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/adsim/AdSimServiceRequestFactory.h	2025-08-04 15:44:21.765308078 -0700
@@ -0,0 +1,36 @@
+// (c) Facebook, Inc. and its affiliates. Confidential and proprietary.
+
+#pragma once
+
+#include <gen-cpp2/AdSim.h>
+
+#include <mutex>
+#include <vector>
+
+namespace facebook::windtunnel::treadmill {
+
+class AdSimServiceRequestFactory {
+ public:
+  explicit AdSimServiceRequestFactory();
+
+  static std::shared_ptr<AdSimServiceRequestFactory> get();
+
+  bool isReady();
+
+  bool tryLock();
+
+  void unLock();
+
+  void prepareRequests(const std::string& req_size);
+
+  const facebook::cea::chips::adsim::AdSimRequest& getRequest() const;
+
+ private:
+  std::vector<facebook::cea::chips::adsim::AdSimRequest> AdSimRequests_;
+
+  std::mutex lock_;
+
+  bool ready_;
+};
+
+} // namespace facebook::windtunnel::treadmill
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/adsim/CMakeLists.txt treadmill/services/adsim/CMakeLists.txt
--- treadmill-src/services/adsim/CMakeLists.txt	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/adsim/CMakeLists.txt	2025-08-04 15:44:21.765829926 -0700
@@ -0,0 +1,52 @@
+# Define the treadmill_adsim executable
+add_executable(treadmill_adsim
+    Treadmill.cpp
+    AdSimServiceRequestFactory.cpp
+    AdSimClientFactory.cpp
+)
+
+# Set include directories for treadmill_adsim
+target_include_directories(treadmill_adsim PRIVATE
+    ${CMAKE_CURRENT_SOURCE_DIR}/../../../adsim/if
+    ${CMAKE_SOURCE_DIR}  # Add the root directory to include path
+)
+
+# Link treadmill_adsim with required libraries
+target_link_libraries(treadmill_adsim
+    PRIVATE
+    treadmill
+    ${CMAKE_CURRENT_SOURCE_DIR}/../../../adsim/build/if/libAdSim-cpp2.a
+    ${CMAKE_CURRENT_SOURCE_DIR}/../../../adsim/build/if/libfb303-cpp2.a
+    ${CMAKE_CURRENT_SOURCE_DIR}/../../../adsim/build/if/libSerialize-cpp2.a
+    ${FOLLY_LIBRARIES}
+    ${FBTHRIFT_LIBRARIES}
+    ${FB303_LIBRARIES}
+    ${FIZZ_LIBRARIES}
+    ${WANGLE_LIBRARIES}
+    ${FMT_LIBRARIES}
+    Boost::filesystem
+    Boost::system
+    Boost::thread
+    Boost::context
+    Threads::Threads
+    ZLIB::ZLIB
+    ${BZIP2_LIBRARIES}
+    ${LZ4_LIBRARY}
+    ${ZSTD_LIBRARY}
+    ${SNAPPY_LIBRARY}
+    ${LIBLZMA_LIBRARIES}
+    ${OPENSSL_LIBRARIES}
+    ${GLOG_LIBRARIES}
+    ${GFLAGS_LIBRARIES}
+    ${DOUBLE_CONVERSION_LIBRARY}
+    ${XXHASH_LIBRARIES}
+    numa
+    dl
+    sodium
+    unwind
+)
+
+# Install target
+install(TARGETS treadmill_adsim
+    RUNTIME DESTINATION bin
+)
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/adsim/Connection.h treadmill/services/adsim/Connection.h
--- treadmill-src/services/adsim/Connection.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/adsim/Connection.h	2025-08-04 15:44:21.766304054 -0700
@@ -0,0 +1,79 @@
+#pragma once
+
+#include <folly/futures/Future.h>
+#include <folly/io/async/EventBase.h>
+#include <gen-cpp2/AdSim.h>
+#include <gflags/gflags.h>
+#include <thrift/lib/cpp2/async/RocketClientChannel.h>
+#include <thrift/lib/cpp2/security/extensions/ThriftParametersClientExtension.h>
+
+#include <fstream>
+#include <iostream>
+
+#include "src/Connection.h"
+#include "src/Treadmill.h"
+
+#include "AdSimClientFactory.h"
+#include "AdSimService.h"
+#include "AdSimServiceRequestFactory.h"
+
+DEFINE_string(transport, "rocket", "Transport to use: header, rocket");
+DEFINE_string(req_size, "5", "A list of request sizes, separated by comma");
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+using apache::thrift::RocketClientChannel;
+using facebook::cea::chips::adsim::AdSimAsyncClient;
+using facebook::cea::chips::adsim::AdSimResponse;
+
+template <>
+class Connection<AdSimService> {
+  // This class is responsible for actually executing the requests against the
+  // service, and acquiring the responses.
+
+ public:
+  explicit Connection<AdSimService>(folly::EventBase& eventBase)
+      : eventBase_(eventBase) {
+    // Create a thrift client using the new AdSimClientFactory
+    auto addr = folly::SocketAddress(FLAGS_hostname, FLAGS_port);
+    auto transport = AdSimClientFactory::createTransport(&eventBase_, addr);
+    client_ = std::make_shared<AdSimAsyncClient>(
+        RocketClientChannel::newChannel(std::move(transport)));
+    requestFactory_ = AdSimServiceRequestFactory::get();
+    if (!requestFactory_->isReady() && requestFactory_->tryLock()) {
+      requestFactory_->prepareRequests(FLAGS_req_size);
+      requestFactory_->unLock();
+    }
+  }
+
+  bool isReady() {
+    return true;
+  }
+
+  // reset connections, called by treadmill worker. see treadmill/Connection.h
+  // for more details.
+  void reset() {}
+
+  folly::Future<AdSimService::Reply> sendRequest(
+      std::unique_ptr<AdSimService::Request> request) {
+    return co_sendRequestImpl(std::move(request)).semi().via(&eventBase_);
+  }
+
+ private:
+  folly::coro::Task<AdSimService::Reply> co_sendRequestImpl(
+      std::unique_ptr<AdSimService::Request> request) {
+    while (!requestFactory_->isReady()) {
+      co_await folly::futures::sleep(std::chrono::seconds{1});
+    }
+    co_await client_->co_sim(requestFactory_->getRequest());
+    co_return AdSimService::Reply{};
+  }
+  folly::EventBase& eventBase_;
+  std::shared_ptr<AdSimAsyncClient> client_;
+  std::shared_ptr<AdSimServiceRequestFactory> requestFactory_;
+};
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/adsim/Request.h treadmill/services/adsim/Request.h
--- treadmill-src/services/adsim/Request.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/adsim/Request.h	2025-08-04 15:44:21.766804620 -0700
@@ -0,0 +1,20 @@
+#pragma once
+
+#include <chrono>
+
+#include "src/Request.h"
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+// TODO (T63730434): for now, this request is just a wrapper around an integer,
+// so we can test how to get treadmill working. we'll add WH-specific stuff
+// later.
+class AdSimServiceRequest : public Request {
+public:
+  explicit AdSimServiceRequest() {}
+};
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/adsim/Treadmill.cpp treadmill/services/adsim/Treadmill.cpp
--- treadmill-src/services/adsim/Treadmill.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/adsim/Treadmill.cpp	2025-08-04 15:44:21.767327751 -0700
@@ -0,0 +1,12 @@
+#include "Connection.h"
+#include "Workload.h"
+
+#include "src/Treadmill.h"
+
+int main(int argc, char *argv[]) {
+  // Init treadmill
+  facebook::windtunnel::treadmill::init(argc, argv);
+  // Start treadmill
+  return facebook::windtunnel::treadmill::run<
+      facebook::windtunnel::treadmill::AdSimService>(argc, argv);
+}
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/adsim/Workload.h treadmill/services/adsim/Workload.h
--- treadmill-src/services/adsim/Workload.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/adsim/Workload.h	2025-08-04 15:44:21.767800667 -0700
@@ -0,0 +1,49 @@
+#pragma once
+
+#include <folly/Unit.h>
+#include <folly/dynamic.h>
+#include <folly/futures/Future.h>
+
+#include "AdSimService.h"
+
+#include "src/Workload.h"
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+template <>
+class Workload<AdSimService> : public WorkloadBase<Workload<AdSimService>> {
+  // This class is responsible for generating requests to send through the
+  // Connection.
+public:
+  explicit Workload<AdSimService>(folly::dynamic /*config*/)
+      : _current_value(0) {}
+
+  void reset() { this->_current_value = 0; }
+
+  std::tuple<std::unique_ptr<AdSimService::Request>,
+             folly::Promise<AdSimService::Reply>,
+             folly::Future<AdSimService::Reply>>
+  getNextRequest() {
+    // Returns the next request to submit, along with a promise/future pair for
+    // the Connection class to insert the response into.
+    auto request = std::make_unique<AdSimService::Request>();
+    auto promise = folly::Promise<AdSimService::Reply>();
+    auto future = promise.getFuture();
+
+    return std::make_tuple(std::move(request), std::move(promise),
+                           std::move(future));
+  }
+
+  folly::dynamic
+  makeConfigOutputs(std::vector<Workload<AdSimService> *> /*workloads*/) {
+    return folly::dynamic::object();
+  }
+
+private:
+  int _current_value;
+};
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/libmcrouter/Connection.h treadmill/services/libmcrouter/Connection.h
--- treadmill-src/services/libmcrouter/Connection.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/libmcrouter/Connection.h	2025-08-04 15:44:21.768546113 -0700
@@ -0,0 +1,92 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <folly/MoveWrapper.h>
+
+#include "memcache/client/Constants.h"
+#include "memcache/client/MC.h"
+#include "treadmill/Connection.h"
+#include "treadmill/services/libmcrouter/LibmcrouterService.h"
+
+DECLARE_string(libmcrouter_flavor);
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+template <>
+class Connection<LibmcrouterService> {
+ public:
+  explicit Connection(folly::EventBase& eventBase) {
+    facebook::memcache::MC::Options extraOptions;
+    if (FLAGS_libmcrouter_flavor == "no-network") {
+      extraOptions["no_network"] = "1";
+      extraOptions["num_proxies"] = "1";
+    }
+    auto connection = facebook::memcache::MC::getInstance(determineFlavor())
+      .createInternalConnection(extraOptions);
+    cc_ = std::make_unique<facebook::memcache::MemcacheClientString>(
+      std::move(connection), eventBase);
+  }
+
+  bool isReady() const { return true; }
+
+  folly::Future<LibmcrouterService::Reply>
+  sendRequest(std::unique_ptr<LibmcrouterService::Request> request) {
+    return std::move(*boost::apply_visitor(RequestTypeVisitor(*cc_), *request));
+  }
+
+ private:
+  std::unique_ptr<facebook::memcache::MemcacheClientString> cc_;
+
+  facebook::memcache::constants::McrouterFlavors determineFlavor() {
+    if (FLAGS_libmcrouter_flavor == "web") {
+      return facebook::memcache::constants::McrouterFlavors::WEB;
+    } else if (FLAGS_libmcrouter_flavor == "no-network" ||
+               FLAGS_libmcrouter_flavor == "perf") {
+      return facebook::memcache::constants::McrouterFlavors::PERF;
+    } else {
+      LOG(WARNING) << "Unsupported flavor, using 'perf'!";
+      return facebook::memcache::constants::McrouterFlavors::PERF;
+    }
+  }
+
+  class RequestTypeVisitor : public boost::static_visitor<
+      folly::MoveWrapper<folly::Future<LibmcrouterService::Reply>>> {
+   public:
+    explicit RequestTypeVisitor(facebook::memcache::MemcacheClientString& cc)
+      : cc_(cc) {
+    }
+
+    result_type operator()(
+        facebook::memcache::MemcacheClientString::UpdateRequests& requests)
+        const {
+      return folly::makeMoveWrapper(cc_.multiSetFuture(requests).then([](
+          folly::Try<facebook::memcache::MemcacheClientString::UpdateResults>&&
+              t) { return LibmcrouterService::Reply(std::move(t.value())); }));
+    }
+
+    result_type operator()(
+        facebook::memcache::MemcacheClientString::GetRequests& requests) const {
+      return folly::makeMoveWrapper(cc_.multiGetFuture(requests).then([](
+          folly::Try<facebook::memcache::MemcacheClientString::GetResults>&&
+              t) { return LibmcrouterService::Reply(std::move(t.value())); }));
+    }
+
+   private:
+    const facebook::memcache::MemcacheClientString& cc_;
+  };
+};
+
+}  // namespace treadmill
+}  // namespace windtunnel
+}  // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/libmcrouter/LibmcrouterService.h treadmill/services/libmcrouter/LibmcrouterService.h
--- treadmill-src/services/libmcrouter/LibmcrouterService.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/libmcrouter/LibmcrouterService.h	2025-08-04 15:44:21.769099621 -0700
@@ -0,0 +1,41 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include "boost/variant.hpp"
+#include "memcache/client/MemcacheClientString.h"
+
+DEFINE_string(libmcrouter_flavor,
+              "perf",
+              "The flavor of libmcrouter to use.");
+
+DEFINE_string(libmcrouter_keys_prefix,
+              "windtunnel.treadmill.libmcrouter.testKey",
+              "Will be used as a prefix for keys.");
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+class LibmcrouterService {
+ public:
+  typedef boost::variant<
+      facebook::memcache::MemcacheClientString::UpdateRequests,
+      facebook::memcache::MemcacheClientString::GetRequests> Request;
+
+  typedef boost::variant<
+      facebook::memcache::MemcacheClientString::UpdateResults,
+      facebook::memcache::MemcacheClientString::GetResults> Reply;
+};
+
+}  // namespace treadmill
+}  // namespace windtunnel
+}  // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/libmcrouter/Treadmill.cpp treadmill/services/libmcrouter/Treadmill.cpp
--- treadmill-src/services/libmcrouter/Treadmill.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/libmcrouter/Treadmill.cpp	2025-08-04 15:44:21.769496941 -0700
@@ -0,0 +1,24 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#include <gflags/gflags.h>
+
+#include "treadmill/services/libmcrouter/Connection.h"
+#include "treadmill/services/libmcrouter/Workload.h"
+
+#include "treadmill/Treadmill.h"
+
+int main(int argc, char* argv[]) {
+  // Init treadmill
+  facebook::windtunnel::treadmill::init(argc, argv);
+  // Start treadmill
+  return facebook::windtunnel::treadmill::run<
+    facebook::windtunnel::treadmill::LibmcrouterService>(argc, argv);
+}
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/libmcrouter/Workload.h treadmill/services/libmcrouter/Workload.h
--- treadmill-src/services/libmcrouter/Workload.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/libmcrouter/Workload.h	2025-08-04 15:44:21.769979752 -0700
@@ -0,0 +1,98 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <folly/futures/Future.h>
+
+#include <mcrouter/lib/cycles/Cycles.h>
+
+#include "treadmill/StatisticsManager.h"
+#include "treadmill/Workload.h"
+
+DECLARE_int64(number_of_keys);
+DECLARE_string(libmcrouter_keys_prefix);
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+template <>
+class Workload<LibmcrouterService> {
+ public:
+  enum class State {
+    WARMUP,
+    GETS
+  };
+
+  explicit Workload(folly::dynamic config)
+    : state_(State::WARMUP),
+      index_(0) {
+    cycles_statistic_ = &StatisticsManager::get()
+      .getContinuousStat("cpu_cycles");
+    facebook::memcache::cycles::startExtracting(
+        [this](facebook::memcache::cycles::CycleStats stats) {
+          if (stats.numSamples > 0) {
+            cycles_statistic_->addSample(stats.avg);
+          }
+        }
+    );
+  }
+
+  std::tuple<std::unique_ptr<LibmcrouterService::Request>,
+             folly::Promise<LibmcrouterService::Reply>,
+             folly::Future<LibmcrouterService::Reply>>
+  getNextRequest() {
+    if (index_ == FLAGS_number_of_keys) {
+      index_ = 0;
+    }
+
+    sprintf(buffer, "%s%d", FLAGS_libmcrouter_keys_prefix.c_str(), index_);
+    std::string key = buffer;
+
+    std::unique_ptr<LibmcrouterService::Request> request;
+    if (state_ == State::WARMUP) {
+      sprintf(buffer, "Value:%d.%s", index_,
+              FLAGS_libmcrouter_keys_prefix.c_str());
+      std::string value = buffer;
+      request = std::make_unique<LibmcrouterService::Request>(
+        facebook::memcache::MemcacheClientString::UpdateRequests(
+          {{std::move(key), std::move(value)}}));
+
+      if (index_ == FLAGS_number_of_keys - 1) {
+        LOG(INFO) << "WARMUP complete";
+        state_ = State::GETS;
+      }
+    } else if (state_ == State::GETS) {
+      request = std::make_unique<LibmcrouterService::Request>(
+          facebook::memcache::MemcacheClientString::GetRequests(
+              {{std::move(key)}}));
+    }
+    folly::Promise<LibmcrouterService::Reply> p;
+    auto f = p.getFuture();
+    ++index_;
+    return std::make_tuple(std::move(request), std::move(p), std::move(f));
+  }
+
+  folly::dynamic makeConfigOutputs(
+                  std::vector<Workload<LibmcrouterService>*> workloads) {
+    return folly::dynamic::object;
+  }
+
+ private:
+  State state_;
+  int index_;
+  char buffer[250];
+  ContinuousStatistic* cycles_statistic_{nullptr};
+};
+
+}  // namespace treadmill
+}  // namespace windtunnel
+}  // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/memcached/Connection.h treadmill/services/memcached/Connection.h
--- treadmill-src/services/memcached/Connection.h	2025-08-11 17:04:00.495361136 -0700
+++ treadmill/services/memcached/Connection.h	2025-08-04 15:44:21.770593079 -0700
@@ -14,8 +14,8 @@
 #include <folly/fibers/EventBaseLoopController.h>
 #include <folly/fibers/FiberManager.h>
 #include <folly/futures/Future.h>
-#include <folly/io/IOBuf.h>
 #include <folly/io/async/EventBase.h>
+#include <folly/io/IOBuf.h>
 #include <mcrouter/lib/network/AsyncMcClient.h>
 #include <mcrouter/lib/network/gen/Memcache.h>

@@ -32,6 +32,7 @@
 using facebook::memcache::McDeleteRequest;
 using facebook::memcache::McGetRequest;
 using facebook::memcache::McSetRequest;
+using facebook::memcache::McOperation;
 using folly::fibers::EventBaseLoopController;
 using folly::fibers::FiberManager;

@@ -51,12 +52,10 @@
     fm_ = std::make_unique<FiberManager>(std::move(loopController));
   }

-  bool isReady() const {
-    return true;
-  }
+  bool isReady() const { return true; }

-  folly::Future<MemcachedService::Reply> sendRequest(
-      std::unique_ptr<typename MemcachedService::Request> request) {
+  folly::Future<MemcachedService::Reply>
+  sendRequest(std::unique_ptr<typename MemcachedService::Request> request) {
     folly::MoveWrapper<folly::Promise<MemcachedService::Reply>> p;
     auto f = p->getFuture();

@@ -68,8 +67,7 @@
       });
     } else if (request->which() == MemcachedRequest::SET) {
       auto req = std::make_shared<McSetRequest>(request->key());
-      req->value_ref() =
-          folly::IOBuf(folly::IOBuf::COPY_BUFFER, request->value());
+      req->value() = folly::IOBuf(folly::IOBuf::COPY_BUFFER, request->value());
       fm_->addTask([this, req, p]() mutable {
         client_->sendSync(*req, std::chrono::milliseconds::zero());
         p->setValue(MemcachedService::Reply());
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/memcached/Makefile.am treadmill/services/memcached/Makefile.am
--- treadmill-src/services/memcached/Makefile.am	2025-08-11 17:04:00.495691426 -0700
+++ treadmill/services/memcached/Makefile.am	1969-12-31 16:00:00.000000000 -0800
@@ -1,14 +0,0 @@
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
-bin_PROGRAMS = treadmill_memcached
-
-AM_CPPFLAGS = -I$(top_srcdir)/..
-
-treadmill_memcached_SOURCES = \
-  Connection.h \
-  MemcachedService.h \
-  Request.h \
-  Workload.h \
-  Treadmill.cpp
-
-treadmill_memcached_LDADD = \
-  $(top_builddir)/libtreadmill.a
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/memcached/Request.h treadmill/services/memcached/Request.h
--- treadmill-src/services/memcached/Request.h	2025-08-11 17:04:00.496082878 -0700
+++ treadmill/services/memcached/Request.h	2025-08-04 15:44:21.771623357 -0700
@@ -20,14 +20,20 @@

 class Request;

-class MemcachedReply {};
+class MemcachedReply {
+};

 class MemcachedRequest : public Request {
  public:
-  enum Operation { GET, SET, DELETE };
+  enum Operation {
+    GET,
+    SET,
+    DELETE
+  };

   MemcachedRequest(Operation type, std::string key)
-      : type_(type), key_(std::move(key)) {}
+    : type_(type),
+      key_(std::move(key)) { }

   virtual ~MemcachedRequest() {}

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/memcached/Workload.h treadmill/services/memcached/Workload.h
--- treadmill-src/services/memcached/Workload.h	2025-08-11 17:04:00.496628794 -0700
+++ treadmill/services/memcached/Workload.h	2025-08-04 15:44:21.772313881 -0700
@@ -26,20 +26,18 @@
 namespace treadmill {

 template <>
-class Workload<MemcachedService>
-    : public WorkloadBase<Workload<MemcachedService>> {
+class Workload<MemcachedService> {
  public:
-  enum State { WARMUP, GET };
-
-  Workload<MemcachedService>(folly::dynamic /*config*/)
-      : state_(State::WARMUP), index_(0) {}
+  enum State {
+    WARMUP,
+    GET
+  };

-  void reset() {
-    index_ = 0;
-  }
+  Workload<MemcachedService>(folly::dynamic config)
+    : state_(State::WARMUP),
+      index_(0) { }

-  std::tuple<
-      std::unique_ptr<MemcachedService::Request>,
+  std::tuple<std::unique_ptr<MemcachedService::Request>,
       Promise<MemcachedService::Reply>,
       Future<MemcachedService::Reply>>
   getNextRequest() {
@@ -51,16 +49,16 @@

     std::unique_ptr<MemcachedService::Request> request;
     if (state_ == State::WARMUP) {
-      request = std::make_unique<MemcachedRequest>(
-          MemcachedRequest::SET, std::move(key));
+      request = std::make_unique<MemcachedRequest>(MemcachedRequest::SET,
+                                                     std::move(key));
       request->setValue(std::to_string(index_));
       if (index_ == FLAGS_number_of_keys - 1) {
         LOG(INFO) << "WARMUP complete";
         state_ = State::GET;
       }
     } else if (state_ == State::GET) {
-      request = std::make_unique<MemcachedRequest>(
-          MemcachedRequest::GET, std::move(key));
+      request = std::make_unique<MemcachedRequest>(MemcachedRequest::GET,
+                                                     std::move(key));
     }
     Promise<MemcachedService::Reply> p;
     auto f = p.getFuture();
@@ -69,7 +67,7 @@
   }

   folly::dynamic makeConfigOutputs(
-      std::vector<Workload<MemcachedService>*> /*workloads*/) {
+                  std::vector<Workload<MemcachedService>*> workloads) {
     return folly::dynamic::object;
   }

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/CMakeLists.txt treadmill/services/sleep/CMakeLists.txt
--- treadmill-src/services/sleep/CMakeLists.txt	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/services/sleep/CMakeLists.txt	2025-08-04 15:44:21.772959938 -0700
@@ -0,0 +1,90 @@
+# Only build if the option is enabled
+if(BUILD_TREADMILL_SLEEP)
+    # Define the treadmill_sleep executable
+    add_executable(treadmill_sleep
+        Treadmill.cpp
+        gen-cpp2/sleep_constants.cpp
+        gen-cpp2/sleep_data.cpp
+        gen-cpp2/sleep_metadata.cpp
+        gen-cpp2/sleep_types.cpp
+        gen-cpp2/sleep_types_compact.cpp
+        gen-cpp2/sleep_types_binary.cpp
+        gen-cpp2/Sleep.cpp
+        gen-cpp2/SleepAsyncClient.cpp
+        gen-cpp2/Sleep_processmap_binary.cpp
+        gen-cpp2/Sleep_processmap_compact.cpp
+    )
+
+    # Add dependencies to ensure Thrift files are generated before building
+    add_dependencies(treadmill_sleep thrift_gen)
+
+    # Set include directories for treadmill_sleep
+    target_include_directories(treadmill_sleep PRIVATE
+        ${CMAKE_SOURCE_DIR}  # Add the root directory to include path
+    )
+
+    # Link treadmill_sleep with required libraries
+    target_link_libraries(treadmill_sleep
+        PRIVATE
+        treadmill
+        ${FOLLY_LIBRARIES}
+        ${FBTHRIFT_LIBRARIES}
+        ${FB303_LIBRARIES}
+        ${FIZZ_LIBRARIES}
+        ${WANGLE_LIBRARIES}
+        ${FMT_LIBRARIES}
+        Boost::filesystem
+        Boost::system
+        Boost::thread
+        Boost::context
+        Threads::Threads
+        ZLIB::ZLIB
+        ${BZIP2_LIBRARIES}
+        ${LZ4_LIBRARY}
+        ${ZSTD_LIBRARY}
+        ${SNAPPY_LIBRARY}
+        ${LIBLZMA_LIBRARIES}
+        ${OPENSSL_LIBRARIES}
+        ${GLOG_LIBRARIES}
+        ${GFLAGS_LIBRARIES}
+        ${DOUBLE_CONVERSION_LIBRARY}
+        ${XXHASH_LIBRARIES}
+        numa
+        dl
+        sodium
+        unwind
+    )
+
+    # Install target
+    install(TARGETS treadmill_sleep
+        RUNTIME DESTINATION bin
+    )
+endif()
+
+# Custom command to generate Thrift files
+add_custom_command(
+    OUTPUT
+        ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/Sleep.h
+        ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/sleep_constants.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/sleep_data.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/sleep_metadata.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/sleep_types.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/sleep_types_compact.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/sleep_types_binary.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/Sleep.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/SleepAsyncClient.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/Sleep_processmap_binary.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/Sleep_processmap_compact.cpp
+    COMMAND PYTHONPATH=${ADSIM_STAGING_DIR}/bin/..:$ENV{PYTHONPATH} ${THRIFT_EXECUTABLE} --gen mstch_cpp2
+            -I ${CMAKE_SOURCE_DIR}
+            -I ${ADSIM_STAGING_DIR}/include/thrift-files
+            -o ${CMAKE_CURRENT_SOURCE_DIR}/
+            ${CMAKE_CURRENT_SOURCE_DIR}/sleep.thrift
+    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/sleep.thrift
+    COMMENT "Generating Thrift files for sleep service"
+)
+
+# Add custom target for Thrift generation
+add_custom_target(thrift_gen DEPENDS
+    ${CMAKE_CURRENT_SOURCE_DIR}/gen-cpp2/Sleep.h
+)
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/Connection.h treadmill/services/sleep/Connection.h
--- treadmill-src/services/sleep/Connection.h	2025-08-11 17:04:00.497080097 -0700
+++ treadmill/services/sleep/Connection.h	2025-08-04 15:44:21.773604332 -0700
@@ -14,12 +14,12 @@
 #include "treadmill/services/sleep/SleepService.h"

 #include "treadmill/Connection.h"
-#include "treadmill/StatisticsManager.h"
 #include "treadmill/Util.h"
+#include "treadmill/StatisticsManager.h"

+#include "treadmill/services/sleep/gen-cpp2/Sleep.h"
 #include <folly/io/async/AsyncSocket.h>
 #include <thrift/lib/cpp2/async/HeaderClientChannel.h>
-#include "treadmill/services/sleep/gen-cpp2/Sleep.h"

 DECLARE_string(hostname);
 DECLARE_int32(port);
@@ -31,33 +31,30 @@
 template <>
 class Connection<SleepService> {
  public:
-  Connection<SleepService>(folly::EventBase& event_base)
-      : histo_(StatisticsManager::get()->getContinuousStat("SleepTime")) {
+  Connection<SleepService>(folly::EventBase& event_base) {
     std::string host = nsLookUp(FLAGS_hostname);
     auto socket = folly::AsyncSocket::newSocket(&event_base, host, FLAGS_port);
-    auto channel =
-        apache::thrift::HeaderClientChannel::newChannel(std::move(socket));
+    auto channel = apache::thrift::HeaderClientChannel::newChannel(std::move(socket));

-    client_ =
-        std::make_unique<services::sleep::SleepAsyncClient>(std::move(channel));
+    client_ = std::make_unique<services::sleep::SleepAsyncClient>(
+                std::move(channel));
   }

-  bool isReady() const {
-    return true;
-  }
+  bool isReady() const { return true; }

-  folly::Future<SleepService::Reply> sendRequest(
-      std::unique_ptr<typename SleepService::Request> request) {
-    auto f = client_->future_goSleep(request->sleep_time())
-                 .thenTry([histo = histo_](folly::Try<int64_t>&& t) mutable {
-                   histo->addValue(t.value());
+  folly::Future<SleepService::Reply>
+  sendRequest(std::unique_ptr<typename SleepService::Request> request) {
+    auto f = client_->future_goSleep(request->sleep_time()).then(
+      [](folly::Try<int64_t>&& t) mutable {
+        StatisticsManager::get().getContinuousStat("SleepTime")
+          .addSample(t.value());
                    return SleepReply(t.value());
-                 });
+      }
+    );
     return f;
   }

  private:
-  std::shared_ptr<StatisticsManager::Histogram> histo_;
   std::unique_ptr<services::sleep::SleepAsyncClient> client_;
 };

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/Makefile.am treadmill/services/sleep/Makefile.am
--- treadmill-src/services/sleep/Makefile.am	2025-08-11 17:04:00.497375624 -0700
+++ treadmill/services/sleep/Makefile.am	1969-12-31 16:00:00.000000000 -0800
@@ -1,14 +0,0 @@
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
-bin_PROGRAMS = treadmill_sleep
-
-AM_CPPFLAGS = -I$(top_srcdir)/..
-
-treadmill_sleep_SOURCES = \
-  Connection.h \
-	Request.h \
-  SleepService.h \
-  Workload.h \
-  Treadmill.cpp
-
-treadmill_sleep_LDADD = \
-  $(top_builddir)/libtreadmill.a
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/Request.h treadmill/services/sleep/Request.h
--- treadmill-src/services/sleep/Request.h	2025-08-11 17:04:00.497665272 -0700
+++ treadmill/services/sleep/Request.h	2025-08-04 15:44:21.774661481 -0700
@@ -22,7 +22,8 @@

 class SleepReply {
  public:
-  explicit SleepReply(int64_t sleep_time) : sleep_time_(sleep_time) {}
+  explicit SleepReply(int64_t sleep_time)
+    : sleep_time_(sleep_time) { }

   int64_t sleep_time() {
     return sleep_time_;
@@ -34,10 +35,13 @@

 class SleepRequest : public Request {
  public:
-  enum Operation { SLEEP };
+  enum Operation {
+    SLEEP
+  };

   SleepRequest(Operation type, int64_t sleep_time)
-      : type_(type), sleep_time_(sleep_time) {}
+    : type_(type),
+      sleep_time_(sleep_time) { }

   virtual ~SleepRequest() {}

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/sleepserver/SleepClient.cpp treadmill/services/sleep/sleepserver/SleepClient.cpp
--- treadmill-src/services/sleep/sleepserver/SleepClient.cpp	2025-08-11 17:04:00.499808954 -0700
+++ treadmill/services/sleep/sleepserver/SleepClient.cpp	2025-08-04 15:44:21.775216200 -0700
@@ -10,32 +10,36 @@

 #include <gflags/gflags.h>

-#include <folly/io/async/AsyncSocket.h>
-#include <thrift/lib/cpp2/async/HeaderClientChannel.h>
 #include "treadmill/services/sleep/gen-cpp2/Sleep.h"
+#include <thrift/lib/cpp2/async/HeaderClientChannel.h>

 using namespace folly;
 using namespace apache::thrift;
+using namespace apache::thrift::async;
 using namespace facebook::windtunnel::treadmill::services::sleep;

-DEFINE_int32(port, 12345, "Port for sleep service (default: 12345).");
+DEFINE_int32(port,
+             12345,
+             "Port for sleep service (default: 12345).");

-DEFINE_string(
-    hostname,
+DEFINE_string(hostname,
     "127.0.0.1",
     "Hostname of the server (default: localhost).");

-DEFINE_int32(sleep_time, 1000, "The sleep time to send (default: 1000).");
+DEFINE_int32(sleep_time,
+             1000,
+             "The sleep time to send (default: 1000).");

 int main(int argc, char* argv[]) {
   google::InitGoogleLogging(argv[0]);
-  gflags::ParseCommandLineFlags(&argc, &argv, true);
+  google::ParseCommandLineFlags(&argc, &argv, true);

   EventBase event_base;

-  auto socket = AsyncSocket::newSocket(&event_base, FLAGS_hostname, FLAGS_port);
+  std::shared_ptr<TAsyncSocket> socket(
+      TAsyncSocket::newSocket(&event_base, FLAGS_hostname, FLAGS_port));

-  SleepAsyncClient client(HeaderClientChannel::newChannel(std::move(socket)));
+  SleepAsyncClient client(HeaderClientChannel::newChannel(socket));

   auto sleep_time = client.future_goSleep(FLAGS_sleep_time).getVia(&event_base);
   LOG(INFO) << "Slept for " << sleep_time << " microseconds.";
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/sleepserver/SleepHandler.cpp treadmill/services/sleep/sleepserver/SleepHandler.cpp
--- treadmill-src/services/sleep/sleepserver/SleepHandler.cpp	2025-08-11 17:04:00.500169280 -0700
+++ treadmill/services/sleep/sleepserver/SleepHandler.cpp	2025-08-04 15:44:21.775777679 -0700
@@ -35,8 +35,7 @@

   folly::RequestEventBase::get()->runInEventBaseThread(
       [promise, time]() mutable {
-        struct timeval start_time, end_time, diff_time;
-        ;
+        struct timeval start_time, end_time, diff_time;;
         gettimeofday(&start_time, nullptr);
         usleep(time);
         gettimeofday(&end_time, nullptr);
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/sleepserver/SleepHandler.h treadmill/services/sleep/sleepserver/SleepHandler.h
--- treadmill-src/services/sleep/sleepserver/SleepHandler.h	2025-08-11 17:04:00.500578689 -0700
+++ treadmill/services/sleep/sleepserver/SleepHandler.h	2025-08-04 15:44:21.776345477 -0700
@@ -10,7 +10,6 @@

 #pragma once

-#include "common/fb303/cpp/FacebookBase2.h"
 #include "treadmill/services/sleep/gen-cpp2/Sleep.h"

 namespace facebook {
@@ -23,21 +22,16 @@
  * A simple thrift server which has only one method that tells the server to
  * sleep for the amount of time embedded in the received request
  */
-class SleepHandler : public SleepSvIf, virtual public fb303::FacebookBase2 {
+class SleepHandler : public SleepSvIf {
  public:
-  SleepHandler() : fb303::FacebookBase2("Sleep") {}
-
-  fb303::cpp2::fb_status getStatus() override {
-    return fb303::cpp2::fb_status::ALIVE;
-  }
-
+  SleepHandler() { }
   /**
    * Asynchronous function to handle goSleep request
    *
    * @param time The time to sleep in microseconds
    * @return Future to the actual time spent in sleep in microseconds
    */
-  folly::Future<int64_t> future_goSleep(int64_t time) override;
+  folly::Future<int64_t> future_goSleep(int64_t time);
 };

 } // namespace sleep
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/sleepserver/SleepServer.cpp treadmill/services/sleep/sleepserver/SleepServer.cpp
--- treadmill-src/services/sleep/sleepserver/SleepServer.cpp	2025-08-11 17:04:00.500847134 -0700
+++ treadmill/services/sleep/sleepserver/SleepServer.cpp	2025-08-04 15:44:21.776850601 -0700
@@ -8,24 +8,29 @@
  *
  */

-#include <gflags/gflags.h>
 #include <memory>
+#include <gflags/gflags.h>

 #include <thrift/lib/cpp2/server/ThriftServer.h>

 #include "treadmill/services/sleep/sleepserver/SleepHandler.h"

 using namespace apache::thrift;
+using namespace apache::thrift::async;

 using namespace facebook::windtunnel::treadmill::services::sleep;

-DEFINE_int32(port, 12345, "Port for sleep service (default: 12345).");
+DEFINE_int32(port,
+             12345,
+             "Port for sleep service (default: 12345).");

-DEFINE_int32(num_workers, 4, "Number of workers (default: 4).");
+DEFINE_int32(num_workers,
+             4,
+             "Number of workers (default: 4).");

 int main(int argc, char* argv[]) {
   google::InitGoogleLogging(argv[0]);
-  gflags::ParseCommandLineFlags(&argc, &argv, true);
+  google::ParseCommandLineFlags(&argc, &argv, true);

   auto handler = std::make_shared<SleepHandler>();
   auto server = std::make_unique<ThriftServer>();
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/SleepService.h treadmill/services/sleep/SleepService.h
--- treadmill-src/services/sleep/SleepService.h	2025-08-11 17:04:00.498079158 -0700
+++ treadmill/services/sleep/SleepService.h	2025-08-04 15:44:21.777384508 -0700
@@ -12,8 +12,7 @@

 #include "treadmill/services/sleep/Request.h"

-DEFINE_int64(
-    sleep_time,
+DEFINE_int64(sleep_time,
     1000,
     "Requested microseconds to sleep for (default:1000)");

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/sleep.thrift treadmill/services/sleep/sleep.thrift
--- treadmill-src/services/sleep/sleep.thrift	2025-08-11 17:04:00.499318183 -0700
+++ treadmill/services/sleep/sleep.thrift	2025-08-04 15:44:21.777864934 -0700
@@ -1,8 +1,5 @@
-# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
-include "common/fb303/if/fb303.thrift"
-
 namespace cpp2 facebook.windtunnel.treadmill.services.sleep

-service Sleep extends fb303.FacebookService {
-  i64 goSleep(1: i64 time);
+service Sleep {
+  i64 goSleep(1: i64 time)
 }
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/Treadmill.cpp treadmill/services/sleep/Treadmill.cpp
--- treadmill-src/services/sleep/Treadmill.cpp	2025-08-11 17:04:00.498619345 -0700
+++ treadmill/services/sleep/Treadmill.cpp	2025-08-04 15:44:21.778469709 -0700
@@ -8,6 +8,8 @@
  *
  */

+#include <gflags/gflags.h>
+
 #include "treadmill/services/sleep/Connection.h"
 #include "treadmill/services/sleep/Workload.h"

diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/services/sleep/Workload.h treadmill/services/sleep/Workload.h
--- treadmill-src/services/sleep/Workload.h	2025-08-11 17:04:00.499062645 -0700
+++ treadmill/services/sleep/Workload.h	2025-08-04 15:44:21.779016326 -0700
@@ -23,26 +23,24 @@
 namespace treadmill {

 template <>
-class Workload<SleepService> : public WorkloadBase<Workload<SleepService>> {
+class Workload<SleepService> {
  public:
-  Workload<SleepService>(folly::dynamic /*config*/) {}
-
-  void reset() {}
+  Workload<SleepService>(folly::dynamic config) {}

-  std::tuple<
-      std::unique_ptr<SleepService::Request>,
+  std::tuple<std::unique_ptr<SleepService::Request>,
       folly::Promise<SleepService::Reply>,
       folly::Future<SleepService::Reply>>
   getNextRequest() {
-    std::unique_ptr<SleepService::Request> request =
-        std::make_unique<SleepRequest>(SleepRequest::SLEEP, FLAGS_sleep_time);
+    std::unique_ptr<SleepService::Request> request
+      = std::make_unique<SleepRequest>(SleepRequest::SLEEP,
+                                         FLAGS_sleep_time);
     folly::Promise<SleepService::Reply> p;
     auto f = p.getFuture();
     return std::make_tuple(std::move(request), std::move(p), std::move(f));
   }

   folly::dynamic makeConfigOutputs(
-      std::vector<Workload<SleepService>*> /*workloads*/) {
+                        std::vector<Workload<SleepService>*> workloads) {
     return folly::dynamic::object;
   }
 };
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/CMakeLists.txt treadmill/src/CMakeLists.txt
--- treadmill-src/src/CMakeLists.txt	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/CMakeLists.txt	2025-08-04 15:44:21.779678988 -0700
@@ -0,0 +1,46 @@
+# Define the treadmill library
+add_library(treadmill STATIC
+    Histogram.cpp
+    RandomEngine.cpp
+    Scheduler.cpp
+    Treadmill.cpp
+    ContinuousStatistic.cpp
+    CounterStatistic.cpp
+    StatisticsManager.cpp
+    Util.cpp
+)
+
+# Add header files to the library for better IDE integration
+target_sources(treadmill PRIVATE
+    Connection.h
+    Histogram.h
+    Request.h
+    RandomEngine.h
+    Scheduler.h
+    Statistic.h
+    ContinuousStatistic.h
+    CounterStatistic.h
+    StatisticsManager.h
+    Treadmill.h
+    Util.h
+    Worker.h
+    Workload.h
+)
+
+# Set include directories for the library
+target_include_directories(treadmill PUBLIC
+    ${CMAKE_SOURCE_DIR}
+)
+
+# Link with required libraries
+target_link_libraries(treadmill PUBLIC
+    ${FOLLY_LIBRARIES}
+    ${FBTHRIFT_LIBRARIES}
+    ${FB303_LIBRARIES}
+    Boost::filesystem
+    Boost::system
+    Boost::thread
+    Boost::context
+    ${GLOG_LIBRARIES}
+    ${GFLAGS_LIBRARIES}
+)
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Connection.h treadmill/src/Connection.h
--- treadmill-src/src/Connection.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Connection.h	2025-08-04 15:44:21.780211633 -0700
@@ -0,0 +1,59 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <folly/Memory.h>
+
+DECLARE_string(counter_name);
+DECLARE_int32(counter_threshold);
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+/**
+ * Specializations of this template should implement:
+ *
+ * bool isReady();
+ *
+ * folly::Future<Service::Reply>
+ * sendRequest(std::unique_ptr<typename Service::Request>&& request);
+ *
+ * */
+template <class Service>
+class Connection {
+public:
+/**
+ * Sample implementation below shows how to wait for a specific counter
+ * value to cross a threshold
+ * e.g. usage: --wait_for_target_ready --counter_threshold 10
+ * --counter_name thrift.accepted_connections.count
+ * */
+
+  bool isReady() const {
+    if(!FLAGS_counter_name.empty()) {
+      int64_t value = client_->sync_getCounter(FLAGS_counter_name);
+      if(value < FLAGS_counter_threshold) {
+        LOG(INFO) << "Threshold: "
+          << FLAGS_counter_threshold << " Counter: "
+          << FLAGS_counter_name << " Value: " << value;
+        return false;
+      }
+    }
+    return true;
+  }
+private:
+  std::unique_ptr<typename Service::Client> client_;
+};
+
+}  // namespace treadmill
+}  // namespace windtunnel
+}  // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/ContinuousStatistic.cpp treadmill/src/ContinuousStatistic.cpp
--- treadmill-src/src/ContinuousStatistic.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/ContinuousStatistic.cpp	2025-08-04 15:44:21.780916158 -0700
@@ -0,0 +1,314 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#include "ContinuousStatistic.h"
+
+#include "RandomEngine.h"
+#include "Util.h"
+
+#include <cmath>
+#include <mutex>
+#include <unordered_map>
+
+#include <glog/logging.h>
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+const std::map<double, const std::string> kQuantiles = {
+    {0.01, "p01"}, {0.05, "p05"}, {0.10, "p10"}, {0.15, "p15"},
+    {0.20, "p20"}, {0.50, "p50"}, {0.80, "p80"}, {0.85, "p85"},
+    {0.90, "p90"}, {0.95, "p95"}, {0.99, "p99"}};
+
+/**
+ * Orchestrates synchronization of histogram inputs so all threads have
+ * the same bins in their histogram. A thread passes in |proposed| and if
+ * it the first thread to propose a set of inputs it will be used from
+ * then on. The function returns a set of inputs that should be used
+ * regardless.
+ *
+ */
+HistogramInput synchronizeGlobalHistogramRange(std::string name,
+                                               const HistogramInput &proposed) {
+  static std::mutex global_mutex;
+  static std::unordered_map<std::string, HistogramInput> proto_histogram_inputs;
+  std::lock_guard<std::mutex> lock(global_mutex);
+
+  HistogramInput accepted = proposed;
+  auto it = proto_histogram_inputs.find(name);
+  if (it == proto_histogram_inputs.end()) {
+    proto_histogram_inputs[name] = proposed;
+  } else {
+    accepted = it->second;
+  }
+
+  return accepted;
+}
+
+void ContinuousStatistic::rebinHistogram(double target_max_value) {
+  double min_value = this->histogram_->getMinBin();
+  double max_value = this->histogram_->getMaxBin();
+
+  double new_max_value = 0.0;
+  if (target_max_value < 0.0) {
+    double max_exceptional = 0;
+    for (int i = 0; i < exceptional_index_; i++) {
+      max_exceptional = std::max(max_exceptional, exceptional_values_[i]);
+    }
+    double pow = std::log2(max_exceptional);
+    new_max_value = std::pow(2, ceil(pow));
+  } else {
+    new_max_value = target_max_value;
+  }
+
+  HistogramInput input(kNumberOfBins, min_value, new_max_value);
+  std::unique_ptr<Histogram> new_histogram(new Histogram(input));
+  new_histogram->insertSmallerHistogramSamples(this->histogram_);
+
+  for (int i = 0; i < exceptional_index_; i++) {
+    new_histogram->addSample(exceptional_values_[i]);
+  }
+  exceptional_index_ = 0;
+  this->histogram_.swap(new_histogram);
+}
+
+void ContinuousStatistic::setHistogramBins() {
+  double min_value = 0.0;
+  double max_value = 1.0;
+  if (!calibrationSamples_.empty()) {
+    min_value = *std::min_element(calibrationSamples_.begin(),
+                                  calibrationSamples_.end());
+    max_value = *std::max_element(calibrationSamples_.begin(),
+                                  calibrationSamples_.end());
+  }
+  HistogramInput input(kNumberOfBins, min_value / 2.0, max_value * 2.0);
+  HistogramInput acceptedHistogram =
+      synchronizeGlobalHistogramRange(this->getName(), input);
+  histogram_.reset(new Histogram(acceptedHistogram));
+}
+
+/**
+ * Add a sample to statistic
+ *
+ * @param value
+ */
+void ContinuousStatistic::addSample(double value) {
+  if (histogram_ == nullptr) {
+    if (warmupSamples_ < nWarmupSamples_) {
+      warmupSamples_++;
+      return;
+    }
+    if (calibrationSamples_.size() < nCalibrationSamples_) {
+      calibrationSamples_.push_back(value);
+      return;
+    }
+    if (calibrationSamples_.size() == nCalibrationSamples_) {
+      this->setHistogramBins();
+      // Set all stats back to 0 after calibration
+      s0_ = 0;
+      s1_ = 0.0;
+      s2_ = 0.0;
+      a_ = 0.0;
+      q_ = 0.0;
+      min_ = 0.0;
+      max_ = 0.0;
+      minSet_ = false;
+      maxSet_ = false;
+    }
+  }
+  if (value > this->histogram_->getMaxBin()) {
+    exceptional_values_[exceptional_index_] = value;
+    exceptional_index_++;
+    if (exceptional_index_ == kExceptionalValues) {
+      this->rebinHistogram();
+    }
+  } else {
+    histogram_->addSample(value);
+  }
+  s0_ += 1.0;
+  s1_ += value;
+  s2_ += (value * value);
+  double tempA = a_;
+  a_ = a_ + (value - a_) / s0_;
+  q_ = q_ + (value - tempA) * (value - a_);
+  if (minSet_) {
+    min_ = std::min(min_, value);
+  } else {
+    min_ = value;
+    minSet_ = true;
+  }
+  if (maxSet_) {
+    max_ = std::max(max_, value);
+  } else {
+    max_ = value;
+    maxSet_ = true;
+  }
+}
+
+double ContinuousStatistic::getAverage() const {
+  if (s0_ == 0) {
+    return 0;
+  }
+  return s1_ / (double)s0_;
+}
+
+double ContinuousStatistic::getStdDev() const {
+  if (s0_ == 0) {
+    return 0;
+  }
+  return sqrt(q_ / (s0_ - 1.0));
+}
+
+double ContinuousStatistic::getCV() const {
+  return this->getStdDev() / this->getAverage();
+}
+
+/**
+ * Estimate a quantile
+ *
+ * @param quantile
+ */
+double ContinuousStatistic::getQuantile(double quantile) {
+  return histogram_->getQuantile(quantile);
+}
+
+double ContinuousStatistic::meanConfidence() const {
+  double z = 1.96;
+  double e = z * this->getStdDev() / sqrt(this->s0_);
+  return e;
+}
+
+double ContinuousStatistic::quantileConfidence(double quantile) const {
+  int nResamples = 100;
+  ContinuousStatistic estimateStatistic("");
+  for (int i = 0; i < nResamples; i++) {
+    ContinuousStatistic resampled("");
+    for (int j = 0; j < this->s0_; j++) {
+      double randQuantile = RandomEngine::getDouble();
+      double sample = this->histogram_->getQuantile(randQuantile);
+      resampled.addSample(sample);
+    }
+    estimateStatistic.addSample(resampled.getAverage());
+  }
+  return estimateStatistic.meanConfidence();
+}
+
+/**
+ * Print out all the statistic
+ */
+void ContinuousStatistic::printStatistic() const {
+  if (!histogram_) {
+    LOG(INFO) << "Did not collect enough samples";
+    return;
+  }
+  LOG(INFO) << "N Samples: " << s0_;
+  LOG(INFO) << "Average: " << this->getAverage() << " +/- " << meanConfidence();
+  LOG(INFO) << "Std. Dev.: " << this->getStdDev();
+  LOG(INFO) << "Cv.: " << this->getCV();
+  LOG(INFO) << "Min: " << this->min_;
+  LOG(INFO) << "Max: " << this->max_;
+  for (auto p : kQuantiles) {
+    LOG(INFO) << p.second
+              << " Percentile: " << this->histogram_->getQuantile(p.first);
+    //            << " +/- " << quantileConfidence(p.first);
+  }
+  LOG(INFO) << "Min Bin " << histogram_->getMinBin();
+  LOG(INFO) << "Max Bin " << histogram_->getMaxBin();
+}
+
+folly::dynamic ContinuousStatistic::toDynamic() const {
+  folly::dynamic map = folly::dynamic::object;
+  map["n_samples"] = this->s0_;
+  map["average"] = this->getAverage();
+  map["std_dev"] = this->getStdDev();
+  if (this->histogram_) {
+    for (const auto &p : kQuantiles) {
+      map[p.second] = this->histogram_->getQuantile(p.first);
+    }
+    map["histogram"] = this->histogram_->toDynamic();
+  }
+  return map;
+}
+
+std::unordered_map<std::string, int64_t>
+ContinuousStatistic::getCounters() const {
+  std::unordered_map<std::string, int64_t> m;
+  m[name_ + ".count"] = s0_;
+  m[name_ + ".avg"] = getAverage();
+  m[name_ + ".stddev"] = getStdDev();
+  if (this->histogram_) {
+    for (const auto &p : kQuantiles) {
+      m[name_ + '.' + p.second] = histogram_->getQuantile(p.first);
+    }
+  }
+  return m;
+}
+
+void ContinuousStatistic::combine(const Statistic &stat0) {
+  const ContinuousStatistic &stat =
+      dynamic_cast<const ContinuousStatistic &>(stat0);
+
+  // Leveraging this:
+  // http://en.wikipedia.org/wiki/
+  // Algorithms_for_calculating_variance#Parallel_algorithm
+  if (s0_ + stat.s0_ > 0) {
+    if (s0_ <= 0.0) {
+      this->a_ = stat.s0_;
+      this->q_ = stat.q_;
+    } else if (stat.s0_ <= 0.0) {
+      // no-op
+    } else {
+      double delta = (stat.a_ - a_);
+      double mean = a_ + delta * (stat.s0_ / (s0_ + stat.s0_));
+      this->a_ = mean;
+      this->q_ =
+          q_ + stat.q_ + delta * delta * s0_ * stat.s0_ / (s0_ * stat.s0_);
+    }
+  }
+
+  this->s0_ += stat.s0_;
+  this->s1_ += stat.s1_;
+  this->s2_ += stat.s2_;
+
+  this->min_ =
+      (this->minSet_ == true ? std::min(this->min_, stat.min_) : stat.min_);
+  this->max_ =
+      (this->maxSet_ == true ? std::max(this->max_, stat.max_) : stat.max_);
+  if (stat.histogram_ == nullptr) {
+    return;
+  }
+
+  // Rebin hitogram to make sure all the exceptional values are in the hitogram
+  std::unique_ptr<ContinuousStatistic> stat_to_combine(
+      new ContinuousStatistic(stat));
+  if (stat_to_combine->exceptional_index_ != 0) {
+    stat_to_combine->rebinHistogram();
+  }
+
+  if (this->histogram_ == nullptr) {
+    this->histogram_.reset(new Histogram(*stat_to_combine->histogram_));
+  } else {
+    // Use the larger max_value for the combined histogram
+    double new_max_value = std::max(this->histogram_->getMaxBin(),
+                                    stat_to_combine->histogram_->getMaxBin());
+    if (this->histogram_->getMaxBin() != new_max_value) {
+      this->rebinHistogram(new_max_value);
+    }
+    if (stat_to_combine->histogram_->getMaxBin() != new_max_value) {
+      stat_to_combine->rebinHistogram(new_max_value);
+    }
+    this->histogram_->combine(*stat_to_combine->histogram_);
+  }
+}
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/ContinuousStatistic.h treadmill/src/ContinuousStatistic.h
--- treadmill-src/src/ContinuousStatistic.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/ContinuousStatistic.h	2025-08-04 15:44:21.781377867 -0700
@@ -0,0 +1,128 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <vector>
+
+#include <folly/dynamic.h>
+#include <gflags/gflags.h>
+
+#include "Histogram.h"
+#include "Statistic.h"
+
+DECLARE_int32(default_calibration_samples);
+DECLARE_int32(default_warmup_samples);
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+const int kNumberOfBins = 1024;
+
+const int kExceptionalValues = 1000;
+
+/**
+ * Uses a similar methodology to:
+ * http://web.eecs.umich.edu/~twenisch/papers/ispass12.pdf
+ *
+ */
+class ContinuousStatistic : public Statistic {
+public:
+  ContinuousStatistic(const std::string &name, int nWarmupSamples,
+                      int nCalibrationSamples)
+      : Statistic(name), histogram_(), nWarmupSamples_(nWarmupSamples),
+        warmupSamples_(0), nCalibrationSamples_(nCalibrationSamples), s0_(0),
+        s1_(0.0), s2_(0.0), a_(0.0), q_(0.0), minSet_(false), maxSet_(false),
+        min_(0), max_(0) {}
+
+  ContinuousStatistic(const ContinuousStatistic &s)
+      : Statistic(s.name_), nWarmupSamples_(s.nWarmupSamples_),
+        warmupSamples_(s.warmupSamples_),
+        nCalibrationSamples_(s.nCalibrationSamples_), s0_(s.s0_), s1_(s.s1_),
+        s2_(s.s2_), a_(s.a_), q_(s.q_), minSet_(s.minSet_), maxSet_(s.maxSet_),
+        min_(s.min_), max_(s.max_), exceptional_index_(s.exceptional_index_) {
+    if (s.histogram_ != nullptr) {
+      histogram_.reset(new Histogram(*s.histogram_));
+    }
+    for (int i = 0; i < exceptional_index_; i++) {
+      exceptional_values_[i] = s.exceptional_values_[i];
+    }
+  }
+
+  explicit ContinuousStatistic(const std::string &name)
+      : ContinuousStatistic(name, FLAGS_default_warmup_samples,
+                            FLAGS_default_calibration_samples) {}
+
+  std::unique_ptr<Statistic> clone() const override {
+    return std::unique_ptr<Statistic>(new ContinuousStatistic(*this));
+  }
+
+  /**
+   * Add a sample to the statistic
+   *
+   * @param value
+   */
+  void addSample(double latency);
+
+  double getAverage() const;
+
+  double getStdDev() const;
+
+  double getCV() const;
+
+  /**
+   * Estimate a quantile
+   *
+   * @param quantile
+   */
+  double getQuantile(double quantile);
+
+  /**
+   * Print out all the statistic
+   */
+  void printStatistic() const override;
+
+  folly::dynamic toDynamic() const override;
+
+  std::unordered_map<std::string, int64_t> getCounters() const override;
+
+  void combine(const Statistic &stat) override;
+
+private:
+  void rebinHistogram(double target_max_value = -1.0);
+
+  void setHistogramBins();
+
+  double meanConfidence() const;
+
+  double quantileConfidence(double quantile) const;
+
+  std::unique_ptr<Histogram> histogram_;
+  int nWarmupSamples_;
+  int warmupSamples_;
+  std::vector<double> calibrationSamples_;
+  int nCalibrationSamples_;
+  int s0_;
+  double s1_;
+  double s2_;
+  double a_;
+  double q_;
+  bool minSet_;
+  bool maxSet_;
+  double min_;
+  double max_;
+  double exceptional_values_[kExceptionalValues];
+  int exceptional_index_{0};
+};
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/CounterStatistic.cpp treadmill/src/CounterStatistic.cpp
--- treadmill-src/src/CounterStatistic.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/CounterStatistic.cpp	2025-08-04 15:44:21.781801007 -0700
@@ -0,0 +1,63 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#include "CounterStatistic.h"
+
+#include "Util.h"
+
+#include <mutex>
+#include <unordered_map>
+
+#include <glog/logging.h>
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+/**
+ * Print out all the statistic
+ */
+void CounterStatistic::printStatistic() const {
+  LOG(INFO) << "Count: " << count_;
+  for (const auto &p : subkey_count_) {
+    LOG(INFO) << "Count[" << p.first << "]: " << p.second;
+  }
+}
+
+folly::dynamic CounterStatistic::toDynamic() const {
+  folly::dynamic map = folly::dynamic::object;
+  map["count"] = this->count_;
+  for (const auto &p : subkey_count_) {
+    map[p.first] = p.second;
+  }
+  return map;
+}
+
+std::unordered_map<std::string, int64_t> CounterStatistic::getCounters() const {
+  std::unordered_map<std::string, int64_t> m;
+  m[name_] = count_;
+  for (const auto &p : subkey_count_) {
+    m[name_ + '.' + p.first] = p.second;
+  }
+  return m;
+}
+
+void CounterStatistic::combine(const Statistic &stat0) {
+  const CounterStatistic &stat = dynamic_cast<const CounterStatistic &>(stat0);
+
+  count_ += stat.count_;
+  for (const auto &p : stat.subkey_count_) {
+    subkey_count_[p.first] += p.second;
+  }
+}
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/CounterStatistic.h treadmill/src/CounterStatistic.h
--- treadmill-src/src/CounterStatistic.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/CounterStatistic.h	2025-08-04 15:44:21.782364028 -0700
@@ -0,0 +1,67 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <string>
+#include <unordered_map>
+#include <vector>
+
+#include <folly/dynamic.h>
+
+#include "Statistic.h"
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+class CounterStatistic : public Statistic {
+public:
+  explicit CounterStatistic(const std::string &name) : Statistic(name) {}
+
+  CounterStatistic(const CounterStatistic &other) : Statistic(other.name_) {
+    count_ = other.count_;
+    subkey_count_ = other.subkey_count_;
+  }
+
+  virtual std::unique_ptr<Statistic> clone() const override {
+    return std::unique_ptr<Statistic>(new CounterStatistic(*this));
+  }
+
+  virtual void printStatistic() const override;
+
+  virtual folly::dynamic toDynamic() const override;
+
+  virtual std::unordered_map<std::string, int64_t> getCounters() const override;
+
+  virtual void combine(const Statistic &stat) override;
+
+  void increase(size_t n = 1, const std::string &subkey = "") {
+    count_ += n;
+    if (!subkey.empty()) {
+      subkey_count_[subkey] += n;
+    }
+  }
+
+  size_t getCount() const { return count_; }
+
+  size_t getCount(const std::string &subkey) const {
+    auto it = subkey_count_.find(subkey);
+    return (it == subkey_count_.end()) ? 0 : it->second;
+  }
+
+private:
+  size_t count_ = 0;
+  std::unordered_map<std::string, size_t> subkey_count_;
+};
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Histogram.cpp treadmill/src/Histogram.cpp
--- treadmill-src/src/Histogram.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Histogram.cpp	2025-08-04 15:44:21.782899258 -0700
@@ -0,0 +1,161 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#include "Histogram.h"
+
+#include <glog/logging.h>
+#include <numeric>
+
+using std::vector;
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+/**
+ * Constructor of Histogram
+ *
+ * @param number_of_bins The number of bins in the sample histogram
+ * @param min_value The minimum value of the sample histogram
+ * @param max_value The maximum value of the sample histogram
+ */
+Histogram::Histogram(const int number_of_bins, const double min_value,
+                     const double max_value)
+    : x_values_(vector<double>(number_of_bins)),
+      y_values_(vector<double>(number_of_bins)),
+      cdf_values_(vector<double>(number_of_bins)) {
+  double delta_x = (max_value - min_value) / number_of_bins;
+  for (int i = 0; i < number_of_bins; i++) {
+    x_values_[i] = (i + 1) * delta_x + min_value;
+    y_values_[i] = 0.0;
+    cdf_values_[i] = 0.0;
+  }
+}
+
+/**
+ * Add a sample to the histogram
+ *
+ * @param sample_value The sample value to add
+ */
+void Histogram::addSample(const double sample_value) {
+  int bin_index = Histogram::findClosestBin(x_values_, sample_value);
+  bin_index =
+      (bin_index > y_values_.size() - 1) ? (y_values_.size() - 1) : bin_index;
+  y_values_[bin_index]++;
+}
+
+/**
+ * Get the X value for a quantile from the sample histogram
+ *
+ * @param quantile The quantile to search for
+ * @return The X value of the quantile in the sample histogram
+ */
+double Histogram::getQuantile(const double quantile) {
+  this->updateCdf();
+
+  int bin_index = Histogram::findClosestBin(cdf_values_, quantile);
+  int i = 0;
+  for (auto val : cdf_values_) {
+    i++;
+  }
+  double bottom_x = 0.0;
+  double bottom_y = 0.0;
+  double top_x = cdf_values_[bin_index];
+  double top_y = x_values_[bin_index];
+
+  if (bin_index != 0) {
+    bottom_x = cdf_values_[bin_index - 1];
+    bottom_y = x_values_[bin_index - 1];
+  }
+
+  return Histogram::linearInterpolate(bottom_x, top_x, bottom_y, top_y,
+                                      quantile);
+}
+
+/**
+ * Print out the statistic of the histogram
+ */
+void Histogram::printHistogram() {
+  LOG(INFO) << "50\% Percentile: " << this->getQuantile(0.50);
+  LOG(INFO) << "90\% Percentile: " << this->getQuantile(0.90);
+  LOG(INFO) << "95\% Percentile: " << this->getQuantile(0.95);
+  LOG(INFO) << "99\% Percentile: " << this->getQuantile(0.99);
+}
+
+void Histogram::insertSmallerHistogramSamples(
+    std::unique_ptr<Histogram> &histogram) {
+  for (int i = 0; i < histogram->x_values_.size(); i++) {
+    int idx = this->findClosestBin(x_values_, histogram->x_values_[i]);
+    y_values_[idx] += histogram->y_values_[i];
+  }
+}
+
+/**
+ * Find the first bin that is greater than or equal to searched value
+ *
+ * @param values The vector of values to search in
+ * @param search_value The value to search for
+ * @return The index of the closest bin
+ */
+int Histogram::findClosestBin(const vector<double> &values,
+                              const double search_value) {
+  auto bin_iter = lower_bound(values.begin(), values.end(), search_value);
+  return distance(values.begin(), bin_iter);
+}
+
+/**
+ * Simple linear interpolation
+ *
+ * @param bottom_x Lower bound of X value
+ * @param top_x Upper bound of X value
+ * @param bottom_y Corresponding Y value of the lower bound X value
+ * @param top_y Corresponding Y value of the upper bound Y value
+ * @param x_value The X value to interpolate
+ * @return The interpolated Y value
+ */
+double Histogram::linearInterpolate(const double bottom_x, const double top_x,
+                                    const double bottom_y, const double top_y,
+                                    const double x_value) {
+  return bottom_y +
+         (top_y - bottom_y) / (top_x - bottom_x) * (x_value - bottom_x);
+}
+
+/**
+ * Update the CDF of the sample histogram
+ */
+void Histogram::updateCdf() {
+  double sample_count =
+      std::accumulate(y_values_.begin(), y_values_.end(), 0.0);
+  double current_cdf = 0.0;
+  for (int i = 0; i < y_values_.size(); i++) {
+    double pdf = y_values_[i] / sample_count;
+    current_cdf += pdf;
+    cdf_values_[i] = current_cdf;
+  }
+}
+
+void Histogram::combine(const Histogram &hist) {
+  for (int i = 0; i < y_values_.size(); i++) {
+    this->y_values_[i] += hist.y_values_[i];
+  }
+  this->updateCdf();
+}
+
+folly::dynamic Histogram::toDynamic() {
+  folly::dynamic hist = folly::dynamic::object;
+  for (int i = 0; i < y_values_.size(); i++) {
+    hist[folly::to<std::string>(x_values_[i])] = y_values_[i];
+  }
+  return hist;
+}
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Histogram.h treadmill/src/Histogram.h
--- treadmill-src/src/Histogram.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Histogram.h	2025-08-04 15:44:21.783368026 -0700
@@ -0,0 +1,126 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <vector>
+
+#include <folly/dynamic.h>
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+class HistogramInput {
+ public:
+  HistogramInput(int number_of_bins, int min_value, int max_value) :
+    number_of_bins_(number_of_bins),
+    min_value_(min_value),
+    max_value_(max_value) {}
+
+  HistogramInput() :
+    HistogramInput(0, 0, 0) {}
+
+  int number_of_bins_;
+  int min_value_;
+  int max_value_;
+};
+
+// Class for histogram of the sampling data
+class Histogram {
+ public:
+  /**
+   * Constructor of Histogram
+   *
+   * @param number_of_bins The number of bins in the sample histogram
+   * @param min_value The minimum value of the sample histogram
+   * @param max_value The maximum value of the sample histogram
+   */
+  Histogram(const int number_of_bins,
+            const double min_value,
+            const double max_value);
+
+  explicit Histogram(const HistogramInput& input) :
+    Histogram(input.number_of_bins_, input.min_value_, input.max_value_) {}
+
+  /**
+   * Add a sample to the histogram
+   *
+   * @param sample_value The sample value to add
+   */
+  void addSample(const double sample_value);
+  /**
+   * Get the X value for a quantile from the sample histogram
+   *
+   * @param quantile The quantile to search for
+   * @return The X value of the quantile in the sample histogram
+   */
+  double getQuantile(const double quantile);
+  /**
+   * Print out the statistic of the histogram
+   */
+  void printHistogram();
+
+  void combine(const Histogram& hist);
+
+  double getMinBin() const {
+    return x_values_.front();
+  }
+
+  double getMaxBin() const {
+    return x_values_.back();
+  }
+
+  void insertSmallerHistogramSamples(std::unique_ptr<Histogram>& histogram);
+
+  /**
+   * Returns a dynamic map representing the histogram
+   */
+  folly::dynamic toDynamic();
+
+ private:
+  /**
+   * Find the bin that is closest to the searched value
+   *
+   * @param values The vector of values to search in
+   * @param search_value The value to search for
+   * @return The index of the closest bin
+   */
+  static int findClosestBin(const std::vector<double>& values,
+                            const double search_value);
+  /**
+   * Simple linear interpolation
+   *
+   * @param bottom_x Lower bound of X value
+   * @param top_x Upper bound of X value
+   * @param bottom_y Corresponding Y value of the lower bound X value
+   * @param top_y Corresponding Y value of the upper bound Y value
+   * @param x_value The X value to interpolate
+   * @return The interpolated Y value
+   */
+  static double linearInterpolate(const double bottom_x, const double top_x,
+                                  const double bottom_y, const double top_y,
+                                  const double x_value);
+  /**
+   * Update the CDF of the sample histogram
+   */
+  void updateCdf();
+
+  // The X values of the bins in the sample histogram
+  std::vector<double> x_values_;
+  // The Y values (counts) of the bins in the sample histogram
+  std::vector<double> y_values_;
+  // The CDF of the sample histogram
+  std::vector<double> cdf_values_;
+};
+
+}  // namespace treadmill
+}  // namespace windtunnel
+}  // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/RandomEngine.cpp treadmill/src/RandomEngine.cpp
--- treadmill-src/src/RandomEngine.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/RandomEngine.cpp	2025-08-04 15:44:21.783935003 -0700
@@ -0,0 +1,83 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include "RandomEngine.h"
+
+#include <sys/time.h>
+#include <thread>
+
+#include <folly/Likely.h>
+
+DEFINE_uint64(random_seed, ULLONG_MAX, "seed for random engines");
+
+using std::mt19937_64;
+using std::uniform_int_distribution;
+using std::uniform_real_distribution;
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+// Seed the random engine
+mt19937_64 RandomEngine::random_engine_(FLAGS_random_seed == ULLONG_MAX
+                                            ? time(nullptr)
+                                            : FLAGS_random_seed);
+// Generate a uniform distribution
+uniform_real_distribution<double> RandomEngine::uniform_real_distribution_(0.0,
+                                                                           1.0);
+uniform_int_distribution<uint64_t>
+    RandomEngine::uniform_int_distribution_(0, ULLONG_MAX);
+
+// Empty thread-local random engine
+folly::ThreadLocalPtr<std::mt19937_64> ThreadSafeRandomEngine::random_engine_;
+
+double RandomEngine::getDouble() {
+  return uniform_real_distribution_(random_engine_);
+}
+
+double RandomEngine::getDouble(double min, double max) {
+  uniform_real_distribution<double> dist(min, max);
+  return dist(random_engine_);
+}
+
+uint64_t RandomEngine::getInteger() {
+  return uniform_int_distribution_(random_engine_);
+}
+
+uint64_t RandomEngine::getInteger(uint64_t min, uint64_t max) {
+  uniform_int_distribution<uint64_t> dist(min, max);
+  return dist(random_engine_);
+}
+
+mt19937_64 &ThreadSafeRandomEngine::get() {
+  mt19937_64 *engine = random_engine_.get();
+  if (UNLIKELY(engine == nullptr)) {
+    std::hash<std::thread::id> hasher;
+    uint64_t seed =
+        hasher(std::this_thread::get_id()) +
+        (FLAGS_random_seed == ULLONG_MAX ? time(nullptr) : FLAGS_random_seed);
+    engine = new mt19937_64(seed);
+    random_engine_.reset(engine);
+  }
+  return *engine;
+}
+
+double ThreadSafeRandomEngine::getDouble(double min, double max) {
+  uniform_real_distribution<double> dist(min, max);
+  return dist(get());
+}
+
+uint64_t ThreadSafeRandomEngine::getInteger(uint64_t min, uint64_t max) {
+  uniform_int_distribution<uint64_t> dist(min, max);
+  return dist(get());
+}
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/RandomEngine.h treadmill/src/RandomEngine.h
--- treadmill-src/src/RandomEngine.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/RandomEngine.h	2025-08-04 15:44:21.784363281 -0700
@@ -0,0 +1,110 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#pragma once
+
+#include <random>
+
+#include <folly/ThreadLocal.h>
+
+DECLARE_uint64(random_seed);
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+/**
+ * Shared struct for Mersene Twister 19937 generator (64 bit)
+ *
+ * The struct produces a shared random number stream that all threads can
+ * access.
+ * The struct might not be thread-safe or have high locking contention depending
+ * on the underlying STL implementation.
+ * If you want a thread-safe PRNG for each thread, use ThreadSafeRandomEngine.
+ */
+struct RandomEngine {
+ public:
+  /**
+   * Return a random number ranging in [0.0, 1.0] in double
+   *
+   * @return A random number ranging in [0.0, 1.0] in double
+   */
+  static double getDouble();
+
+  /**
+   * Return a random number ranging in [min, max] in double
+   *
+   * @return A random number ranging in [min, max] in double
+   */
+  static double getDouble(double min, double max);
+
+  /**
+   * Return a random number ranging in [0, 2^64-1] in uint64_t
+   *
+   * @return A random number ranging in [0, 2^64-1] in uint64_t
+   */
+  static uint64_t getInteger();
+
+  /**
+   * Return a random number ranging in [min, max] in uint64_t
+   *
+   * @return A random number ranging in [min, max] in uint64_t
+   */
+  static uint64_t getInteger(uint64_t min, uint64_t max);
+
+ private:
+  // The Mersene Twister 19937 random engine (64 bit)
+  static std::mt19937_64 random_engine_;
+  // A uniform distribution for real numbers
+  static std::uniform_real_distribution<double> uniform_real_distribution_;
+  // A uniform distribution for integer numbers
+  static std::uniform_int_distribution<uint64_t> uniform_int_distribution_;
+};
+
+/**
+ * Thread-local struct for Mersene Twister 19937 generator (64 bit)
+ *
+ * This struct produces a private random number stream for current thread.
+ * Should perform better than the shared engine.
+ * Different threads will have different seeds derived from the global seed and
+ * their thread ids.
+ * The correlation between streams of all threads might not be 0.
+ * Don't use if you have strong requirement on randomness.
+ */
+struct ThreadSafeRandomEngine {
+ public:
+  /**
+   * Return a random number ranging in [min, max] in double
+   *
+   * @return A random number ranging in [min, max] in double
+   */
+  static double getDouble(double min, double max);
+
+  /**
+   * Return a random number ranging in [min, max] in uint64_t
+   *
+   * @return A random number ranging in [min, max] in uint64_t
+   */
+  static uint64_t getInteger(uint64_t min, uint64_t max);
+
+ private:
+  /**
+   * Return the underlying random engine
+   *
+   * @return The underlying random engine
+   */
+  static std::mt19937_64& get();
+
+  // The Mersene Twister 19937 random engine (64 bit)
+  static folly::ThreadLocalPtr<std::mt19937_64> random_engine_;
+};
+
+}  // namespace treadmill
+}  // namespace windtunnel
+}  // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Request.h treadmill/src/Request.h
--- treadmill-src/src/Request.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Request.h	2025-08-04 15:44:21.784765519 -0700
@@ -0,0 +1,22 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+class Request {
+};
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Scheduler.cpp treadmill/src/Scheduler.cpp
--- treadmill-src/src/Scheduler.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Scheduler.cpp	2025-08-04 15:44:21.785297704 -0700
@@ -0,0 +1,107 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#include "Scheduler.h"
+
+#include <folly/Memory.h>
+#include <folly/futures/Future.h>
+#include <folly/futures/Promise.h>
+
+#include "Util.h"
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+Scheduler::Scheduler(uint32_t rps, uint32_t number_of_workers,
+                     uint32_t logging_threshold)
+    : logging_threshold_(logging_threshold), rps_(rps),
+      logged_(number_of_workers, 1), queues_(number_of_workers) {}
+
+Scheduler::~Scheduler() {}
+
+folly::Future<folly::Unit> Scheduler::run() {
+  running_.store(true, std::memory_order_relaxed);
+  thread_ = std::make_unique<std::thread>([this] { this->loop(); });
+  return promise_.getFuture();
+}
+
+void Scheduler::stop() { running_.store(false); }
+
+void Scheduler::join() {
+  CHECK(!running_);
+  thread_->join();
+}
+
+folly::NotificationQueue<int> &Scheduler::getWorkerQueue(uint32_t id) {
+  return queues_[id];
+}
+
+double Scheduler::randomExponentialInterval(double mean) {
+  static std::mt19937 *rng = new std::mt19937();
+  std::uniform_real_distribution<double> dist(0, 1.0);
+  /* Cap the lower end so that we don't return infinity */
+  return -log(std::max(dist(*rng), 1e-9)) * mean;
+}
+
+void Scheduler::waitNs(int64_t ns) {
+  /* We need to have *precise* timing, and it's not achievable with any other
+     means like 'nanosleep' or EventBase.
+     "pause" instruction would hint processor that this is a spin-loop, it
+     will burn as much CPU as possible. The processor will use this hint
+     to avoid memory order violation, which greatly improves its performance.
+     http://siyobik.info.gf/main/reference/instruction/PAUSE */
+  for (auto start = nowNs(); nowNs() - start < ns;) {
+    asm volatile("pause");
+  }
+}
+
+/**
+ * Responsible for generating requests events.
+ * Requests are randomly spaced (intervals are drawn from an
+ * exponential distribution) to achieve the target throughput rate.
+ * Events would be put into notification queues, which would be selected in
+ * round-robin fashion.
+ */
+void Scheduler::loop() {
+  int64_t interval_ns = 1.0 / rps_ * k_ns_per_s;
+  int64_t a = 0, b = 0, budget = randomExponentialInterval(interval_ns);
+  while (running_) {
+    b = nowNs();
+    if (a) {
+      /* Account for time spent sending the message */
+      budget -= (b - a);
+    }
+    waitNs(std::max(budget, 0L));
+    a = nowNs();
+    /* Decrease the sleep budget by the exact time slept (could have been
+       more than the budget value), increase by the next interval */
+    budget += randomExponentialInterval(interval_ns) - (a - b);
+    queues_[next_].putMessage(0);
+    if (queues_[next_].size() > logging_threshold_ * logged_[next_]) {
+      LOG(INFO) << "Notification queue for worker " << next_
+                << " is overloaded by factor of " << logged_[next_];
+      logged_[next_] *= 2;
+    }
+    ++next_;
+    if (next_ == queues_.size()) {
+      next_ = 0;
+    }
+  }
+  /* Shut down all workers */
+  for (int i = 0; i < queues_.size(); ++i) {
+    queues_[i].putMessage(-1);
+  }
+  promise_.setValue(folly::Unit());
+}
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Scheduler.h treadmill/src/Scheduler.h
--- treadmill-src/src/Scheduler.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Scheduler.h	2025-08-04 15:44:21.785766002 -0700
@@ -0,0 +1,66 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <memory>
+#include <thread>
+
+#include <folly/futures/Future.h>
+#include <folly/futures/Promise.h>
+#include <folly/io/async/NotificationQueue.h>
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+class Scheduler {
+ public:
+  Scheduler(uint32_t rps, uint32_t number_of_workers,
+            uint32_t logging_threshold);
+  ~Scheduler();
+
+  folly::Future<folly::Unit> run();
+
+  // It is safe to call stop() multiple times.
+  void stop();
+
+  // The scheduler _must_ be stopped first.
+  void join();
+
+  folly::NotificationQueue<int>& getWorkerQueue(uint32_t id);
+ private:
+  /**
+   * Draws from an exponential distribution with the given mean.
+   */
+  static double randomExponentialInterval(double mean);
+
+  /**
+   * Waits until given amount of nanosecond pases, for precise timing it uses
+   * spin-loop.
+   */
+  static void waitNs(int64_t ns);
+
+  void loop();
+
+  uint32_t logging_threshold_;
+  uint32_t next_{0};
+  uint32_t rps_;
+
+  std::vector<uint64_t> logged_;
+  std::vector<folly::NotificationQueue<int>> queues_;
+  std::atomic<bool> running_;
+  std::unique_ptr<std::thread> thread_;
+  folly::Promise<folly::Unit> promise_;
+};
+
+}  // namespace treadmill
+}  // namespace windtunnel
+}  // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Statistic.h treadmill/src/Statistic.h
--- treadmill-src/src/Statistic.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Statistic.h	2025-08-04 15:44:21.786249814 -0700
@@ -0,0 +1,49 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <vector>
+
+#include <folly/dynamic.h>
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+class Statistic {
+ public:
+  explicit Statistic(const std::string& name)
+    : name_(name) {}
+
+  virtual ~Statistic() {}
+
+  virtual std::unique_ptr<Statistic> clone() const = 0;
+
+  virtual void printStatistic() const = 0;
+
+  virtual folly::dynamic toDynamic() const = 0;
+
+  // Get fb303 counters.
+  virtual std::unordered_map<std::string, int64_t> getCounters() const = 0;
+
+  virtual void combine(const Statistic& stat) = 0;
+
+  std::string getName() const {
+    return name_;
+  }
+
+ protected:
+  std::string name_;
+};
+
+}  // namespace treadmill
+}  // namespace windtunnel
+}  // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/StatisticsManager.cpp treadmill/src/StatisticsManager.cpp
--- treadmill-src/src/StatisticsManager.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/StatisticsManager.cpp	2025-08-04 15:44:21.786702809 -0700
@@ -0,0 +1,119 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#include "StatisticsManager.h"
+
+#include <glog/logging.h>
+
+#include <folly/Memory.h>
+#include <folly/ThreadLocal.h>
+#include <folly/dynamic.h>
+#include <folly/json.h>
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+class StatsTag;
+static folly::ThreadLocal<StatisticsManager, StatsTag> localManager;
+
+/* static */ StatisticsManager &StatisticsManager::get() {
+  return *localManager;
+}
+
+/* static */ void StatisticsManager::printAll() {
+  StatisticsManager combined = getCombined();
+  combined.print();
+}
+
+void StatisticsManager::print() const {
+  LOG(INFO) << "Statistics:";
+  LOG(INFO) << "";
+  for (auto &stat : stat_map_) {
+    LOG(INFO) << stat.second->getName();
+    stat.second->printStatistic();
+  }
+}
+
+void StatisticsManager::combine(const StatisticsManager &other) {
+  for (const auto &pair : other.stat_map_) {
+    const auto &key = pair.first;
+    const Statistic &stat = *pair.second;
+    auto it = stat_map_.find(key);
+    if (it == stat_map_.end()) {
+      stat_map_[key] = stat.clone();
+    } else {
+      it->second->combine(stat);
+    }
+  }
+}
+
+ContinuousStatistic &
+StatisticsManager::getContinuousStat(const std::string &name) {
+  auto it = stat_map_.find(name);
+  if (it == stat_map_.end()) {
+    if (name == REQUEST_LATENCY) {
+      // More warmup and calibration samples for request latency
+      it = stat_map_
+               .emplace(name, std::make_unique<ContinuousStatistic>(
+                                  name, FLAGS_latency_warmup_samples,
+                                  FLAGS_latency_calibration_samples))
+               .first;
+    } else {
+      it = stat_map_.emplace(name, std::make_unique<ContinuousStatistic>(name))
+               .first;
+    }
+  }
+  return dynamic_cast<ContinuousStatistic &>(*it->second);
+}
+
+CounterStatistic &StatisticsManager::getCounterStat(const std::string &name) {
+  auto it = stat_map_.find(name);
+  if (it == stat_map_.end()) {
+    it =
+        stat_map_.emplace(name, std::make_unique<CounterStatistic>(name)).first;
+  }
+  return dynamic_cast<CounterStatistic &>(*it->second);
+}
+
+/* static */ StatisticsManager StatisticsManager::getCombined() {
+  StatisticsManager combined;
+  for (const auto &manager : localManager.accessAllThreads()) {
+    combined.combine(manager);
+  }
+  return combined;
+}
+
+/* static */ std::string StatisticsManager::toJson() {
+  StatisticsManager combined = getCombined();
+  folly::dynamic map = folly::dynamic::object;
+  for (auto &pair : combined.stat_map_) {
+    map[pair.first] = pair.second->toDynamic();
+  }
+  folly::json::serialization_opts opts;
+  opts.allow_nan_inf = true;
+  opts.allow_non_string_keys = true;
+  return folly::json::serialize(map, opts);
+}
+
+/* static */
+std::map<std::string, int64_t> StatisticsManager::exportAllCounters() {
+  StatisticsManager combined = getCombined();
+  std::map<std::string, int64_t> m;
+  for (const auto &p1 : combined.stat_map_) {
+    const auto m2 = p1.second->getCounters();
+    m.insert(m2.begin(), m2.end());
+  }
+  return m;
+}
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/StatisticsManager.h treadmill/src/StatisticsManager.h
--- treadmill-src/src/StatisticsManager.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/StatisticsManager.h	2025-08-04 15:44:21.787186099 -0700
@@ -0,0 +1,67 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <memory>
+#include <unordered_map>
+
+#include "ContinuousStatistic.h"
+#include "CounterStatistic.h"
+#include "Statistic.h"
+
+DECLARE_int32(latency_calibration_samples);
+DECLARE_int32(latency_warmup_samples);
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+// Statistics names are kept here
+const std::string REQUEST_LATENCY = "request_latency";
+const std::string THROUGHPUT = "throughput";
+const std::string OUTSTANDING_REQUESTS = "outstanding_requests";
+const std::string EXCEPTIONS = "exceptions";
+const std::string UNCAUGHT_EXCEPTIONS = "uncaught_exceptions";
+
+class StatisticsManager {
+public:
+  StatisticsManager() {}
+
+  virtual ~StatisticsManager() {}
+
+  void print() const;
+
+  static StatisticsManager &get();
+  static StatisticsManager getCombined();
+  static void printAll();
+  static std::string toJson();
+  static std::map<std::string, int64_t> exportAllCounters();
+
+  ContinuousStatistic &getContinuousStat(const std::string &name);
+  CounterStatistic &getCounterStat(const std::string &name);
+
+  StatisticsManager(StatisticsManager const &);
+  void operator=(StatisticsManager const &);
+
+  using StatMapType =
+      std::unordered_map<std::string, std::unique_ptr<Statistic>>;
+
+  const StatMapType &getStatMap() const { return stat_map_; }
+
+private:
+  void combine(const StatisticsManager &other);
+
+  StatMapType stat_map_;
+};
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Treadmill.cpp treadmill/src/Treadmill.cpp
--- treadmill-src/src/Treadmill.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Treadmill.cpp	2025-08-04 15:44:21.787727598 -0700
@@ -0,0 +1,129 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#include <string>
+
+#include <folly/init/Init.h>
+#include <gflags/gflags.h>
+#include <glog/logging.h>
+
+// The path to the workload configuration file
+DEFINE_string(config_file,
+              "./examples/flat.json",
+              "The path to the workload configuration file.");
+
+// The hostname of the server
+DEFINE_string(hostname,
+              "localhost",
+              "The host to load test.");
+
+DEFINE_string(counter_name,
+              "",
+              "Counter to compare against threshold (e.g, foo.bar.count).");
+
+DEFINE_int32(counter_threshold,
+             -1,
+             "counter_name value > counter_threshold before sending requests.");
+
+// The number of connections each worker thread handles
+DEFINE_int32(number_of_connections,
+             4,
+             "The number of connections for each thread worker.");
+
+// The total number of workers
+DEFINE_int32(number_of_workers,
+             1,
+             "The number of workers.");
+
+// The number of keys in the workload
+DEFINE_int64(number_of_keys,
+             1024,
+             "The number of keys in the workload.");
+
+// The port number to connect
+DEFINE_int32(port,
+             11211,
+             "The port on the host to connect to.");
+
+// The request per second trying to send
+DEFINE_int32(request_per_second,
+             1024,
+             "The request per second to send.");
+
+// The total testing time in second
+DEFINE_int32(runtime,
+             120,
+             "The total runtime in seconds.");
+
+// The file to store the JSON output statistics
+DEFINE_string(output_file,
+              "",
+              "Where to print the json output of statistics.");
+
+// The max number of requests to have outstanding per worker
+DEFINE_int32(max_outstanding_requests,
+             1000,
+             "The max number of requests to have outstanding per worker.");
+
+// Config filename to pass into the workload in JSON format
+DEFINE_string(config_in_file,
+              "",
+              "Config filename to pass into the workload in JSON format.");
+
+DEFINE_string(config_in_json,
+              "",
+              "Configuration string to be parsed as JSON for the workload. "
+              "If --config_in_file is also specified, "
+              "the configs are merged.");
+
+// Config filename to export from the workload in JSON format
+DEFINE_string(config_out_file,
+              "",
+              "Config filename to export from the workload in JSON format.");
+
+// Comma-separated list of CPU IDs to pin the workers
+DEFINE_string(cpu_affinity,
+              "",
+              "Comma-separated list of CPU IDs to pin the workers.");
+
+// Default number of calibration samples for continuous statistics
+DEFINE_int32(default_calibration_samples,
+             10,
+             "Default number of calibration samples for continuous statistics.");
+
+// Default number of warm-up samples for continuous statistics
+DEFINE_int32(default_warmup_samples,
+             10,
+             "Default number of warm-up samples for continuous statistics.");
+
+// Number of calibration samples for latency statistics
+DEFINE_int32(latency_calibration_samples,
+             1000,
+             "Number of calibration samples for latency statistics.");
+
+// Number of warm-up samples for latency statistics
+DEFINE_int32(latency_warmup_samples,
+             1000,
+             "Number of warm-up samples for latency statistics.");
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+void init(int argc, char* argv[]) {
+  // Set the usage information
+  std::string usage("Treadmill loadtester");
+  google::SetUsageMessage(usage);
+  folly::init(&argc, &argv);
+}
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/TreadmillFB303.cpp treadmill/src/TreadmillFB303.cpp
--- treadmill-src/src/TreadmillFB303.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/TreadmillFB303.cpp	2025-08-04 15:44:21.788168875 -0700
@@ -0,0 +1,52 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#include "TreadmillFB303.h"
+
+#include <memory>
+
+#include <folly/Singleton.h>
+#include <thrift/lib/cpp2/server/ThriftServer.h>
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+namespace {
+folly::Singleton<TreadmillFB303> instance;
+}
+
+std::shared_ptr<TreadmillFB303> getGlobalTreadmillFB303() {
+  return instance.try_get();
+}
+
+void TreadmillFB303::make_fb303(
+    std::shared_ptr<std::thread>& server_thread,
+    int server_port) {
+  using facebook::windtunnel::treadmill::getGlobalTreadmillFB303;
+  auto server = std::make_shared<apache::thrift::ThriftServer>();
+  server->setPort(server_port);
+  server->setInterface(getGlobalTreadmillFB303());
+  server_thread.reset(
+    new std::thread(
+      [server]() {
+        server->serve();
+      }),
+    [server](std::thread* t) {
+      server->stop();
+      t->join();
+      delete t;
+    }
+  );
+}
+
+}
+}
+}
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/TreadmillFB303.h treadmill/src/TreadmillFB303.h
--- treadmill-src/src/TreadmillFB303.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/TreadmillFB303.h	2025-08-04 15:44:21.788645166 -0700
@@ -0,0 +1,73 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <memory>
+
+#include <folly/SharedMutex.h>
+#include <folly/Singleton.h>
+
+#include "common/fb303/if/gen-cpp2/FacebookService.h"
+#include "treadmill/StatisticsManager.h"
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+// TODO(14039001): commonize this so other treadmills can use it
+class TreadmillFB303 : public facebook::fb303::cpp2::FacebookServiceSvIf {
+ public:
+  using fb_status = facebook::fb303::cpp2::fb_status;
+
+  explicit TreadmillFB303()
+    : status_(fb_status::STARTING),
+      aliveSince_(time(nullptr)) {}
+
+  ~TreadmillFB303() override {}
+
+  void setStatus(fb_status status) {
+    folly::SharedMutex::WriteHolder(mutex_);
+    status_ = status;
+  }
+
+  fb_status getStatus() override {
+    folly::SharedMutex::ReadHolder(mutex_);
+    return status_;
+  }
+
+  void getStatusDetails(std::string& _return) override {
+    _return = fb303::cpp2::_fb_status_VALUES_TO_NAMES.at(getStatus());
+  }
+
+  int64_t aliveSince() override {
+    folly::SharedMutex::ReadHolder(mutex_);
+    return aliveSince_;
+  }
+
+  void getCounters(std::map<std::string, int64_t>& _return) override {
+    _return = StatisticsManager::exportAllCounters();
+  }
+
+  static void make_fb303(
+      std::shared_ptr<std::thread>& server_thread,
+      int server_port);
+
+ private:
+  fb_status status_;
+  const int64_t aliveSince_;
+  folly::SharedMutex mutex_;
+};
+
+extern std::shared_ptr<TreadmillFB303> getGlobalTreadmillFB303();
+
+}
+}
+}
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Treadmill.h treadmill/src/Treadmill.h
--- treadmill-src/src/Treadmill.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Treadmill.h	2025-08-04 15:44:21.789252864 -0700
@@ -0,0 +1,208 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <string>
+#include <thread>
+#include <vector>
+
+#include <folly/String.h>
+#include <folly/futures/Future.h>
+#include <folly/json.h>
+#include <gflags/gflags.h>
+#include <glog/logging.h>
+
+#include "Scheduler.h"
+#include "Worker.h"
+
+// The path to the workload configuration file
+DECLARE_string(config_file);
+
+// The hostname of the server
+DECLARE_string(hostname);
+
+DECLARE_string(counter_name);
+
+DECLARE_int32(counter_threshold);
+
+// The number of connections each worker thread handles
+DECLARE_int32(number_of_connections);
+
+// The total number of workers
+DECLARE_int32(number_of_workers);
+
+// The number of keys in the workload
+DECLARE_int64(number_of_keys);
+
+// The port number to connect
+DECLARE_int32(port);
+
+// The request per second trying to send
+DECLARE_int32(request_per_second);
+
+// The total testing time in second
+DECLARE_int32(runtime);
+
+// The file to store the JSON output statistics
+DECLARE_string(output_file);
+
+// The max number of requests to have outstanding per worker
+DECLARE_int32(max_outstanding_requests);
+
+// Config filename to pass into the workload in JSON format
+DECLARE_string(config_in_file);
+
+// Config string to pass into the workload in JSON format
+DECLARE_string(config_in_json);
+
+// Config filename to export from the workload in JSON format
+DECLARE_string(config_out_file);
+
+// Comma-separated list of CPU IDs to pin the workers
+DECLARE_string(cpu_affinity);
+
+// Default number of calibration samples for continuous statistics
+DECLARE_int32(default_calibration_samples);
+
+// Default number of warm-up samples for continuous statistics
+DECLARE_int32(default_warmup_samples);
+
+// Number of calibration samples for latency statistics
+DECLARE_int32(latency_calibration_samples);
+
+// Number of warm-up samples for latency statistics
+DECLARE_int32(latency_warmup_samples);
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+/**
+ * Press start to rock
+ *
+ * @param argc Argument count
+ * @param argv Argument vector
+ */
+template <typename Service> int run(int argc, char *argv[]) {
+  std::vector<std::unique_ptr<Worker<Service>>> workers;
+  double rps = FLAGS_request_per_second / (double)FLAGS_number_of_workers;
+  int max_outstanding_requests_per_worker =
+      FLAGS_max_outstanding_requests / FLAGS_number_of_workers;
+  LOG(INFO) << "Desired rps per worker: " << rps;
+  LOG(INFO) << "Max outstanding requests per worker: "
+            << max_outstanding_requests_per_worker;
+  LOG(INFO) << "N Workers: " << FLAGS_number_of_workers;
+  LOG(INFO) << "N Connections: " << FLAGS_number_of_connections;
+
+  folly::dynamic config = folly::dynamic::object;
+  if (FLAGS_config_in_file != "") {
+    config = readDynamicFromFile(FLAGS_config_in_file);
+  }
+  if (FLAGS_config_in_json != "") {
+    folly::dynamic config2 = folly::parseJson(FLAGS_config_in_json);
+    config.update(config2);
+  }
+  int cpu_affinity_list[FLAGS_number_of_workers];
+  std::fill_n(cpu_affinity_list, FLAGS_number_of_workers, -1);
+
+  if (FLAGS_cpu_affinity != "") {
+    int total_number_of_cores = std::thread::hardware_concurrency();
+    std::vector<folly::StringPiece> affinity_string_list;
+    folly::split(",", FLAGS_cpu_affinity, affinity_string_list);
+    if (affinity_string_list.size() != FLAGS_number_of_workers) {
+      LOG(FATAL) << "Length of the CPU affinity list ("
+                 << affinity_string_list.size()
+                 << ") does not match the number of workers ("
+                 << FLAGS_number_of_workers << ")";
+    } else {
+      for (int i = 0; i < FLAGS_number_of_workers; i++) {
+        int cpu_affinity = folly::to<int>(affinity_string_list[i]);
+        if (cpu_affinity >= 0 && cpu_affinity < total_number_of_cores) {
+          cpu_affinity_list[i] = cpu_affinity;
+        } else {
+          LOG(FATAL) << "Core " << cpu_affinity << " does not exist";
+        }
+      }
+    }
+  }
+
+  Scheduler scheduler(FLAGS_request_per_second, FLAGS_number_of_workers,
+                      max_outstanding_requests_per_worker);
+
+  auto terminate_early_fn = [&scheduler]() { scheduler.stop(); };
+
+  for (int i = 0; i < FLAGS_number_of_workers; i++) {
+    workers.push_back(std::make_unique<Worker<Service>>(
+        scheduler.getWorkerQueue(i), FLAGS_number_of_workers,
+        FLAGS_number_of_connections, max_outstanding_requests_per_worker,
+        config, cpu_affinity_list[i], terminate_early_fn));
+  }
+
+  // Start testing
+  for (int i = 0; i < FLAGS_number_of_workers; i++) {
+    workers[i]->run();
+  }
+
+  // Start the test and wait for it to finish.
+  std::vector<folly::SemiFuture<folly::Unit>> futs;
+  futs.push_back(scheduler.run());
+  futs.push_back(folly::futures::sleep(std::chrono::seconds(FLAGS_runtime)));
+  folly::collectAny(futs).wait();
+
+  LOG(INFO) << "Stopping and joining scheduler thread";
+  scheduler.stop();
+  scheduler.join();
+
+  StatisticsManager::printAll();
+  if (FLAGS_output_file != "") {
+    int fd =
+        open(FLAGS_output_file.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0666);
+    if (fd == -1) {
+      LOG(FATAL) << "Open to write file failed: " << FLAGS_output_file;
+    }
+    std::string json = StatisticsManager::toJson();
+    writeBlock(fd, json.c_str(), json.size());
+    close(fd);
+  }
+
+  LOG(INFO) << "Stopping workers";
+
+  // We already stored stats, so just drop all remaining scheduled request.
+  for (int i = 0; i < FLAGS_number_of_workers; i++) {
+    workers[i]->stop();
+  }
+
+  LOG(INFO) << "Joining worker threads";
+
+  // Join worker threads
+  for (int i = 0; i < FLAGS_number_of_workers; i++) {
+    workers[i]->join();
+  }
+  if (FLAGS_config_out_file != "") {
+    LOG(INFO) << "Saving config";
+    std::vector<Worker<Service> *> workerRefs;
+    for (auto &worker : workers) {
+      workerRefs.push_back(worker.get());
+    }
+    auto config_output = workers[0]->makeConfigOutputs(workerRefs);
+    writeDynamicToFile(FLAGS_config_out_file, config_output);
+  }
+
+  LOG(INFO) << "Complete";
+
+  return 0;
+}
+
+void init(int argc, char *argv[]);
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Util.cpp treadmill/src/Util.cpp
--- treadmill-src/src/Util.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Util.cpp	2025-08-04 15:44:21.789839071 -0700
@@ -0,0 +1,206 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#include "Util.h"
+
+#include <arpa/inet.h>
+#include <fstream>
+#include <glog/logging.h>
+#include <netdb.h>
+#include <sys/time.h>
+
+#include <folly/json.h>
+
+using std::string;
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+// The number of attempts to get host information
+const int kNumberOfAttempts = 3;
+
+int64_t nowNs() {
+  struct timespec ts;
+  int r = clock_gettime(CLOCK_MONOTONIC, &ts);
+  PCHECK(r == 0);
+  return (ts.tv_nsec + ts.tv_sec * k_ns_per_s);
+}
+
+bool writeStringToFile(std::string txt, std::string filename) {
+  std::ofstream os(filename);
+  try {
+    os.exceptions(std::ofstream::failbit | std::ofstream::badbit);
+    os << txt;
+    os.close();
+  } catch (std::exception const &e) {
+    LOG(ERROR) << "Failed to write file " << e.what();
+    return false;
+  }
+
+  return true;
+}
+
+bool readFileToString(std::string filename, std::string &txt) {
+  std::ifstream is(filename.c_str());
+  try {
+    is.exceptions(std::ifstream::failbit | std::ifstream::badbit);
+
+    std::stringstream buffer;
+    buffer << is.rdbuf();
+    is.close();
+    txt = buffer.str();
+  } catch (std::exception const &e) {
+    LOG(ERROR) << "Failed to read file " << e.what();
+    return false;
+  }
+
+  return true;
+}
+
+void writeDynamicToFile(std::string filename, folly::dynamic object) {
+  std::string json = folly::toJson(object);
+  if (!writeStringToFile(json, filename)) {
+    LOG(FATAL) << "Open to read failed: " << filename;
+  }
+}
+
+folly::dynamic readDynamicFromFile(std::string filename) {
+  std::string s;
+  if (!readFileToString(filename, s)) {
+    LOG(FATAL) << "Open to read failed: " << filename;
+  }
+  return folly::parseJson(s);
+}
+
+/**
+ * Read a line from the file descriptor
+ *
+ * @param fd The file descriptor
+ * @param buffer The buffer to write
+ * @param buffer_size The size of the read buffer
+ * @return The total amount of bytes read
+ */
+int readLine(int fd, char *buffer, int buffer_size) {
+  int total_bytes_read = 0;
+  do {
+    read(fd, buffer + total_bytes_read, 1);
+    total_bytes_read++;
+  } while (total_bytes_read < buffer_size &&
+           (buffer[total_bytes_read - 2] != '\r' ||
+            buffer[total_bytes_read - 1] != '\n'));
+  return total_bytes_read;
+}
+
+/**
+ * Read from block given the file descriptor
+ *
+ * @param fd The file descriptor
+ * @param buffer The buffer to write
+ * @param buffer_size The size of the read buffer
+ */
+void readBlock(int fd, char *buffer, int buffer_size) {
+  int total_bytes_read = 0;
+  while (total_bytes_read != buffer_size) {
+    int bytes_read =
+        read(fd, buffer + total_bytes_read, buffer_size - total_bytes_read);
+    // Read syscall failed.
+    if (bytes_read < 0) {
+      string sys_error = string(strerror(errno));
+      LOG(FATAL) << "Read syscall failed: " + sys_error;
+    }
+    total_bytes_read += bytes_read;
+  }
+
+  // Make sure all bytes have been read from the fd.
+  if (total_bytes_read < buffer_size) {
+    LOG(FATAL) << "Read loop exited before all bytes were written."
+                  "This should never happen";
+  }
+}
+
+/**
+ * Write to block given the file descriptor
+ *
+ * @param fd The file descriptor
+ * @param buffer The buffer to write
+ * @param buffer_size The size of the write buffer
+ */
+void writeBlock(int fd, const char *buffer, int buffer_size) {
+  int total_bytes_written = 0;
+  while (total_bytes_written != buffer_size) {
+    int bytes_written = write(fd, buffer + total_bytes_written,
+                              buffer_size - total_bytes_written);
+    // Write syscall failed.
+    if (bytes_written < 0) {
+      LOG(INFO) << "Attempted write size "
+                << (buffer_size - total_bytes_written);
+      string sys_error = string(strerror(errno));
+      LOG(FATAL) << "Write syscall failed: " + sys_error;
+    }
+    total_bytes_written += bytes_written;
+  }
+}
+
+double time_s() {
+  struct timeval time_stamp = {0, 0};
+  gettimeofday(&time_stamp, nullptr);
+  return time_stamp.tv_sec + time_stamp.tv_usec * 1e-6;
+}
+
+/**
+ * Loop up the IP address given hostname; return the first ip address
+ * returned by getaddrinfo; if error occurs, return non-zero error code.
+ *
+ * @param hostname Hostname for the server in string, support ipv4 & ipv6
+ * @return IP address under the hostname in string
+ */
+std::string nsLookUp(const string &hostname) {
+  string ret;
+  struct addrinfo hints;
+  struct addrinfo *res;
+  memset(&hints, 0, sizeof(hints));
+  hints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */
+
+  int error = -1;
+  for (int attempt = 0; (error != 0) && (attempt < kNumberOfAttempts);
+       attempt++) {
+    error = getaddrinfo(hostname.c_str(), nullptr, &hints, &res);
+  }
+
+  if (error == 0) {
+    int len = res->ai_addrlen;
+
+    if (res->ai_addr->sa_family == AF_INET) {
+      // IPv4
+      char ip_address[INET_ADDRSTRLEN];
+      struct sockaddr_in *addr = (struct sockaddr_in *)res->ai_addr;
+      inet_ntop(AF_INET, &(addr->sin_addr.s_addr), ip_address, INET_ADDRSTRLEN);
+      ret = string(ip_address);
+    } else {
+      // IPv6
+      char ip_address[INET6_ADDRSTRLEN];
+      struct sockaddr_in6 *addr = (struct sockaddr_in6 *)res->ai_addr;
+      inet_ntop(AF_INET6, &(addr->sin6_addr.s6_addr), ip_address,
+                INET6_ADDRSTRLEN);
+      ret = string(ip_address);
+    }
+    freeaddrinfo(res);
+  } else {
+    LOG(FATAL) << "DNS error: " << gai_strerror(error);
+    exit(error);
+  }
+
+  return ret;
+}
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Util.h treadmill/src/Util.h
--- treadmill-src/src/Util.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Util.h	2025-08-04 15:44:21.790310484 -0700
@@ -0,0 +1,71 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <random>
+
+#include <folly/dynamic.h>
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+// Number of nanoseconds in one second.
+constexpr int64_t k_ns_per_s = 1000000000;
+
+/**
+ * Get current time according to CLOCK_MONOTONIC.
+ *
+ * @return current time in nanoseconds.
+ */
+int64_t nowNs();
+
+void writeDynamicToFile(std::string filename, folly::dynamic);
+
+folly::dynamic readDynamicFromFile(std::string filename);
+
+/**
+ * Read a line from the file descriptor
+ *
+ * @param fd The file descriptor
+ * @param buffer The buffer to write
+ * @param buffer_size The size of the read buffer
+ * @return The total amount of bytes read
+ */
+int readLine(int fd, char* buffer, int buffer_size);
+
+/**
+ * Read from block given the file descriptor
+ *
+ * @param fd The file descriptor
+ * @param buffer The buffer to write
+ * @param buffer_size The size of the read buffer
+ */
+void readBlock(int fd, char* buffer, int buffer_size);
+
+/**
+ * Write to block given the file descriptor
+ *
+ * @param fd The file descriptor
+ * @param buffer The buffer to write
+ * @param buffer_size The size of the write buffer
+ */
+void writeBlock(int fd,
+                const char* buffer,
+                int buffer_size);
+
+std::string nsLookUp(const std::string& hostname);
+
+double time_s();
+
+}  // namespace treadmill
+}  // namespace windtunnel
+}  // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Worker.h treadmill/src/Worker.h
--- treadmill-src/src/Worker.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Worker.h	2025-08-04 15:44:21.791388194 -0700
@@ -0,0 +1,250 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+#include <sched.h>
+
+#include <memory>
+#include <thread>
+
+#include <glog/logging.h>
+
+#include <folly/Memory.h>
+#include <folly/MoveWrapper.h>
+#include <folly/String.h>
+#include <folly/futures/Future.h>
+#include <folly/io/async/EventBase.h>
+#include <folly/io/async/NotificationQueue.h>
+#include <folly/system/ThreadName.h>
+
+#include "Connection.h"
+#include "StatisticsManager.h"
+#include "Util.h"
+#include "Workload.h"
+
+DEFINE_bool(wait_for_target_ready, false,
+            "If true, wait until the target is ready.");
+
+DECLARE_string(counter_name);
+DECLARE_int32(counter_threshold);
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+template <class Service>
+class Worker : private folly::NotificationQueue<int>::Consumer {
+public:
+  Worker(folly::NotificationQueue<int> &queue, int number_of_workers,
+         int number_of_connections, int max_outstanding_requests,
+         const folly::dynamic &config, int cpu_affinity,
+         std::function<void()> terminate_early_fn)
+      : number_of_workers_(number_of_workers),
+        number_of_connections_(number_of_connections),
+        max_outstanding_requests_(max_outstanding_requests), workload_(config),
+        cpu_affinity_(cpu_affinity), queue_(queue),
+        terminate_early_fn_(terminate_early_fn) {
+    for (int i = 0; i < number_of_connections_; i++) {
+      connections_.push_back(
+          std::make_unique<Connection<Service>>(event_base_));
+    }
+  }
+
+  ~Worker() {}
+
+  void run() {
+    // If countername is specified then make sure wait_for_target was also true
+    if (!FLAGS_counter_name.empty() &&
+        (!FLAGS_wait_for_target_ready || FLAGS_counter_threshold < 0)) {
+      LOG(FATAL) << "--counter_name " << FLAGS_counter_name
+                 << " specified without --wait_for_target_ready"
+                 << " or valid --counter_threshold value";
+    }
+
+    if (FLAGS_wait_for_target_ready) {
+      for (auto &conn : connections_) {
+        while (!conn->isReady()) {
+          LOG(INFO) << "Target not ready";
+          /* sleep override */ sleep(1);
+        }
+      }
+      LOG(INFO) << "Target is ready";
+    }
+
+    running_.store(true, std::memory_order_relaxed);
+    sender_thread_ =
+        std::make_unique<std::thread>([this] { this->senderLoop(); });
+  }
+
+  void stop() { running_.store(false); }
+
+  void join() { sender_thread_->join(); }
+
+  folly::dynamic makeConfigOutputs(std::vector<Worker *> worker_refs) {
+    std::vector<Workload<Service> *> workload_refs;
+    for (auto worker : worker_refs) {
+      workload_refs.push_back(&(worker->workload_));
+    }
+    return workload_.makeConfigOutputs(workload_refs);
+  }
+
+private:
+  /**
+   * Sender loop listens to the request queue and network events.
+   * It will only send up to the outstanding requests limit.
+   */
+  void senderLoop() {
+    folly::setThreadName("treadmill-wrkr");
+    if (cpu_affinity_ != -1) {
+      cpu_set_t mask;
+      CPU_ZERO(&mask);
+      CPU_SET(cpu_affinity_, &mask);
+      if (sched_setaffinity(0, sizeof(cpu_set_t), &mask)) {
+        LOG(ERROR) << "Failed to set CPU affinity";
+      }
+    }
+    throughput_statistic_ =
+        &StatisticsManager::get().getContinuousStat(THROUGHPUT);
+    outstanding_statistic_ =
+        &StatisticsManager::get().getContinuousStat(OUTSTANDING_REQUESTS);
+    latency_statistic_ =
+        &StatisticsManager::get().getContinuousStat(REQUEST_LATENCY);
+    exceptions_statistic_ =
+        &StatisticsManager::get().getCounterStat(EXCEPTIONS);
+    uncaught_exceptions_statistic_ =
+        &StatisticsManager::get().getCounterStat(UNCAUGHT_EXCEPTIONS);
+    last_throughput_time_ = nowNs();
+
+    startConsuming(&event_base_, &queue_);
+    event_base_.loopForever();
+  }
+
+  void messageAvailable(int &&message) noexcept override {
+    if (message == -1 || !running_) {
+      stopConsuming();
+      if (to_send_ == 0 && outstanding_requests_ == 0) {
+        event_base_.terminateLoopSoon();
+      } else {
+        // To avoid potential race condition
+        running_.store(false);
+      }
+      return;
+    }
+
+    ++to_send_;
+    pumpRequests();
+  }
+
+  void pumpRequests() {
+    while (to_send_ && outstanding_requests_ < max_outstanding_requests_ &&
+           running_) {
+
+      auto request_tuple = workload_.getNextRequest();
+      if (std::get<0>(request_tuple) == nullptr) {
+        LOG(INFO) << "terminating";
+        running_.store(false);
+        terminate_early_fn_();
+        return;
+      }
+      auto pw = folly::makeMoveWrapper(std::move(std::get<1>(request_tuple)));
+      ++outstanding_requests_;
+      --to_send_;
+      auto conn_idx = conn_idx_;
+      conn_idx_ = (conn_idx_ + 1) % number_of_connections_;
+      auto send_time = nowNs();
+
+      auto reply =
+          connections_[conn_idx]
+              ->sendRequest(std::move(std::get<0>(request_tuple)))
+              .then([send_time, this,
+                     pw](folly::Try<typename Service::Reply> &&t) mutable {
+                auto recv_time = nowNs();
+                latency_statistic_->addSample((recv_time - send_time) / 1000.0);
+                n_throughput_requests_++;
+                if (t.hasException()) {
+                  n_exceptions_by_type_
+                      [t.exception().class_name().toStdString()]++;
+                  LOG(INFO) << t.exception().what();
+                  pw->setException(t.exception());
+                }
+                if (t.hasValue()) {
+                  pw->setValue(std::move(t.value()));
+                }
+
+                --outstanding_requests_;
+
+                if (!running_ && outstanding_requests_ == 0) {
+                  event_base_.terminateLoopSoon();
+                } else {
+                  pumpRequests();
+                }
+              });
+      auto &f = std::get<2>(request_tuple);
+      std::move(f).thenError([this](folly::exception_wrapper ew) {
+        n_uncaught_exceptions_by_type_[ew.class_name().toStdString()]++;
+        return folly::makeFuture<
+            typename std::remove_reference<decltype(f)>::type::value_type>(ew);
+      });
+    }
+
+    // Estimate throughput and outstanding requests
+    auto t = nowNs();
+    double throughput_delta = double(t - last_throughput_time_) / k_ns_per_s;
+    if (throughput_delta >= 0.1) {
+      double throughput =
+          n_throughput_requests_ / throughput_delta * number_of_workers_;
+      throughput_statistic_->addSample(throughput);
+      n_throughput_requests_ = 0;
+      last_throughput_time_ = t;
+      double outstanding = outstanding_requests_ * number_of_workers_;
+      outstanding_statistic_->addSample(outstanding);
+    }
+
+    for (auto p : n_exceptions_by_type_) {
+      exceptions_statistic_->increase(p.second, p.first);
+    }
+    n_exceptions_by_type_.clear();
+
+    for (auto p : n_uncaught_exceptions_by_type_) {
+      uncaught_exceptions_statistic_->increase(p.second, p.first);
+    }
+    n_uncaught_exceptions_by_type_.clear();
+  }
+
+  std::vector<std::unique_ptr<Connection<Service>>> connections_;
+  folly::EventBase event_base_;
+  std::atomic<bool> running_;
+  int number_of_workers_;
+  int number_of_connections_;
+  size_t max_outstanding_requests_;
+  Workload<Service> workload_;
+  int cpu_affinity_;
+  int64_t last_throughput_time_{0};
+  size_t n_throughput_requests_{0};
+  std::unordered_map<std::string, size_t> n_exceptions_by_type_;
+  std::unordered_map<std::string, size_t> n_uncaught_exceptions_by_type_;
+
+  folly::NotificationQueue<int> &queue_;
+  std::unique_ptr<std::thread> sender_thread_;
+  size_t conn_idx_{0};
+  size_t outstanding_requests_{0};
+  size_t to_send_{0};
+  ContinuousStatistic *latency_statistic_{nullptr};
+  ContinuousStatistic *throughput_statistic_{nullptr};
+  ContinuousStatistic *outstanding_statistic_{nullptr};
+  CounterStatistic *exceptions_statistic_{nullptr};
+  CounterStatistic *uncaught_exceptions_statistic_{nullptr};
+  std::function<void()> terminate_early_fn_;
+};
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/src/Workload.h treadmill/src/Workload.h
--- treadmill-src/src/Workload.h	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/src/Workload.h	2025-08-04 15:44:21.792085738 -0700
@@ -0,0 +1,54 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#pragma once
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+template <class Workload>
+class WorkloadBase {
+ public:
+  void setPhase(const std::string& phase) {
+    phase_ = phase;
+  }
+  const std::string getPhase() const {
+    return phase_;
+  }
+
+ protected:
+  std::string phase_;
+};
+
+template <class Service>
+class Workload {
+  /**
+   * Workloads are implemented as template specializations that derive from
+   * WorkloadBase using themselves as template parameter. Example:
+   *   class Workload<MyService> : BaseWorkload<Workload<MyService>> {...};
+   *
+   * Any specialization of Workload must implement the following functions:
+   *  explicit Workload<Service>(folly::dynamic config)
+   *  void reset() - to reset their internal state. (Used via Scheduler::resume
+   *                 to re-synchronize A/B sides after pausing.)
+   *  std::tuple<
+   *              std::unique_ptr<HhvmHttpReplayService::Request>,
+   *              folly::Promise<HhvmHttpReplayService::Reply>,
+   *              folly::Future<HhvmHttpReplayService::Reply>
+   *            > getNextRequest() - to get one request from the workload.
+   *  folly::dynamic makeConfigOutputs(
+   *      std::vector<Workload<HhvmHttpReplayService>*>)
+   */
+};
+
+} // namespace treadmill
+} // namespace windtunnel
+} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Statistic.h treadmill/Statistic.h
--- treadmill-src/Statistic.h	2025-08-11 17:04:00.476702624 -0700
+++ treadmill/Statistic.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,48 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-#include <vector>
-
-#include <folly/dynamic.h>
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-class Statistic {
- public:
-  explicit Statistic(const std::string& name) : name_(name) {}
-
-  virtual ~Statistic() {}
-
-  virtual std::unique_ptr<Statistic> clone() const = 0;
-
-  virtual void printStatistic() const = 0;
-
-  virtual folly::dynamic toDynamic() const = 0;
-
-  // Get fb303 counters.
-  virtual std::unordered_map<std::string, int64_t> getCounters() const = 0;
-
-  virtual void combine(const Statistic& stat) = 0;
-
-  std::string getName() const {
-    return name_;
-  }
-
- protected:
-  std::string name_;
-};
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/StatisticsManager.cpp treadmill/StatisticsManager.cpp
--- treadmill-src/StatisticsManager.cpp	2025-08-11 17:04:00.476952903 -0700
+++ treadmill/StatisticsManager.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,113 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#include "treadmill/StatisticsManager.h"
-
-#include <glog/logging.h>
-
-#include <folly/Format.h>
-#include <folly/Memory.h>
-#include <folly/Singleton.h>
-#include <folly/dynamic.h>
-#include <folly/json.h>
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-namespace {
-struct PrivateTag {};
-
-static folly::Singleton<StatisticsManager, PrivateTag> managerSingle;
-const auto kQuantiles = std::array<double, 13>{
-    {0.01,
-     0.05,
-     0.10,
-     0.15,
-     0.20,
-     0.50,
-     0.80,
-     0.85,
-     0.90,
-     0.95,
-     0.99,
-     0.999,
-     1.0}};
-
-} // namespace
-/* static */ std::shared_ptr<StatisticsManager> StatisticsManager::get() {
-  return managerSingle.try_get();
-}
-
-void StatisticsManager::print() const {
-  LOG(INFO) << "Statistics:";
-  LOG(INFO) << "";
-  count_map_.withWLock([](auto& m) {
-    for (auto& cp : m) {
-      LOG(INFO) << cp.first;
-      cp.second->printStatistic();
-    }
-  });
-
-  histo_map_.withWLock([](auto& m) {
-    for (auto& cp : m) {
-      // Unlike the counter there's no printStatistic for our histograms. So we
-      // have to do that here.
-      LOG(INFO) << cp.first;
-      cp.second->flush();
-      auto est = cp.second->estimateQuantiles(kQuantiles);
-
-      LOG(INFO) << "Count: " << folly::sformat("{:.0f}", est.count);
-      LOG(INFO) << "Avg: " << est.sum / std::max(1.0, est.count);
-      for (const auto& q : est.quantiles) {
-        LOG(INFO) << folly::sformat("P{:.0f}: {:.2f}", q.first * 100, q.second);
-      }
-    }
-  });
-}
-
-std::shared_ptr<StatisticsManager::Histogram>
-StatisticsManager::getContinuousStat(const std::string& name) {
-  return histo_map_.withWLock([&](auto& m) {
-    auto it = m.find(name);
-
-    if (it != m.end()) {
-      return it->second;
-    } else {
-      // We don't want to construct a counter unless we know the counter isn't
-      // there. That does lead to two reads into the map. Oh well.
-      auto ptr = std::make_shared<StatisticsManager::Histogram>();
-      m.emplace(name, ptr);
-      return ptr;
-    }
-  });
-}
-
-std::shared_ptr<StatisticsManager::Counter> StatisticsManager::getCounterStat(
-    const std::string& name) {
-  return count_map_.withWLock([&](auto& m) {
-    // Try and see if the counter is in the map
-    auto it = m.find(name);
-
-    if (it != m.end()) {
-      return it->second;
-    } else {
-      // We don't want to construct a counter unless we know the counter isn't
-      // there. That does lead to two reads into the map. Oh well.
-      auto ptr = std::make_shared<StatisticsManager::Counter>(name);
-      m.emplace(name, ptr);
-      return ptr;
-    }
-  });
-}
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/StatisticsManager.h treadmill/StatisticsManager.h
--- treadmill-src/StatisticsManager.h	2025-08-11 17:04:00.477209310 -0700
+++ treadmill/StatisticsManager.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,60 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-#include <memory>
-#include <unordered_map>
-
-#include <folly/Synchronized.h>
-#include <folly/stats/QuantileEstimator.h>
-
-#include "treadmill/CounterStatistic.h"
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-// Statistics names are kept here
-const std::string REQUEST_LATENCY = "request_latency";
-const std::string THROUGHPUT = "throughput";
-const std::string OUTSTANDING_REQUESTS = "outstanding_requests";
-const std::string EXCEPTIONS = "exceptions";
-const std::string UNCAUGHT_EXCEPTIONS = "uncaught_exceptions";
-
-class StatisticsManager {
- public:
-  using Histogram = folly::SimpleQuantileEstimator<>;
-  using Counter = CounterStatistic;
-  using HistoMapType =
-      std::unordered_map<std::string, std::shared_ptr<Histogram>>;
-  using CounterMapType =
-      std::unordered_map<std::string, std::shared_ptr<Counter>>;
-
-  StatisticsManager() {}
-  virtual ~StatisticsManager() {}
-
-  void print() const;
-  std::string toJson();
-
-  static std::shared_ptr<StatisticsManager> get();
-  std::shared_ptr<Histogram> getContinuousStat(const std::string& name);
-  std::shared_ptr<Counter> getCounterStat(const std::string& name);
-
-  StatisticsManager(StatisticsManager const&);
-  void operator=(StatisticsManager const&);
-
-  folly::Synchronized<HistoMapType> histo_map_;
-  folly::Synchronized<CounterMapType> count_map_;
-};
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/test/RandomEngineTest.cpp treadmill/test/RandomEngineTest.cpp
--- treadmill-src/test/RandomEngineTest.cpp	2025-08-11 17:04:00.501380983 -0700
+++ treadmill/test/RandomEngineTest.cpp	2025-08-04 15:44:21.794046604 -0700
@@ -12,11 +12,13 @@

 #include "treadmill/RandomEngine.h"

-#include <cmath>
-#include <functional>
-#include <numeric>
-#include <thread>
 #include <vector>
+#include <thread>
+#include <numeric>
+#include <functional>
+#include <cmath>
+
+#include <folly/Memory.h>

 namespace facebook {
 namespace windtunnel {
@@ -88,12 +90,13 @@

 } // namespace

+
 } // namespace treadmill
 } // namespace windtunnel
 } // namespace facebook

 int main(int argc, char* argv[]) {
   testing::InitGoogleTest(&argc, argv);
-  FLAGS_treadmill_random_seed = 0;
+  FLAGS_random_seed = 0;
   return RUN_ALL_TESTS();
 }
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/test/StatisticTest.cpp treadmill/test/StatisticTest.cpp
--- treadmill-src/test/StatisticTest.cpp	1969-12-31 16:00:00.000000000 -0800
+++ treadmill/test/StatisticTest.cpp	2025-08-04 15:44:21.794741454 -0700
@@ -0,0 +1,47 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+#include <gtest/gtest.h>
+
+#include "treadmill/ContinuousStatistic.h"
+
+namespace facebook {
+namespace windtunnel {
+namespace treadmill {
+
+namespace {
+
+TEST(StatisticTest, SimpleAverage) {
+  ContinuousStatistic s("test", 0, 0);
+  for (int i = 0; i < 100; i++) {
+    s.addSample(i + 1);
+  }
+  ASSERT_NEAR(50.5, s.getAverage(), .1);
+}
+
+TEST(StatisticTest, RebinTest) {
+  ContinuousStatistic s_0("stat_0", 0, 0);
+  ContinuousStatistic s_1("stat_1", 0, 0);
+  for (int i = 0; i < 100; i++) {
+    s_0.addSample(i + 1);
+    s_1.addSample(i + 1);
+  }
+  s_0.combine(s_1);
+  ASSERT_NEAR(s_0.getQuantile(0.5), 50, 1.0);
+  ASSERT_NEAR(s_0.getQuantile(0.95), 95, 1.0);
+  ASSERT_NEAR(s_0.getQuantile(0.99), 99, 1.0);
+}
+
+} // namespace
+
+
+}  // namespace treadmill
+}  // namespace windtunnel
+}  // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/TreadmillConst.h treadmill/TreadmillConst.h
--- treadmill-src/TreadmillConst.h	2025-08-11 17:04:00.478123563 -0700
+++ treadmill/TreadmillConst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,20 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-#include <string_view>
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-constexpr std::string_view kUniqueReplayID = "unique_replay_id";
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Treadmill.cpp treadmill/Treadmill.cpp
--- treadmill-src/Treadmill.cpp	2025-08-11 17:04:00.477551128 -0700
+++ treadmill/Treadmill.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,117 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#include <string>
-
-#include <folly/init/Init.h>
-
-#include <gflags/gflags.h>
-#include <glog/logging.h>
-
-// The path to the workload configuration file
-DEFINE_string(
-    config_file,
-    "./examples/flat.json",
-    "The path to the workload configuration file.");
-
-// The hostname of the server
-DEFINE_string(hostname, "localhost", "The host to load test.");
-
-DEFINE_bool(
-    wait_for_target_ready,
-    false,
-    "If true, wait until the target is ready.");
-
-DEFINE_string(
-    counter_name,
-    "",
-    "Counter to compare against threshold (e.g, foo.bar.count).");
-
-DEFINE_int32(
-    counter_threshold,
-    -1,
-    "counter_name value > counter_threshold before sending requests.");
-
-// The number of connections each worker thread handles
-DEFINE_int32(
-    number_of_connections,
-    4,
-    "The number of connections for each thread worker.");
-
-// The total number of workers
-DEFINE_int32(number_of_workers, 1, "The number of workers.");
-
-// The number of keys in the workload
-DEFINE_int64(number_of_keys, 1024, "The number of keys in the workload.");
-
-// The port number to connect
-DEFINE_int32(port, 11211, "The port on the host to connect to.");
-
-DEFINE_int32(control_port, 23456, "Port for TreadmillService remote control.");
-
-// The request per second trying to send
-DEFINE_int32(request_per_second, 1024, "The request per second to send.");
-
-// The total testing time in second
-DEFINE_int32(runtime, 120, "The total runtime in seconds.");
-
-// The max number of requests to have outstanding per worker
-DEFINE_int32(
-    max_outstanding_requests,
-    1000,
-    "The max number of requests to have outstanding per worker.");
-
-// Config filename to pass into the workload in JSON format
-DEFINE_string(
-    config_in_file,
-    "",
-    "Config filename to pass into the workload in JSON format.");
-
-DEFINE_string(
-    config_in_json,
-    "",
-    "Configuration string to be parsed as JSON for the workload. "
-    "If --config_in_file is also specified, "
-    "the configs are merged.");
-
-// Config filename to export from the workload in JSON format
-DEFINE_string(
-    config_out_file,
-    "",
-    "Config filename to export from the workload in JSON format.");
-
-// Comma-separated list of CPU IDs to pin the workers
-DEFINE_string(
-    cpu_affinity,
-    "",
-    "Comma-separated list of CPU IDs to pin the workers.");
-
-DEFINE_int32(server_port, -1, "Port for fb303 server");
-
-DEFINE_int32(
-    worker_shutdown_delay,
-    1,
-    "Seconds to allow for workers to gracefully shutdown");
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-void init(int argc, char* argv[]) {
-  // Set the usage information
-  std::string usage("Treadmill loadtester");
-  gflags::SetUsageMessage(usage);
-
-  folly::init(&argc, &argv);
-}
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/TreadmillFB303.cpp treadmill/TreadmillFB303.cpp
--- treadmill-src/TreadmillFB303.cpp	2025-08-11 17:04:00.478390007 -0700
+++ treadmill/TreadmillFB303.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,267 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#include "TreadmillFB303.h"
-#include "thrift/lib/cpp/util/EnumUtils.h"
-
-#include "Scheduler.h"
-
-#include <memory>
-
-#include <folly/Conv.h>
-#include <folly/Singleton.h>
-#include <thrift/lib/cpp2/server/ThriftServer.h>
-#include "common/services/cpp/TLSConfig.h"
-#include "common/time/ClockGettimeNS.h"
-
-DEFINE_bool(
-    require_configuration_on_resume,
-    false,
-    "If true, 'resume' only when configuration is available");
-DEFINE_bool(
-    enable_watchdog_timer,
-    false,
-    "If true, a watchdog timer will be maintained during a run.");
-
-using fb_status = facebook::fb303::cpp2::fb_status;
-using ::treadmill::RateResponse;
-using ::treadmill::ResumeRequest;
-using ::treadmill::ResumeResponse;
-
-using namespace facebook::services;
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-TreadmillFB303::TreadmillFB303(Scheduler& scheduler)
-    : FacebookBase2("Treadmill"),
-      status_(fb_status::STARTING),
-      aliveSince_(time(nullptr)),
-      scheduler_(scheduler),
-      configuration_(std::make_unique<std::map<std::string, std::string>>()),
-      watchdogDurationSec_(0),
-      lastHeartbeat_(0) {}
-
-TreadmillFB303::~TreadmillFB303() {}
-
-void TreadmillFB303::setStatus(fb_status status) {
-  folly::SharedMutex::WriteHolder guard(mutex_);
-  status_ = status;
-}
-
-fb_status TreadmillFB303::getStatus() {
-  folly::SharedMutex::ReadHolder guard(mutex_);
-  return status_;
-}
-
-void TreadmillFB303::getStatusDetails(std::string& _return) {
-  _return = apache::thrift::util::enumNameOrThrow(getStatus());
-}
-
-int64_t TreadmillFB303::aliveSince() {
-  folly::SharedMutex::ReadHolder guard(mutex_);
-  return aliveSince_;
-}
-
-void TreadmillFB303::getCounters(std::map<std::string, int64_t>& _return) {
-  fb303::FacebookBase2::getCounters(_return);
-}
-
-bool TreadmillFB303::pause() {
-  LOG(INFO) << "TreadmillHandler::pause";
-  scheduler_.pause();
-  watchdogDurationSec_ = 0;
-  return true;
-}
-
-bool TreadmillFB303::resume() {
-  LOG(INFO) << "TreadmillHandler::resume";
-  watchdogUpdate();
-  folly::SharedMutex::ReadHolder guard(mutex_);
-  if (FLAGS_require_configuration_on_resume && configuration_->empty()) {
-    LOG(WARNING) << "refusing resume without configuration";
-    return false;
-  }
-  return scheduler_.resume();
-}
-
-folly::Future<std::unique_ptr<ResumeResponse>> TreadmillFB303::future_resume2(
-    std::unique_ptr<ResumeRequest> req) {
-  // Get the phase name being super paranoid.
-  auto phaseName = req != nullptr ? req->get_phaseName() : "UNKNOWN_PHASE";
-  LOG(INFO) << "TreadmillHandler::resume2 with phase " << phaseName;
-  watchdogUpdate();
-  scheduler_.setPhase(phaseName);
-  auto resp = std::make_unique<ResumeResponse>();
-  auto running = scheduler_.resume();
-  LOG(INFO) << "Scheduler is currently "
-            << (running ? "Running" : "Not Running");
-  resp->success_ref() = running;
-  return folly::makeFuture(std::move(resp));
-}
-
-void TreadmillFB303::setRps(int32_t rps) {
-  LOG(INFO) << "TreadmillHandler::setRps to " << rps;
-  watchdogUpdate();
-  scheduler_.setRps(rps);
-}
-
-void TreadmillFB303::setMaxOutstanding(int32_t max_outstanding) {
-  LOG(INFO) << "TreadmillHandler::setMaxOutstanding to " << max_outstanding;
-  watchdogUpdate();
-  scheduler_.setMaxOutstandingRequests(max_outstanding);
-}
-
-folly::Future<std::unique_ptr<::treadmill::RateResponse>>
-TreadmillFB303::future_getRate() {
-  auto response = std::make_unique<RateResponse>();
-  response->scheduler_running_ref() = scheduler_.isRunning();
-  response->rps_ref() = scheduler_.getRps();
-  response->max_outstanding_ref() = scheduler_.getMaxOutstandingRequests();
-  return folly::makeFuture(std::move(response));
-}
-
-folly::Future<std::unique_ptr<std::string>>
-TreadmillFB303::future_getConfiguration(std::unique_ptr<std::string> key) {
-  LOG(INFO) << "TreadmillHandler::getConfiguration: " << *key;
-  watchdogUpdate();
-
-  folly::SharedMutex::ReadHolder guard(mutex_);
-  if (configuration_->count(*key) > 0) {
-    auto value = std::make_unique<std::string>(configuration_->at(*key));
-    LOG(INFO) << "returning " << *key << " = " << *value;
-    return folly::makeFuture(std::move(value));
-  }
-  auto value = std::make_unique<std::string>();
-  return folly::makeFuture(std::move(value));
-}
-
-void TreadmillFB303::setConfiguration(
-    std::unique_ptr<std::string> key,
-    std::unique_ptr<std::string> value) {
-  LOG(INFO) << "TreadmillHandler::setConfiguration: " << *key << " = "
-            << *value;
-  watchdogUpdate();
-
-  folly::SharedMutex::WriteHolder guard(mutex_);
-  configuration_->insert_or_assign(*key, *value);
-  if (FLAGS_enable_watchdog_timer && *key == "watchdog_sec") {
-    LOG(INFO) << "TreadmillHandler::watchdog timer value (secs) = " << *value;
-    if (auto result = folly::tryTo<uint32_t>(*value)) {
-      watchdogDurationSec_ = result.value();
-    } else {
-      watchdogDurationSec_ = 0; // disabled
-    }
-  }
-}
-
-uint32_t TreadmillFB303::getConfigurationValue(
-    const std::string& key,
-    uint32_t defaultValue) {
-  folly::SharedMutex::ReadHolder guard(mutex_);
-  if (configuration_->count(key) > 0) {
-    auto value = std::make_unique<std::string>(configuration_->at(key));
-    if (auto result = folly::tryTo<uint32_t>(*value)) {
-      return result.value();
-    }
-    LOG(WARNING) << "failed to convert value [" << *value << "]";
-    // fall through
-  }
-  return defaultValue;
-}
-
-std::unique_ptr<std::string> TreadmillFB303::getConfigurationValue(
-    const std::string& key,
-    const std::string& defaultValue) {
-  folly::SharedMutex::ReadHolder guard(mutex_);
-  if (configuration_->count(key) > 0) {
-    return std::make_unique<std::string>(configuration_->at(key));
-  } else {
-    return std::make_unique<std::string>(defaultValue);
-  }
-}
-
-void TreadmillFB303::clearConfiguration() {
-  LOG(INFO) << "TreadmillHandler::clearConfiguration";
-  watchdogUpdate();
-  folly::SharedMutex::WriteHolder guard(mutex_);
-  configuration_->clear();
-}
-
-bool TreadmillFB303::configurationEmpty() const {
-  folly::SharedMutex::ReadHolder guard(mutex_);
-  return configuration_->empty();
-}
-
-void TreadmillFB303::watchdogUpdate() {
-  if (FLAGS_enable_watchdog_timer && watchdogDurationSec_ > 0) {
-    lastHeartbeat_ = fb_time_seconds();
-    LOG(INFO) << "watchdog update = " << lastHeartbeat_;
-  }
-}
-
-bool TreadmillFB303::watchdogTimeoutCheck(bool raise) {
-  if (FLAGS_enable_watchdog_timer && watchdogDurationSec_ > 0) {
-    time_t now = fb_time_seconds();
-    if (now - watchdogDurationSec_ > lastHeartbeat_) {
-      LOG(WARNING) << "watchdog timeout: no contact since " << lastHeartbeat_;
-      if (raise) {
-        abort();
-      }
-      return true;
-    }
-  }
-  return false;
-}
-
-namespace {
-folly::SharedMutex instance_mutex;
-std::shared_ptr<TreadmillFB303> instance;
-} // namespace
-
-std::shared_ptr<TreadmillFB303> getGlobalTreadmillFB303() {
-  folly::SharedMutex::ReadHolder guard(instance_mutex);
-  if (!instance) {
-    LOG(FATAL) << "No global Treadmill FB303 instance set";
-  }
-
-  return instance;
-}
-
-void TreadmillFB303::make_fb303(
-    std::shared_ptr<std::thread>& server_thread,
-    int server_port,
-    Scheduler& scheduler) {
-  {
-    folly::SharedMutex::WriteHolder guard(instance_mutex);
-    if (instance) {
-      LOG(FATAL) << "Global Treadmill FB303 instance was already set";
-    }
-    instance = std::make_shared<TreadmillFB303>(scheduler);
-  }
-
-  auto server = std::make_shared<apache::thrift::ThriftServer>();
-  LOG(INFO) << "FB303 running on port " << server_port;
-  server->setPort(server_port);
-  server->setInterface(getGlobalTreadmillFB303());
-  TLSConfig::applyDefaultsToThriftServer(*server);
-  server_thread.reset(
-      new std::thread([server]() { server->serve(); }),
-      [server](std::thread* t) {
-        server->stop();
-        t->join();
-        delete t;
-      });
-}
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/TreadmillFB303.h treadmill/TreadmillFB303.h
--- treadmill-src/TreadmillFB303.h	2025-08-11 17:04:00.478622738 -0700
+++ treadmill/TreadmillFB303.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,83 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-#include <folly/SharedMutex.h>
-
-#include "common/fb303/cpp/FacebookBase2.h"
-#include "treadmill/if/gen-cpp2/TreadmillService.h"
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-class Scheduler;
-
-class TreadmillFB303 : public facebook::fb303::FacebookBase2,
-                       public ::treadmill::TreadmillServiceSvIf {
- public:
-  using fb_status = facebook::fb303::cpp2::fb_status;
-
-  explicit TreadmillFB303(Scheduler& scheduler);
-
-  ~TreadmillFB303() override;
-
-  void setStatus(fb_status status);
-  fb_status getStatus() override;
-
-  void getStatusDetails(std::string& _return) override;
-  int64_t aliveSince() override;
-  void getCounters(std::map<std::string, int64_t>& _return) override;
-
-  bool pause() override;
-  bool resume() override;
-  folly::Future<std::unique_ptr<::treadmill::ResumeResponse>> future_resume2(
-      std::unique_ptr<::treadmill::ResumeRequest> req) override;
-  void setRps(int32_t rps) override;
-  void setMaxOutstanding(int32_t max_outstanding) override;
-  folly::Future<std::unique_ptr<::treadmill::RateResponse>> future_getRate()
-      override;
-
-  folly::Future<std::unique_ptr<std::string>> future_getConfiguration(
-      std::unique_ptr<std::string> key) override;
-  void setConfiguration(
-      std::unique_ptr<std::string> key,
-      std::unique_ptr<std::string> value) override;
-  uint32_t getConfigurationValue(const std::string& key, uint32_t defaultValue);
-  std::unique_ptr<std::string> getConfigurationValue(
-      const std::string& key,
-      const std::string& defaultValue);
-  void clearConfiguration() override;
-  bool configurationEmpty() const;
-
-  void watchdogUpdate();
-  bool watchdogTimeoutCheck(bool raise = true);
-
-  static void make_fb303(
-      std::shared_ptr<std::thread>& server_thread,
-      int server_port,
-      Scheduler& scheduler);
-
- private:
-  fb_status status_;
-  const int64_t aliveSince_;
-  folly::SharedMutex mutex_;
-  Scheduler& scheduler_;
-  std::unique_ptr<std::map<std::string, std::string>> configuration_;
-  uint32_t watchdogDurationSec_;
-  time_t lastHeartbeat_;
-};
-
-extern std::shared_ptr<TreadmillFB303> getGlobalTreadmillFB303();
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Treadmill.h treadmill/Treadmill.h
--- treadmill-src/Treadmill.h	2025-08-11 17:04:00.477845713 -0700
+++ treadmill/Treadmill.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,270 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-#include <string>
-#include <thread>
-#include <vector>
-
-#include <folly/String.h>
-#include <folly/futures/Future.h>
-#include <folly/json.h>
-#include <gflags/gflags.h>
-#include <glog/logging.h>
-
-#include "common/stats/ServiceData.h"
-#include "treadmill/Scheduler.h"
-#include "treadmill/TreadmillFB303.h"
-#include "treadmill/Worker.h"
-
-#include "common/fb303/cpp/FacebookBase2.h"
-#include "common/services/cpp/ServiceFramework.h"
-#include "thrift/lib/cpp2/server/ThriftServer.h"
-#include "treadmill/if/gen-cpp2/TreadmillService.h"
-
-// The path to the workload configuration file
-DECLARE_string(config_file);
-
-// The hostname of the server
-DECLARE_string(hostname);
-
-DECLARE_string(counter_name);
-
-DECLARE_int32(counter_threshold);
-
-// The number of connections each worker thread handles
-DECLARE_int32(number_of_connections);
-
-// The total number of workers
-DECLARE_int32(number_of_workers);
-
-// The number of keys in the workload
-DECLARE_int64(number_of_keys);
-
-// The port number to connect
-DECLARE_int32(port);
-
-DECLARE_int32(control_port);
-
-// The request per second trying to send
-DECLARE_int32(request_per_second);
-
-// The total testing time in second
-DECLARE_int32(runtime);
-
-// The file to store the JSON output statistics
-DECLARE_string(output_file);
-
-// The max number of requests to have outstanding per worker
-DECLARE_int32(max_outstanding_requests);
-
-// Config filename to pass into the workload in JSON format
-DECLARE_string(config_in_file);
-
-// Config string to pass into the workload in JSON format
-DECLARE_string(config_in_json);
-
-// Config filename to export from the workload in JSON format
-DECLARE_string(config_out_file);
-
-// Comma-separated list of CPU IDs to pin the workers
-DECLARE_string(cpu_affinity);
-
-// Default number of calibration samples for continuous statistics
-DECLARE_int32(default_calibration_samples);
-
-// Default number of warm-up samples for continuous statistics
-DECLARE_int32(default_warmup_samples);
-
-// Number of calibration samples for latency statistics
-DECLARE_int32(latency_calibration_samples);
-
-// Number of warm-up samples for latency statistics
-DECLARE_int32(latency_warmup_samples);
-
-// Port for fb303 server
-DECLARE_int32(server_port);
-
-// How many seconds to give workers to finish requests
-DECLARE_int32(worker_shutdown_delay);
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-template <class Service>
-class TreadmillRunner {
- public:
-  TreadmillRunner() {
-    rps = FLAGS_request_per_second / (double)FLAGS_number_of_workers;
-    max_outstanding_requests_per_worker =
-        FLAGS_max_outstanding_requests / FLAGS_number_of_workers;
-    config = folly::dynamic::object;
-    scheduler = std::make_unique<Scheduler>(
-        FLAGS_request_per_second,
-        FLAGS_number_of_workers,
-        FLAGS_max_outstanding_requests,
-        max_outstanding_requests_per_worker);
-    cpu_affinity_list = std::vector<int>(FLAGS_number_of_workers, -1);
-    terminate_early_fn = [&scheduler = scheduler]() { scheduler->stop(); };
-  }
-  virtual ~TreadmillRunner(){};
-  /**
-   * Press start to rock
-   *
-   * @param argc Argument count
-   * @param argv Argument vector
-   */
-  int run(int /*argc*/, char* /*argv*/[]) {
-    LOG(INFO) << "Desired rps per worker: " << rps;
-    LOG(INFO) << "Max outstanding requests per worker: "
-              << max_outstanding_requests_per_worker;
-    LOG(INFO) << "N Workers: " << FLAGS_number_of_workers;
-    LOG(INFO) << "N Connections: " << FLAGS_number_of_connections;
-    if (FLAGS_config_in_file != "") {
-      config = readDynamicFromFile(FLAGS_config_in_file);
-    }
-    if (FLAGS_config_in_json != "") {
-      folly::dynamic config2 = folly::parseJson(FLAGS_config_in_json);
-      config.update(config2);
-    }
-
-    if (FLAGS_cpu_affinity != "") {
-      int total_number_of_cores = std::thread::hardware_concurrency();
-      std::vector<folly::StringPiece> affinity_string_list;
-      folly::split(",", FLAGS_cpu_affinity, affinity_string_list);
-      if (affinity_string_list.size() != FLAGS_number_of_workers) {
-        LOG(FATAL) << "Length of the CPU affinity list ("
-                   << affinity_string_list.size()
-                   << ") does not match the number of workers ("
-                   << FLAGS_number_of_workers << ")";
-      } else {
-        for (int i = 0; i < FLAGS_number_of_workers; i++) {
-          int cpu_affinity = folly::to<int>(affinity_string_list[i]);
-          if (cpu_affinity >= 0 && cpu_affinity < total_number_of_cores) {
-            cpu_affinity_list[i] = cpu_affinity;
-          } else {
-            LOG(FATAL) << "Core " << cpu_affinity << " does not exist";
-          }
-        }
-      }
-    }
-
-    // Init fb303
-    std::shared_ptr<std::thread> server_thread;
-    if (FLAGS_server_port > 0) {
-      TreadmillFB303::make_fb303(server_thread, FLAGS_server_port, *scheduler);
-    }
-    initializeWorkers();
-
-    // Start testing
-    for (int i = 0; i < FLAGS_number_of_workers; i++) {
-      workers[i]->run();
-    }
-
-    // Start the test and wait for it to finish.
-    std::vector<folly::SemiFuture<folly::Unit>> futs;
-    futs.push_back(scheduler->run());
-    futs.push_back(folly::futures::sleep(std::chrono::seconds(FLAGS_runtime)));
-    folly::collectAny(futs).wait();
-
-    LOG(INFO) << "Stopping and joining scheduler thread";
-    scheduler->stop();
-    scheduler->join();
-
-    if (FLAGS_worker_shutdown_delay > 0) {
-      // Wait for workers to finish requests
-      size_t secondsToWait = FLAGS_worker_shutdown_delay;
-      size_t remaining;
-      do {
-        remaining = 0;
-        for (auto& it : workers) {
-          if (it->hasMoreWork())
-            remaining++;
-        }
-        if (remaining > 0) {
-          LOG(INFO) << "waiting for " << remaining << " worker(s)";
-          sleep(1);
-          --secondsToWait;
-        }
-      } while (secondsToWait > 0 && remaining > 0);
-    }
-
-    StatisticsManager::get()->print();
-    LOG(INFO) << "Stopping workers";
-
-    // We already stored stats, so just drop all remaining scheduled request.
-    for (int i = 0; i < FLAGS_number_of_workers; i++) {
-      workers[i]->stop();
-    }
-
-    LOG(INFO) << "Joining worker threads";
-
-    // Join worker threads
-    for (int i = 0; i < FLAGS_number_of_workers; i++) {
-      workers[i]->join();
-    }
-    if (FLAGS_config_out_file != "") {
-      LOG(INFO) << "Saving config";
-      std::vector<Worker<Service>*> workerRefs;
-      for (auto& worker : workers) {
-        workerRefs.push_back(worker.get());
-      }
-      auto config_output = workers[0]->makeConfigOutputs(workerRefs);
-      writeDynamicToFile(FLAGS_config_out_file, config_output);
-    }
-    auto counters = stats::ServiceData::get()->getCounters();
-    for (auto& pair : counters) {
-      LOG(INFO) << pair.first << ": " << pair.second;
-    }
-
-    LOG(INFO) << "Complete";
-
-    return 0;
-  }
-
-  virtual void initializeWorkers() {
-    for (int i = 0; i < FLAGS_number_of_workers; i++) {
-      workers.push_back(std::make_unique<Worker<Service>>(
-          i,
-          scheduler->getWorkerQueue(i),
-          FLAGS_number_of_workers,
-          FLAGS_number_of_connections,
-          max_outstanding_requests_per_worker,
-          config,
-          cpu_affinity_list[i],
-          terminate_early_fn));
-    }
-  }
-
- protected:
-  std::vector<std::unique_ptr<Worker<Service>>> workers;
-  std::unique_ptr<Scheduler> scheduler;
-  int max_outstanding_requests_per_worker;
-  folly::dynamic config;
-  std::vector<int> cpu_affinity_list;
-  std::function<void()> terminate_early_fn;
-
- private:
-  double rps;
-};
-
-void init(int argc, char* argv[]);
-
-template <class Service>
-int run(int argc, char* argv[]) {
-  TreadmillRunner runner = TreadmillRunner<Service>();
-  return runner.run(argc, argv);
-};
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Util.cpp treadmill/Util.cpp
--- treadmill-src/Util.cpp	2025-08-11 17:04:00.478860087 -0700
+++ treadmill/Util.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,208 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#include "treadmill/Util.h"
-
-#include <arpa/inet.h>
-#include <netdb.h>
-#include <fstream>
-#include <sstream>
-
-#include <sys/time.h>
-
-#include <folly/json.h>
-#include <glog/logging.h>
-
-using std::string;
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-// The number of attempts to get host information
-const int kNumberOfAttempts = 3;
-
-int64_t nowNs() {
-  struct timespec ts;
-  int r = clock_gettime(CLOCK_MONOTONIC, &ts);
-  PCHECK(r == 0);
-  return (ts.tv_nsec + ts.tv_sec * k_ns_per_s);
-}
-
-bool writeStringToFile(std::string txt, std::string filename) {
-  std::ofstream os(filename);
-  try {
-    os.exceptions(std::ofstream::failbit | std::ofstream::badbit);
-    os << txt;
-    os.close();
-  } catch (std::exception const& e) {
-    LOG(ERROR) << "Failed to write file " << e.what();
-    return false;
-  }
-
-  return true;
-}
-
-bool readFileToString(std::string filename, std::string& txt) {
-  std::ifstream is(filename.c_str());
-  try {
-    is.exceptions(std::ifstream::failbit | std::ifstream::badbit);
-
-    std::stringstream buffer;
-    buffer << is.rdbuf();
-    is.close();
-    txt = buffer.str();
-  } catch (std::exception const& e) {
-    LOG(ERROR) << "Failed to read file " << e.what();
-    return false;
-  }
-
-  return true;
-}
-
-void writeDynamicToFile(std::string filename, folly::dynamic object) {
-  std::string json = folly::toJson(object);
-  if (!writeStringToFile(json, filename)) {
-    LOG(FATAL) << "Open to read failed: " << filename;
-  }
-}
-
-folly::dynamic readDynamicFromFile(std::string filename) {
-  std::string s;
-  if (!readFileToString(filename, s)) {
-    LOG(FATAL) << "Open to read failed: " << filename;
-  }
-  return folly::parseJson(s);
-}
-
-/**
- * Read a line from the file descriptor
- *
- * @param fd The file descriptor
- * @param buffer The buffer to write
- * @param buffer_size The size of the read buffer
- * @return The total amount of bytes read
- */
-int readLine(int fd, char* buffer, int buffer_size) {
-  int total_bytes_read = 0;
-  do {
-    read(fd, buffer + total_bytes_read, 1);
-    total_bytes_read++;
-  } while (total_bytes_read < buffer_size &&
-           (buffer[total_bytes_read - 2] != '\r' ||
-            buffer[total_bytes_read - 1] != '\n'));
-  return total_bytes_read;
-}
-
-/**
- * Read from block given the file descriptor
- *
- * @param fd The file descriptor
- * @param buffer The buffer to write
- * @param buffer_size The size of the read buffer
- */
-void readBlock(int fd, char* buffer, int buffer_size) {
-  int total_bytes_read = 0;
-  while (total_bytes_read != buffer_size) {
-    int bytes_read =
-        read(fd, buffer + total_bytes_read, buffer_size - total_bytes_read);
-    // Read syscall failed.
-    if (bytes_read < 0) {
-      string sys_error = string(strerror(errno));
-      LOG(FATAL) << "Read syscall failed: " + sys_error;
-    }
-    total_bytes_read += bytes_read;
-  }
-
-  // Make sure all bytes have been read from the fd.
-  if (total_bytes_read < buffer_size) {
-    LOG(FATAL) << "Read loop exited before all bytes were written."
-                  "This should never happen";
-  }
-}
-
-/**
- * Write to block given the file descriptor
- *
- * @param fd The file descriptor
- * @param buffer The buffer to write
- * @param buffer_size The size of the write buffer
- */
-void writeBlock(int fd, const char* buffer, int buffer_size) {
-  int total_bytes_written = 0;
-  while (total_bytes_written != buffer_size) {
-    int bytes_written = write(
-        fd, buffer + total_bytes_written, buffer_size - total_bytes_written);
-    // Write syscall failed.
-    if (bytes_written < 0) {
-      LOG(INFO) << "Attempted write size "
-                << (buffer_size - total_bytes_written);
-      string sys_error = string(strerror(errno));
-      LOG(FATAL) << "Write syscall failed: " + sys_error;
-    }
-    total_bytes_written += bytes_written;
-  }
-}
-
-double time_s() {
-  struct timeval time_stamp = {0, 0};
-  gettimeofday(&time_stamp, nullptr);
-  return time_stamp.tv_sec + time_stamp.tv_usec * 1e-6;
-}
-
-/**
- * Loop up the IP address given hostname; return the first ip address
- * returned by getaddrinfo; if error occurs, return non-zero error code.
- *
- * @param hostname Hostname for the server in string, support ipv4 & ipv6
- * @return IP address under the hostname in string
- */
-std::string nsLookUp(const string& hostname) {
-  string ret;
-  struct addrinfo hints;
-  struct addrinfo* res;
-  memset(&hints, 0, sizeof(hints));
-  hints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */
-
-  int error = -1;
-  for (int attempt = 0; (error != 0) && (attempt < kNumberOfAttempts);
-       attempt++) {
-    error = getaddrinfo(hostname.c_str(), nullptr, &hints, &res);
-  }
-
-  if (error == 0) {
-    int len = res->ai_addrlen;
-
-    if (res->ai_addr->sa_family == AF_INET) {
-      // IPv4
-      char ip_address[INET_ADDRSTRLEN];
-      struct sockaddr_in* addr = (struct sockaddr_in*)res->ai_addr;
-      inet_ntop(AF_INET, &(addr->sin_addr.s_addr), ip_address, INET_ADDRSTRLEN);
-      ret = string(ip_address);
-    } else {
-      // IPv6
-      char ip_address[INET6_ADDRSTRLEN];
-      struct sockaddr_in6* addr = (struct sockaddr_in6*)res->ai_addr;
-      inet_ntop(
-          AF_INET6, &(addr->sin6_addr.s6_addr), ip_address, INET6_ADDRSTRLEN);
-      ret = string(ip_address);
-    }
-    freeaddrinfo(res);
-  } else {
-    LOG(FATAL) << "DNS error: " << gai_strerror(error);
-    exit(error);
-  }
-
-  return ret;
-}
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Util.h treadmill/Util.h
--- treadmill-src/Util.h	2025-08-11 17:04:00.479121743 -0700
+++ treadmill/Util.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,69 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-#include <random>
-
-#include <folly/dynamic.h>
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-// Number of nanoseconds in one second.
-constexpr int64_t k_ns_per_s = 1000000000;
-
-/**
- * Get current time according to CLOCK_MONOTONIC.
- *
- * @return current time in nanoseconds.
- */
-int64_t nowNs();
-
-void writeDynamicToFile(std::string filename, folly::dynamic);
-
-folly::dynamic readDynamicFromFile(std::string filename);
-
-/**
- * Read a line from the file descriptor
- *
- * @param fd The file descriptor
- * @param buffer The buffer to write
- * @param buffer_size The size of the read buffer
- * @return The total amount of bytes read
- */
-int readLine(int fd, char* buffer, int buffer_size);
-
-/**
- * Read from block given the file descriptor
- *
- * @param fd The file descriptor
- * @param buffer The buffer to write
- * @param buffer_size The size of the read buffer
- */
-void readBlock(int fd, char* buffer, int buffer_size);
-
-/**
- * Write to block given the file descriptor
- *
- * @param fd The file descriptor
- * @param buffer The buffer to write
- * @param buffer_size The size of the write buffer
- */
-void writeBlock(int fd, const char* buffer, int buffer_size);
-
-std::string nsLookUp(const std::string& hostname);
-
-double time_s();
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Worker.h treadmill/Worker.h
--- treadmill-src/Worker.h	2025-08-11 17:04:00.479414897 -0700
+++ treadmill/Worker.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,324 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-#include <sched.h>
-
-#include <memory>
-#include <thread>
-
-#include <glog/logging.h>
-
-#include <folly/Memory.h>
-#include <folly/MoveWrapper.h>
-#include <folly/String.h>
-#include <folly/futures/Future.h>
-#include <folly/io/async/EventBase.h>
-#include <folly/io/async/NotificationQueue.h>
-#include <folly/system/ThreadName.h>
-
-#include "treadmill/Connection.h"
-#include "treadmill/Event.h"
-#include "treadmill/StatisticsManager.h"
-#include "treadmill/Util.h"
-#include "treadmill/Workload.h"
-
-DECLARE_bool(wait_for_target_ready);
-DECLARE_string(counter_name);
-DECLARE_int32(counter_threshold);
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-constexpr folly::StringPiece kOutstandingRequestsCounter =
-    "outstanding_requests";
-
-template <class Service>
-class Worker : private folly::NotificationQueue<Event>::Consumer {
- public:
-  Worker(
-      int worker_id,
-      folly::NotificationQueue<Event>& queue,
-      int number_of_workers,
-      int number_of_connections,
-      int max_outstanding_requests,
-      const folly::dynamic& config,
-      int cpu_affinity,
-      std::function<void()> terminate_early_fn)
-      : worker_id_(worker_id),
-        number_of_workers_(number_of_workers),
-        number_of_connections_(number_of_connections),
-        max_outstanding_requests_(max_outstanding_requests),
-        workload_(config),
-        cpu_affinity_(cpu_affinity),
-        queue_(queue),
-        terminate_early_fn_(terminate_early_fn) {
-    for (int i = 0; i < number_of_connections_; i++) {
-      connections_.push_back(
-          std::make_unique<Connection<Service>>(event_base_));
-    }
-
-    setWorkerCounter(kOutstandingRequestsCounter, 0);
-  }
-
-  Worker(
-      int worker_id,
-      folly::NotificationQueue<Event>& queue,
-      int number_of_workers,
-      int number_of_connections,
-      int max_outstanding_requests,
-      const folly::dynamic& config,
-      int cpu_affinity,
-      std::function<void()> terminate_early_fn,
-      Workload<Service> workload)
-      : Worker(
-            worker_id,
-            queue,
-            number_of_workers,
-            number_of_connections,
-            max_outstanding_requests,
-            config,
-            cpu_affinity,
-            terminate_early_fn) {
-    workload_ = workload;
-  }
-
-  ~Worker() override {}
-
-  void run() {
-    // If countername is specified then make sure wait_for_target was also true
-    if (!FLAGS_counter_name.empty() &&
-        (!FLAGS_wait_for_target_ready || FLAGS_counter_threshold < 0)) {
-      LOG(FATAL) << "--counter_name " << FLAGS_counter_name
-                 << " specified without --wait_for_target_ready"
-                 << " or valid --counter_threshold value";
-    }
-
-    if (FLAGS_wait_for_target_ready) {
-      for (auto& conn : connections_) {
-        while (!conn->isReady()) {
-          LOG(INFO) << "Target not ready";
-          /* sleep override */ sleep(1);
-        }
-      }
-      LOG(INFO) << "Target is ready";
-    }
-
-    running_.store(true, std::memory_order_relaxed);
-    sender_thread_ =
-        std::make_unique<std::thread>([this] { this->senderLoop(); });
-  }
-
-  void stop() {
-    running_.store(false);
-    auto stopper = [this]() { event_base_.terminateLoopSoon(); };
-    event_base_.runInEventBaseThread(stopper);
-    LOG(INFO) << "Worker " << worker_id_ << " terminating";
-  }
-
-  void join() {
-    sender_thread_->join();
-  }
-
-  bool hasMoreWork() {
-    return running_ || outstanding_requests_ > 0;
-  }
-
-  folly::dynamic makeConfigOutputs(std::vector<Worker*> worker_refs) {
-    std::vector<Workload<Service>*> workload_refs;
-    for (auto worker : worker_refs) {
-      workload_refs.push_back(&(worker->workload_));
-    }
-    return workload_.makeConfigOutputs(workload_refs);
-  }
-
- private:
-  void setWorkerCounter(folly::StringPiece key, int64_t value) {
-    std::string fullKey = folly::sformat("worker.{}.{}", worker_id_, key);
-
-    auto sd = facebook::stats::ServiceData::get();
-    sd->setCounter(fullKey, value);
-  }
-
-  void setMaxOutstanding(int32_t max_outstanding_requests) {
-    max_outstanding_requests_ = max_outstanding_requests;
-  }
-
-  /**
-   * Sender loop listens to the request queue and network events.
-   * It will only send up to the outstanding requests limit.
-   */
-  void senderLoop() {
-    folly::setThreadName("treadmill-wrkr");
-    if (cpu_affinity_ != -1) {
-      cpu_set_t mask;
-      CPU_ZERO(&mask);
-      CPU_SET(cpu_affinity_, &mask);
-      if (sched_setaffinity(0, sizeof(cpu_set_t), &mask)) {
-        LOG(ERROR) << "Failed to set CPU affinity";
-      }
-    }
-    auto manager = StatisticsManager::get();
-    outstanding_statistic_ = manager->getContinuousStat(OUTSTANDING_REQUESTS);
-    throughput_statistic_ = manager->getContinuousStat(THROUGHPUT);
-    latency_statistic_ = manager->getContinuousStat(REQUEST_LATENCY);
-    exceptions_statistic_ = manager->getCounterStat(EXCEPTIONS);
-    uncaught_exceptions_statistic_ =
-        manager->getCounterStat(UNCAUGHT_EXCEPTIONS);
-    last_throughput_time_ = nowNs();
-
-    startConsuming(&event_base_, &queue_);
-    event_base_.loopForever();
-  }
-
-  void messageAvailable(Event&& event) noexcept override {
-    if (event.getEventType() == EventType::STOP || !running_) {
-      LOG(INFO) << "Stopping Worker because "
-                << ((event.getEventType() == EventType::STOP)
-                        ? "Event Type = Stop"
-                        : "running_ = false but got a message.");
-      stopConsuming();
-      // To avoid potential race condition
-      running_.store(false);
-    } else if (event.getEventType() == EventType::RESET) {
-      LOG(INFO) << "Got EventType::RESET";
-      workload_.reset();
-    } else if (event.getEventType() == EventType::SEND_REQUEST) {
-      sendRequest();
-    } else if (event.getEventType() == EventType::SET_MAX_OUTSTANDING) {
-      auto extraData = event.getExtraData();
-      if (!extraData.isInt()) {
-        LOG(ERROR) << "SET_MAX_OUTSTANDING event not an int: " << extraData;
-      } else {
-        LOG(INFO) << "Got EventType::SET_MAX_OUTSTANDING = "
-                  << extraData.asInt();
-        setMaxOutstanding(extraData.asInt());
-      }
-    } else if (event.getEventType() == EventType::SET_PHASE) {
-      auto extraData = event.getExtraData();
-      if (!extraData.isString()) {
-        LOG(ERROR) << "SET_PHASE event got invalid extra data: " << extraData;
-      } else {
-        LOG(INFO) << "Got EventType::SET_PHASE = " << extraData.asString();
-        workload_.setPhase(extraData.asString());
-      }
-    } else {
-      LOG(ERROR) << "Got unhandled event: " << int(event.getEventType());
-    }
-  }
-
-  void sendRequest() {
-    if (outstanding_requests_ < max_outstanding_requests_ && running_) {
-      auto request_tuple = workload_.getNextRequest();
-      if (std::get<0>(request_tuple) == nullptr) {
-        LOG(INFO) << "terminating";
-        running_.store(false);
-        terminate_early_fn_();
-        return;
-      }
-      auto pw = folly::makeMoveWrapper(std::move(std::get<1>(request_tuple)));
-      ++outstanding_requests_;
-      auto conn_idx = conn_idx_;
-      conn_idx_ = (conn_idx_ + 1) % number_of_connections_;
-      auto send_time = nowNs();
-
-      auto reply =
-          connections_[conn_idx]
-              ->sendRequest(std::move(std::get<0>(request_tuple)))
-              .thenTry([send_time, this, pw](
-                           folly::Try<typename Service::Reply>&& t) mutable {
-                auto recv_time = nowNs();
-                if (running_) {
-                  // If the worker is not in running state, latency stat have
-                  // already been released
-                  latency_statistic_->addValue(
-                      (recv_time - send_time) / 1000.0);
-                }
-                n_throughput_requests_++;
-                if (t.hasException()) {
-                  n_exceptions_by_type_
-                      [t.exception().class_name().toStdString()]++;
-                  LOG(INFO) << t.exception().what();
-                  pw->setException(t.exception());
-                }
-                if (t.hasValue()) {
-                  pw->setValue(std::move(t.value()));
-                }
-
-                --outstanding_requests_;
-                this->setWorkerCounter(
-                    kOutstandingRequestsCounter, outstanding_requests_);
-              });
-      auto& f = std::get<2>(request_tuple);
-      std::move(f).thenError([this](folly::exception_wrapper ew) {
-        n_uncaught_exceptions_by_type_[ew.class_name().toStdString()]++;
-        return folly::makeFuture<
-            typename std::remove_reference<decltype(f)>::type::value_type>(ew);
-      });
-    }
-
-    // Estimate throughput and outstanding requests
-    auto t = nowNs();
-    double throughput_delta = double(t - last_throughput_time_) / k_ns_per_s;
-    if (throughput_delta >= 0.1) {
-      double throughput =
-          n_throughput_requests_ / throughput_delta * number_of_workers_;
-      throughput_statistic_->addValue(throughput);
-      n_throughput_requests_ = 0;
-      last_throughput_time_ = t;
-      double outstanding = outstanding_requests_ * number_of_workers_;
-      outstanding_statistic_->addValue(outstanding);
-    }
-
-    for (auto p : n_exceptions_by_type_) {
-      exceptions_statistic_->increase(p.second, p.first);
-    }
-    n_exceptions_by_type_.clear();
-
-    for (auto p : n_uncaught_exceptions_by_type_) {
-      uncaught_exceptions_statistic_->increase(p.second, p.first);
-    }
-    n_uncaught_exceptions_by_type_.clear();
-
-    setWorkerCounter(kOutstandingRequestsCounter, outstanding_requests_);
-  }
-
-  const int worker_id_;
-  std::vector<std::unique_ptr<Connection<Service>>> connections_;
-  folly::EventBase event_base_;
-  std::atomic<bool> running_;
-  int number_of_workers_;
-  int number_of_connections_;
-  int32_t max_outstanding_requests_;
-  Workload<Service> workload_;
-  int cpu_affinity_;
-  int64_t last_throughput_time_{0};
-  std::atomic<int64_t> n_throughput_requests_{0};
-  std::unordered_map<std::string, size_t> n_exceptions_by_type_;
-  std::unordered_map<std::string, size_t> n_uncaught_exceptions_by_type_;
-
-  folly::NotificationQueue<Event>& queue_;
-  std::unique_ptr<std::thread> sender_thread_;
-  size_t conn_idx_{0};
-  std::atomic<int64_t> outstanding_requests_{0};
-  std::shared_ptr<StatisticsManager::Histogram> latency_statistic_{nullptr};
-  std::shared_ptr<StatisticsManager::Histogram> outstanding_statistic_{nullptr};
-  std::shared_ptr<StatisticsManager::Histogram> throughput_statistic_{nullptr};
-  std::shared_ptr<StatisticsManager::Counter> exceptions_statistic_{nullptr};
-  std::shared_ptr<StatisticsManager::Counter> uncaught_exceptions_statistic_{
-      nullptr};
-  std::function<void()> terminate_early_fn_;
-};
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
diff -wbBdu -ruN '--exclude=.git' '--exclude=*.rej' '--exclude=*.orig' '--exclude=gen-cpp2' '--exclude=build' '--exclude=third_party' treadmill-src/Workload.h treadmill/Workload.h
--- treadmill-src/Workload.h	2025-08-11 17:04:00.479733008 -0700
+++ treadmill/Workload.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,54 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-
-#pragma once
-
-namespace facebook {
-namespace windtunnel {
-namespace treadmill {
-
-template <class Workload>
-class WorkloadBase {
- public:
-  void setPhase(const std::string& phase) {
-    phase_ = phase;
-  }
-  const std::string getPhase() const {
-    return phase_;
-  }
-
- protected:
-  std::string phase_;
-};
-
-template <class Service>
-class Workload {
-  /**
-   * Workloads are implemented as template specializations that derive from
-   * WorkloadBase using themselves as template parameter. Example:
-   *   class Workload<MyService> : BaseWorkload<Workload<MyService>> {...};
-   *
-   * Any specialization of Workload must implement the following functions:
-   *  explicit Workload<Service>(folly::dynamic config)
-   *  void reset() - to reset their internal state. (Used via Scheduler::resume
-   *                 to re-synchronize A/B sides after pausing.)
-   *  std::tuple<
-   *              std::unique_ptr<HhvmHttpReplayService::Request>,
-   *              folly::Promise<HhvmHttpReplayService::Reply>,
-   *              folly::Future<HhvmHttpReplayService::Reply>
-   *            > getNextRequest() - to get one request from the workload.
-   *  folly::dynamic makeConfigOutputs(
-   *      std::vector<Workload<HhvmHttpReplayService>*>)
-   */
-};
-
-} // namespace treadmill
-} // namespace windtunnel
-} // namespace facebook
